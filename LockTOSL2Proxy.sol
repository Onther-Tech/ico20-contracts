// Sources flattened with hardhat v2.13.1 https://hardhat.org

// File @openzeppelin/contracts/GSN/Context.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}


// File @openzeppelin/contracts/utils/Address.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.2 <0.8.0;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}


// File @openzeppelin/contracts/utils/EnumerableSet.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Library for managing
 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
 * types.
 *
 * Sets have the following properties:
 *
 * - Elements are added, removed, and checked for existence in constant time
 * (O(1)).
 * - Elements are enumerated in O(n). No guarantees are made on the ordering.
 *
 * ```
 * contract Example {
 *     // Add the library methods
 *     using EnumerableSet for EnumerableSet.AddressSet;
 *
 *     // Declare a set state variable
 *     EnumerableSet.AddressSet private mySet;
 * }
 * ```
 *
 * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)
 * and `uint256` (`UintSet`) are supported.
 */
library EnumerableSet {
    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Set type with
    // bytes32 values.
    // The Set implementation uses private functions, and user-facing
    // implementations (such as AddressSet) are just wrappers around the
    // underlying Set.
    // This means that we can only create new EnumerableSets for types that fit
    // in bytes32.

    struct Set {
        // Storage of set values
        bytes32[] _values;

        // Position of the value in the `values` array, plus 1 because index 0
        // means a value is not in the set.
        mapping (bytes32 => uint256) _indexes;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function _add(Set storage set, bytes32 value) private returns (bool) {
        if (!_contains(set, value)) {
            set._values.push(value);
            // The value is stored at length-1, but we add 1 to all indexes
            // and use 0 as a sentinel value
            set._indexes[value] = set._values.length;
            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function _remove(Set storage set, bytes32 value) private returns (bool) {
        // We read and store the value's index to prevent multiple reads from the same storage slot
        uint256 valueIndex = set._indexes[value];

        if (valueIndex != 0) { // Equivalent to contains(set, value)
            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
            // the array, and then remove the last element (sometimes called as 'swap and pop').
            // This modifies the order of the array, as noted in {at}.

            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = set._values.length - 1;

            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs
            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.

            bytes32 lastvalue = set._values[lastIndex];

            // Move the last value to the index where the value to delete is
            set._values[toDeleteIndex] = lastvalue;
            // Update the index for the moved value
            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based

            // Delete the slot where the moved value was stored
            set._values.pop();

            // Delete the index for the deleted slot
            delete set._indexes[value];

            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function _contains(Set storage set, bytes32 value) private view returns (bool) {
        return set._indexes[value] != 0;
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function _length(Set storage set) private view returns (uint256) {
        return set._values.length;
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function _at(Set storage set, uint256 index) private view returns (bytes32) {
        require(set._values.length > index, "EnumerableSet: index out of bounds");
        return set._values[index];
    }

    // Bytes32Set

    struct Bytes32Set {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
        return _add(set._inner, value);
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
        return _remove(set._inner, value);
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
        return _contains(set._inner, value);
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(Bytes32Set storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
        return _at(set._inner, index);
    }

    // AddressSet

    struct AddressSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(AddressSet storage set, address value) internal returns (bool) {
        return _add(set._inner, bytes32(uint256(value)));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(AddressSet storage set, address value) internal returns (bool) {
        return _remove(set._inner, bytes32(uint256(value)));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(AddressSet storage set, address value) internal view returns (bool) {
        return _contains(set._inner, bytes32(uint256(value)));
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(AddressSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function at(AddressSet storage set, uint256 index) internal view returns (address) {
        return address(uint256(_at(set._inner, index)));
    }


    // UintSet

    struct UintSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(UintSet storage set, uint256 value) internal returns (bool) {
        return _add(set._inner, bytes32(value));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(UintSet storage set, uint256 value) internal returns (bool) {
        return _remove(set._inner, bytes32(value));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(UintSet storage set, uint256 value) internal view returns (bool) {
        return _contains(set._inner, bytes32(value));
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function length(UintSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function at(UintSet storage set, uint256 index) internal view returns (uint256) {
        return uint256(_at(set._inner, index));
    }
}


// File @openzeppelin/contracts/access/AccessControl.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;



/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```
 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
abstract contract AccessControl is Context {
    using EnumerableSet for EnumerableSet.AddressSet;
    using Address for address;

    struct RoleData {
        EnumerableSet.AddressSet members;
        bytes32 adminRole;
    }

    mapping (bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {_setupRole}.
     */
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members.contains(account);
    }

    /**
     * @dev Returns the number of accounts that have `role`. Can be used
     * together with {getRoleMember} to enumerate all bearers of a role.
     */
    function getRoleMemberCount(bytes32 role) public view returns (uint256) {
        return _roles[role].members.length();
    }

    /**
     * @dev Returns one of the accounts that have `role`. `index` must be a
     * value between 0 and {getRoleMemberCount}, non-inclusive.
     *
     * Role bearers are not sorted in any particular way, and their ordering may
     * change at any point.
     *
     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure
     * you perform all queries on the same block. See the following
     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]
     * for more information.
     */
    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {
        return _roles[role].members.at(index);
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) public virtual {
        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to grant");

        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) public virtual {
        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to revoke");

        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) public virtual {
        require(account == _msgSender(), "AccessControl: can only renounce roles for self");

        _revokeRole(role, account);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event. Note that unlike {grantRole}, this function doesn't perform any
     * checks on the calling account.
     *
     * [WARNING]
     * ====
     * This function should only be called from the constructor when setting
     * up the initial roles for the system.
     *
     * Using this function in any other way is effectively circumventing the admin
     * system imposed by {AccessControl}.
     * ====
     */
    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);
        _roles[role].adminRole = adminRole;
    }

    function _grantRole(bytes32 role, address account) private {
        if (_roles[role].members.add(account)) {
            emit RoleGranted(role, account, _msgSender());
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (_roles[role].members.remove(account)) {
            emit RoleRevoked(role, account, _msgSender());
        }
    }
}


// File @openzeppelin/contracts/introspection/IERC165.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}


// File @openzeppelin/contracts/introspection/ERC165.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts may inherit from this and call {_registerInterface} to declare
 * their support of an interface.
 */
abstract contract ERC165 is IERC165 {
    /*
     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7
     */
    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;

    /**
     * @dev Mapping of interface ids to whether or not it's supported.
     */
    mapping(bytes4 => bool) private _supportedInterfaces;

    constructor () internal {
        // Derived contracts need only register support for their own interfaces,
        // we register support for ERC165 itself here
        _registerInterface(_INTERFACE_ID_ERC165);
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     *
     * Time complexity O(1), guaranteed to always use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {
        return _supportedInterfaces[interfaceId];
    }

    /**
     * @dev Registers the contract as an implementer of the interface defined by
     * `interfaceId`. Support of the actual ERC165 interface is automatic and
     * registering its interface id is not required.
     *
     * See {IERC165-supportsInterface}.
     *
     * Requirements:
     *
     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).
     */
    function _registerInterface(bytes4 interfaceId) internal virtual {
        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");
        _supportedInterfaces[interfaceId] = true;
    }
}


// File @openzeppelin/contracts/math/SafeMath.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}


// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}


// File @openzeppelin/contracts/token/ERC20/ERC20.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;



/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    /**
     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with
     * a default value of 18.
     *
     * To select a different value for {decimals}, use {_setupDecimals}.
     *
     * All three of these values are immutable: they can only be set once during
     * construction.
     */
    constructor (string memory name_, string memory symbol_) public {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is
     * called.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
        return _decimals;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Sets {decimals} to a value other than the default one of 18.
     *
     * WARNING: This function should only be called from the constructor. Most
     * applications that interact with token contracts will not expect
     * {decimals} to ever change, and may work incorrectly if it does.
     */
    function _setupDecimals(uint8 decimals_) internal {
        _decimals = decimals_;
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}


// File @openzeppelin/contracts/token/ERC20/ERC20Burnable.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;


/**
 * @dev Extension of {ERC20} that allows token holders to destroy both their own
 * tokens and those that they have an allowance for, in a way that can be
 * recognized off-chain (via event analysis).
 */
abstract contract ERC20Burnable is Context, ERC20 {
    using SafeMath for uint256;

    /**
     * @dev Destroys `amount` tokens from the caller.
     *
     * See {ERC20-_burn}.
     */
    function burn(uint256 amount) public virtual {
        _burn(_msgSender(), amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, deducting from the caller's
     * allowance.
     *
     * See {ERC20-_burn} and {ERC20-allowance}.
     *
     * Requirements:
     *
     * - the caller must have allowance for ``accounts``'s tokens of at least
     * `amount`.
     */
    function burnFrom(address account, uint256 amount) public virtual {
        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, "ERC20: burn amount exceeds allowance");

        _approve(account, _msgSender(), decreasedAllowance);
        _burn(account, amount);
    }
}


// File @openzeppelin/contracts/token/ERC20/SafeERC20.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;



/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}


// File @openzeppelin/contracts/token/ERC721/IERC721.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.2 <0.8.0;

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    /**
      * @dev Safely transfers `tokenId` token from `from` to `to`.
      *
      * Requirements:
      *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
      * - `tokenId` token must exist and be owned by `from`.
      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
      *
      * Emits a {Transfer} event.
      */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}


// File @openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.2 <0.8.0;

/**
 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721Enumerable is IERC721 {

    /**
     * @dev Returns the total amount of tokens stored by the contract.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
     */
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);

    /**
     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
     * Use along with {totalSupply} to enumerate all tokens.
     */
    function tokenByIndex(uint256 index) external view returns (uint256);
}


// File @openzeppelin/contracts/token/ERC721/IERC721Metadata.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.2 <0.8.0;

/**
 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721Metadata is IERC721 {

    /**
     * @dev Returns the token collection name.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the token collection symbol.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
     */
    function tokenURI(uint256 tokenId) external view returns (string memory);
}


// File @openzeppelin/contracts/math/Math.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library Math {
    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow, so we distribute
        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
    }
}


// File @openzeppelin/contracts/utils/Arrays.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Collection of functions related to array types.
 */
library Arrays {
   /**
     * @dev Searches a sorted `array` and returns the first index that contains
     * a value greater or equal to `element`. If no such index exists (i.e. all
     * values in the array are strictly less than `element`), the array length is
     * returned. Time complexity O(log n).
     *
     * `array` is expected to be sorted in ascending order, and to contain no
     * repeated elements.
     */
    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {
        if (array.length == 0) {
            return 0;
        }

        uint256 low = 0;
        uint256 high = array.length;

        while (low < high) {
            uint256 mid = Math.average(low, high);

            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
            // because Math.average rounds down (it does integer division with truncation).
            if (array[mid] > element) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.
        if (low > 0 && array[low - 1] == element) {
            return low - 1;
        } else {
            return low;
        }
    }
}


// File @openzeppelin/contracts/utils/Counters.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @title Counters
 * @author Matt Condon (@shrugs)
 * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number
 * of elements in a mapping, issuing ERC721 ids, or counting request ids.
 *
 * Include with `using Counters for Counters.Counter;`
 * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}
 * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never
 * directly accessed.
 */
library Counters {
    using SafeMath for uint256;

    struct Counter {
        // This variable should never be directly accessed by users of the library: interactions must be restricted to
        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
        // this feature: see https://github.com/ethereum/solidity/issues/4637
        uint256 _value; // default: 0
    }

    function current(Counter storage counter) internal view returns (uint256) {
        return counter._value;
    }

    function increment(Counter storage counter) internal {
        // The {SafeMath} overflow check can be skipped here, see the comment at the top
        counter._value += 1;
    }

    function decrement(Counter storage counter) internal {
        counter._value = counter._value.sub(1);
    }
}


// File @uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol@v1.0.0

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Permissionless pool actions
/// @notice Contains pool methods that can be called by anyone
interface IUniswapV3PoolActions {
    /// @notice Sets the initial price for the pool
    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value
    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96
    function initialize(uint160 sqrtPriceX96) external;

    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
    /// on tickLower, tickUpper, the amount of liquidity, and the current price.
    /// @param recipient The address for which the liquidity will be created
    /// @param tickLower The lower tick of the position in which to add liquidity
    /// @param tickUpper The upper tick of the position in which to add liquidity
    /// @param amount The amount of liquidity to mint
    /// @param data Any data that should be passed through to the callback
    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
    function mint(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount,
        bytes calldata data
    ) external returns (uint256 amount0, uint256 amount1);

    /// @notice Collects tokens owed to a position
    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
    /// @param recipient The address which should receive the fees collected
    /// @param tickLower The lower tick of the position for which to collect fees
    /// @param tickUpper The upper tick of the position for which to collect fees
    /// @param amount0Requested How much token0 should be withdrawn from the fees owed
    /// @param amount1Requested How much token1 should be withdrawn from the fees owed
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount0Requested,
        uint128 amount1Requested
    ) external returns (uint128 amount0, uint128 amount1);

    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
    /// @dev Fees must be collected separately via a call to #collect
    /// @param tickLower The lower tick of the position for which to burn liquidity
    /// @param tickUpper The upper tick of the position for which to burn liquidity
    /// @param amount How much liquidity to burn
    /// @return amount0 The amount of token0 sent to the recipient
    /// @return amount1 The amount of token1 sent to the recipient
    function burn(
        int24 tickLower,
        int24 tickUpper,
        uint128 amount
    ) external returns (uint256 amount0, uint256 amount1);

    /// @notice Swap token0 for token1, or token1 for token0
    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
    /// @param recipient The address to receive the output of the swap
    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
    /// @param data Any data to be passed through to the callback
    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external returns (int256 amount0, int256 amount1);

    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback
    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback
    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling
    /// with 0 amount{0,1} and sending the donation amount(s) from the callback
    /// @param recipient The address which will receive the token0 and token1 amounts
    /// @param amount0 The amount of token0 to send
    /// @param amount1 The amount of token1 to send
    /// @param data Any data to be passed through to the callback
    function flash(
        address recipient,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external;

    /// @notice Increase the maximum number of price and liquidity observations that this pool will store
    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to
    /// the input observationCardinalityNext.
    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store
    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
}


// File @uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol@v1.0.0

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Pool state that is not stored
/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the
/// blockchain. The functions here may have variable gas costs.
interface IUniswapV3PoolDerivedState {
    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
    /// you must call it with secondsAgos = [3600, 0].
    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned
    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp
    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block
    /// timestamp
    function observe(uint32[] calldata secondsAgos)
        external
        view
        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);

    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range
    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.
    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first
    /// snapshot is taken and the second snapshot is taken.
    /// @param tickLower The lower tick of the range
    /// @param tickUpper The upper tick of the range
    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range
    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range
    /// @return secondsInside The snapshot of seconds per liquidity for the range
    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)
        external
        view
        returns (
            int56 tickCumulativeInside,
            uint160 secondsPerLiquidityInsideX128,
            uint32 secondsInside
        );
}


// File @uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol@v1.0.0

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Events emitted by a pool
/// @notice Contains all events emitted by the pool
interface IUniswapV3PoolEvents {
    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool
    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize
    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96
    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool
    event Initialize(uint160 sqrtPriceX96, int24 tick);

    /// @notice Emitted when liquidity is minted for a given position
    /// @param sender The address that minted the liquidity
    /// @param owner The owner of the position and recipient of any minted liquidity
    /// @param tickLower The lower tick of the position
    /// @param tickUpper The upper tick of the position
    /// @param amount The amount of liquidity minted to the position range
    /// @param amount0 How much token0 was required for the minted liquidity
    /// @param amount1 How much token1 was required for the minted liquidity
    event Mint(
        address sender,
        address indexed owner,
        int24 indexed tickLower,
        int24 indexed tickUpper,
        uint128 amount,
        uint256 amount0,
        uint256 amount1
    );

    /// @notice Emitted when fees are collected by the owner of a position
    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees
    /// @param owner The owner of the position for which fees are collected
    /// @param tickLower The lower tick of the position
    /// @param tickUpper The upper tick of the position
    /// @param amount0 The amount of token0 fees collected
    /// @param amount1 The amount of token1 fees collected
    event Collect(
        address indexed owner,
        address recipient,
        int24 indexed tickLower,
        int24 indexed tickUpper,
        uint128 amount0,
        uint128 amount1
    );

    /// @notice Emitted when a position's liquidity is removed
    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect
    /// @param owner The owner of the position for which liquidity is removed
    /// @param tickLower The lower tick of the position
    /// @param tickUpper The upper tick of the position
    /// @param amount The amount of liquidity to remove
    /// @param amount0 The amount of token0 withdrawn
    /// @param amount1 The amount of token1 withdrawn
    event Burn(
        address indexed owner,
        int24 indexed tickLower,
        int24 indexed tickUpper,
        uint128 amount,
        uint256 amount0,
        uint256 amount1
    );

    /// @notice Emitted by the pool for any swaps between token0 and token1
    /// @param sender The address that initiated the swap call, and that received the callback
    /// @param recipient The address that received the output of the swap
    /// @param amount0 The delta of the token0 balance of the pool
    /// @param amount1 The delta of the token1 balance of the pool
    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96
    /// @param liquidity The liquidity of the pool after the swap
    /// @param tick The log base 1.0001 of price of the pool after the swap
    event Swap(
        address indexed sender,
        address indexed recipient,
        int256 amount0,
        int256 amount1,
        uint160 sqrtPriceX96,
        uint128 liquidity,
        int24 tick
    );

    /// @notice Emitted by the pool for any flashes of token0/token1
    /// @param sender The address that initiated the swap call, and that received the callback
    /// @param recipient The address that received the tokens from flash
    /// @param amount0 The amount of token0 that was flashed
    /// @param amount1 The amount of token1 that was flashed
    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee
    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee
    event Flash(
        address indexed sender,
        address indexed recipient,
        uint256 amount0,
        uint256 amount1,
        uint256 paid0,
        uint256 paid1
    );

    /// @notice Emitted by the pool for increases to the number of observations that can be stored
    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index
    /// just before a mint/swap/burn.
    /// @param observationCardinalityNextOld The previous value of the next observation cardinality
    /// @param observationCardinalityNextNew The updated value of the next observation cardinality
    event IncreaseObservationCardinalityNext(
        uint16 observationCardinalityNextOld,
        uint16 observationCardinalityNextNew
    );

    /// @notice Emitted when the protocol fee is changed by the pool
    /// @param feeProtocol0Old The previous value of the token0 protocol fee
    /// @param feeProtocol1Old The previous value of the token1 protocol fee
    /// @param feeProtocol0New The updated value of the token0 protocol fee
    /// @param feeProtocol1New The updated value of the token1 protocol fee
    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);

    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner
    /// @param sender The address that collects the protocol fees
    /// @param recipient The address that receives the collected protocol fees
    /// @param amount0 The amount of token0 protocol fees that is withdrawn
    /// @param amount0 The amount of token1 protocol fees that is withdrawn
    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
}


// File @uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol@v1.0.0

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Pool state that never changes
/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values
interface IUniswapV3PoolImmutables {
    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface
    /// @return The contract address
    function factory() external view returns (address);

    /// @notice The first of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token0() external view returns (address);

    /// @notice The second of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token1() external view returns (address);

    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
    /// @return The fee
    function fee() external view returns (uint24);

    /// @notice The pool tick spacing
    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
    /// This value is an int24 to avoid casting even though it is always positive.
    /// @return The tick spacing
    function tickSpacing() external view returns (int24);

    /// @notice The maximum amount of position liquidity that can use any tick in the range
    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and
    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool
    /// @return The max amount of liquidity per tick
    function maxLiquidityPerTick() external view returns (uint128);
}


// File @uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol@v1.0.0

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Permissioned pool actions
/// @notice Contains pool methods that may only be called by the factory owner
interface IUniswapV3PoolOwnerActions {
    /// @notice Set the denominator of the protocol's % share of the fees
    /// @param feeProtocol0 new protocol fee for token0 of the pool
    /// @param feeProtocol1 new protocol fee for token1 of the pool
    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;

    /// @notice Collect the protocol fee accrued to the pool
    /// @param recipient The address to which collected protocol fees should be sent
    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1
    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0
    /// @return amount0 The protocol fee collected in token0
    /// @return amount1 The protocol fee collected in token1
    function collectProtocol(
        address recipient,
        uint128 amount0Requested,
        uint128 amount1Requested
    ) external returns (uint128 amount0, uint128 amount1);
}


// File @uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol@v1.0.0

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Pool state that can change
/// @notice These methods compose the pool's state, and can change with any frequency including multiple times
/// per transaction
interface IUniswapV3PoolState {
    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
    /// when accessed externally.
    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
    /// boundary.
    /// observationIndex The index of the last oracle observation that was written,
    /// observationCardinality The current maximum number of observations stored in the pool,
    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
    /// feeProtocol The protocol fee for both tokens of the pool.
    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
    /// unlocked Whether the pool is currently locked to reentrancy
    function slot0()
        external
        view
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        );

    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
    /// @dev This value can overflow the uint256
    function feeGrowthGlobal0X128() external view returns (uint256);

    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
    /// @dev This value can overflow the uint256
    function feeGrowthGlobal1X128() external view returns (uint256);

    /// @notice The amounts of token0 and token1 that are owed to the protocol
    /// @dev Protocol fees will never exceed uint128 max in either token
    function protocolFees() external view returns (uint128 token0, uint128 token1);

    /// @notice The currently in range liquidity available to the pool
    /// @dev This value has no relationship to the total liquidity across all ticks
    function liquidity() external view returns (uint128);

    /// @notice Look up information about a specific tick in the pool
    /// @param tick The tick to look up
    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or
    /// tick upper,
    /// liquidityNet how much liquidity changes when the pool price crosses the tick,
    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,
    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,
    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick
    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,
    /// secondsOutside the seconds spent on the other side of the tick from the current tick,
    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.
    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.
    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for
    /// a specific position.
    function ticks(int24 tick)
        external
        view
        returns (
            uint128 liquidityGross,
            int128 liquidityNet,
            uint256 feeGrowthOutside0X128,
            uint256 feeGrowthOutside1X128,
            int56 tickCumulativeOutside,
            uint160 secondsPerLiquidityOutsideX128,
            uint32 secondsOutside,
            bool initialized
        );

    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information
    function tickBitmap(int16 wordPosition) external view returns (uint256);

    /// @notice Returns the information about a position by the position's key
    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
    /// @return _liquidity The amount of liquidity in the position,
    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
    function positions(bytes32 key)
        external
        view
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    /// @notice Returns data about a specific observation index
    /// @param index The element of the observations array to fetch
    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time
    /// ago, rather than at a specific index in the array.
    /// @return blockTimestamp The timestamp of the observation,
    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,
    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,
    /// Returns initialized whether the observation has been initialized and the values are safe to use
    function observations(uint256 index)
        external
        view
        returns (
            uint32 blockTimestamp,
            int56 tickCumulative,
            uint160 secondsPerLiquidityCumulativeX128,
            bool initialized
        );
}


// File @uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol@v1.0.0

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;






/// @title The interface for a Uniswap V3 Pool
/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform
/// to the ERC20 specification
/// @dev The pool interface is broken up into many smaller pieces
interface IUniswapV3Pool is
    IUniswapV3PoolImmutables,
    IUniswapV3PoolState,
    IUniswapV3PoolDerivedState,
    IUniswapV3PoolActions,
    IUniswapV3PoolOwnerActions,
    IUniswapV3PoolEvents
{

}


// File @uniswap/v3-periphery/contracts/interfaces/IERC721Permit.sol@v1.4.3

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.7.5;

/// @title ERC721 with permit
/// @notice Extension to ERC721 that includes a permit function for signature based approvals
interface IERC721Permit is IERC721 {
    /// @notice The permit typehash used in the permit signature
    /// @return The typehash for the permit
    function PERMIT_TYPEHASH() external pure returns (bytes32);

    /// @notice The domain separator used in the permit signature
    /// @return The domain seperator used in encoding of permit signature
    function DOMAIN_SEPARATOR() external view returns (bytes32);

    /// @notice Approve of a specific token ID for spending by spender via signature
    /// @param spender The account that is being approved
    /// @param tokenId The ID of the token that is being approved for spending
    /// @param deadline The deadline timestamp by which the call must be mined for the approve to work
    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
    function permit(
        address spender,
        uint256 tokenId,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external payable;
}


// File @uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol@v1.4.3

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Immutable state
/// @notice Functions that return immutable state of the router
interface IPeripheryImmutableState {
    /// @return Returns the address of the Uniswap V3 factory
    function factory() external view returns (address);

    /// @return Returns the address of WETH9
    function WETH9() external view returns (address);
}


// File @uniswap/v3-periphery/contracts/interfaces/IPeripheryPayments.sol@v1.4.3

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.7.5;

/// @title Periphery Payments
/// @notice Functions to ease deposits and withdrawals of ETH
interface IPeripheryPayments {
    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.
    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.
    /// @param amountMinimum The minimum amount of WETH9 to unwrap
    /// @param recipient The address receiving ETH
    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;

    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`
    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps
    /// that use ether for the input amount
    function refundETH() external payable;

    /// @notice Transfers the full amount of a token held by this contract to recipient
    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users
    /// @param token The contract address of the token which will be transferred to `recipient`
    /// @param amountMinimum The minimum amount of token required for a transfer
    /// @param recipient The destination address of the token
    function sweepToken(
        address token,
        uint256 amountMinimum,
        address recipient
    ) external payable;
}


// File @uniswap/v3-periphery/contracts/interfaces/IPoolInitializer.sol@v1.4.3

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.7.5;
pragma abicoder v2;

/// @title Creates and initializes V3 Pools
/// @notice Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that
/// require the pool to exist.
interface IPoolInitializer {
    /// @notice Creates a new pool if it does not exist, then initializes if not initialized
    /// @dev This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool
    /// @param token0 The contract address of token0 of the pool
    /// @param token1 The contract address of token1 of the pool
    /// @param fee The fee amount of the v3 pool for the specified token pair
    /// @param sqrtPriceX96 The initial square root price of the pool as a Q64.96 value
    /// @return pool Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary
    function createAndInitializePoolIfNecessary(
        address token0,
        address token1,
        uint24 fee,
        uint160 sqrtPriceX96
    ) external payable returns (address pool);
}


// File @uniswap/v3-periphery/contracts/libraries/PoolAddress.sol@v1.4.3

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee
library PoolAddress {
    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;

    /// @notice The identifying key of the pool
    struct PoolKey {
        address token0;
        address token1;
        uint24 fee;
    }

    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels
    /// @param tokenA The first token of a pool, unsorted
    /// @param tokenB The second token of a pool, unsorted
    /// @param fee The fee level of the pool
    /// @return Poolkey The pool details with ordered token0 and token1 assignments
    function getPoolKey(
        address tokenA,
        address tokenB,
        uint24 fee
    ) internal pure returns (PoolKey memory) {
        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);
        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});
    }

    /// @notice Deterministically computes the pool address given the factory and PoolKey
    /// @param factory The Uniswap V3 factory contract address
    /// @param key The PoolKey
    /// @return pool The contract address of the V3 pool
    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {
        require(key.token0 < key.token1);
        pool = address(
            uint256(
                keccak256(
                    abi.encodePacked(
                        hex'ff',
                        factory,
                        keccak256(abi.encode(key.token0, key.token1, key.fee)),
                        POOL_INIT_CODE_HASH
                    )
                )
            )
        );
    }
}


// File @uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol@v1.4.3

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.7.5;
pragma abicoder v2;






/// @title Non-fungible token for positions
/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred
/// and authorized.
interface INonfungiblePositionManager is
    IPoolInitializer,
    IPeripheryPayments,
    IPeripheryImmutableState,
    IERC721Metadata,
    IERC721Enumerable,
    IERC721Permit
{
    /// @notice Emitted when liquidity is increased for a position NFT
    /// @dev Also emitted when a token is minted
    /// @param tokenId The ID of the token for which liquidity was increased
    /// @param liquidity The amount by which liquidity for the NFT position was increased
    /// @param amount0 The amount of token0 that was paid for the increase in liquidity
    /// @param amount1 The amount of token1 that was paid for the increase in liquidity
    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
    /// @notice Emitted when liquidity is decreased for a position NFT
    /// @param tokenId The ID of the token for which liquidity was decreased
    /// @param liquidity The amount by which liquidity for the NFT position was decreased
    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity
    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity
    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
    /// @notice Emitted when tokens are collected for a position NFT
    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior
    /// @param tokenId The ID of the token for which underlying tokens were collected
    /// @param recipient The address of the account that received the collected tokens
    /// @param amount0 The amount of token0 owed to the position that was collected
    /// @param amount1 The amount of token1 owed to the position that was collected
    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);

    /// @notice Returns the position information associated with a given token ID.
    /// @dev Throws if the token ID is not valid.
    /// @param tokenId The ID of the token that represents the position
    /// @return nonce The nonce for permits
    /// @return operator The address that is approved for spending
    /// @return token0 The address of the token0 for a specific pool
    /// @return token1 The address of the token1 for a specific pool
    /// @return fee The fee associated with the pool
    /// @return tickLower The lower end of the tick range for the position
    /// @return tickUpper The higher end of the tick range for the position
    /// @return liquidity The liquidity of the position
    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position
    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position
    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation
    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation
    function positions(uint256 tokenId)
        external
        view
        returns (
            uint96 nonce,
            address operator,
            address token0,
            address token1,
            uint24 fee,
            int24 tickLower,
            int24 tickUpper,
            uint128 liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    struct MintParams {
        address token0;
        address token1;
        uint24 fee;
        int24 tickLower;
        int24 tickUpper;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        address recipient;
        uint256 deadline;
    }

    /// @notice Creates a new position wrapped in a NFT
    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized
    /// a method does not exist, i.e. the pool is assumed to be initialized.
    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata
    /// @return tokenId The ID of the token that represents the minted position
    /// @return liquidity The amount of liquidity for this position
    /// @return amount0 The amount of token0
    /// @return amount1 The amount of token1
    function mint(MintParams calldata params)
        external
        payable
        returns (
            uint256 tokenId,
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    struct IncreaseLiquidityParams {
        uint256 tokenId;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`
    /// @param params tokenId The ID of the token for which liquidity is being increased,
    /// amount0Desired The desired amount of token0 to be spent,
    /// amount1Desired The desired amount of token1 to be spent,
    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,
    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return liquidity The new liquidity amount as a result of the increase
    /// @return amount0 The amount of token0 to acheive resulting liquidity
    /// @return amount1 The amount of token1 to acheive resulting liquidity
    function increaseLiquidity(IncreaseLiquidityParams calldata params)
        external
        payable
        returns (
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    struct DecreaseLiquidityParams {
        uint256 tokenId;
        uint128 liquidity;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    /// @notice Decreases the amount of liquidity in a position and accounts it to the position
    /// @param params tokenId The ID of the token for which liquidity is being decreased,
    /// amount The amount by which liquidity will be decreased,
    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,
    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return amount0 The amount of token0 accounted to the position's tokens owed
    /// @return amount1 The amount of token1 accounted to the position's tokens owed
    function decreaseLiquidity(DecreaseLiquidityParams calldata params)
        external
        payable
        returns (uint256 amount0, uint256 amount1);

    struct CollectParams {
        uint256 tokenId;
        address recipient;
        uint128 amount0Max;
        uint128 amount1Max;
    }

    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient
    /// @param params tokenId The ID of the NFT for which tokens are being collected,
    /// recipient The account that should receive the tokens,
    /// amount0Max The maximum amount of token0 to collect,
    /// amount1Max The maximum amount of token1 to collect
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);

    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens
    /// must be collected first.
    /// @param tokenId The ID of the token that is being burned
    function burn(uint256 tokenId) external payable;
}


// File @uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol@v1.0.0

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Callback for IUniswapV3PoolActions#swap
/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface
interface IUniswapV3SwapCallback {
    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.
    /// @dev In the implementation you must pay the pool tokens owed for the swap.
    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.
    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by
    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.
    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by
    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.
    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call
    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata data
    ) external;
}


// File @uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol@v1.4.3

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.7.5;
pragma abicoder v2;

/// @title Router token swapping functionality
/// @notice Functions for swapping tokens via Uniswap V3
interface ISwapRouter is IUniswapV3SwapCallback {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps `amountIn` of one token for as much as possible of another token
    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata
    /// @return amountOut The amount of the received token
    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);

    struct ExactInputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
    }

    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path
    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata
    /// @return amountOut The amount of the received token
    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);

    struct ExactOutputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps as little as possible of one token for `amountOut` of another token
    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata
    /// @return amountIn The amount of the input token
    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);

    struct ExactOutputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
    }

    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)
    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata
    /// @return amountIn The amount of the input token
    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);
}


// File @uniswap/v3-periphery/contracts/libraries/TransferHelper.sol@v1.4.3

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.6.0;

library TransferHelper {
    /// @notice Transfers tokens from the targeted address to the given destination
    /// @notice Errors with 'STF' if transfer fails
    /// @param token The contract address of the token to be transferred
    /// @param from The originating address from which the tokens will be transferred
    /// @param to The destination address of the transfer
    /// @param value The amount to be transferred
    function safeTransferFrom(
        address token,
        address from,
        address to,
        uint256 value
    ) internal {
        (bool success, bytes memory data) =
            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');
    }

    /// @notice Transfers tokens from msg.sender to a recipient
    /// @dev Errors with ST if transfer fails
    /// @param token The contract address of the token which will be transferred
    /// @param to The recipient of the transfer
    /// @param value The value of the transfer
    function safeTransfer(
        address token,
        address to,
        uint256 value
    ) internal {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');
    }

    /// @notice Approves the stipulated contract to spend the given allowance in the given token
    /// @dev Errors with 'SA' if transfer fails
    /// @param token The contract address of the token to be approved
    /// @param to The target of the approval
    /// @param value The amount of the given token the target will be allowed to spend
    function safeApprove(
        address token,
        address to,
        uint256 value
    ) internal {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');
    }

    /// @notice Transfers ETH to the recipient address
    /// @dev Fails with `STE`
    /// @param to The destination of the transfer
    /// @param value The value to be transferred
    function safeTransferETH(address to, uint256 value) internal {
        (bool success, ) = to.call{value: value}(new bytes(0));
        require(success, 'STE');
    }
}


// File contracts/common/AccessRoleCommon.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

contract AccessRoleCommon {
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN");
    bytes32 public constant MINTER_ROLE = keccak256("MINTER");
    bytes32 public constant BURNER_ROLE = keccak256("BURNER");
    bytes32 public constant PROJECT_ADMIN_ROLE = keccak256("PROJECT_ADMIN_ROLE");
}


// File contracts/common/AccessibleCommon.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;


contract AccessibleCommon is AccessRoleCommon, AccessControl {
    modifier onlyOwner() {
        require(isAdmin(msg.sender), "Accessible: Caller is not an admin");
        _;
    }

    /// @dev add admin
    /// @param account  address to add
    function addAdmin(address account) public virtual onlyOwner {
        grantRole(ADMIN_ROLE, account);
    }

    /// @dev remove admin
    /// @param account  address to remove
    function removeAdmin(address account) public virtual onlyOwner {
        renounceRole(ADMIN_ROLE, account);
    }

    /// @dev transfer admin
    /// @param newAdmin new admin address
    function transferAdmin(address newAdmin) external virtual onlyOwner {
        require(newAdmin != address(0), "Accessible: zero address");
        require(msg.sender != newAdmin, "Accessible: same admin");

        grantRole(ADMIN_ROLE, newAdmin);
        renounceRole(ADMIN_ROLE, msg.sender);
    }

    /// @dev whether admin
    /// @param account  address to check
    function isAdmin(address account) public view virtual returns (bool) {
        return hasRole(ADMIN_ROLE, account);
    }
}


// File contracts/common/AccessiblePlusCommon.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

contract AccessiblePlusCommon is AccessibleCommon {
    modifier onlyMinter() {
        require(
            isMinter(msg.sender),
            "AccessiblePlusCommon: Caller is not a minter"
        );
        _;
    }
    modifier onlyBurner() {
        require(
            isBurner(msg.sender),
            "AccessiblePlusCommon: Caller is not a burner"
        );
        _;
    }

    function isMinter(address account) public view virtual returns (bool) {
        return hasRole(MINTER_ROLE, account);
    }

    function isBurner(address account) public view virtual returns (bool) {
        return hasRole(BURNER_ROLE, account);
    }

    function addMinter(address account) public virtual onlyOwner {
        grantRole(MINTER_ROLE, account);
    }

    function addBurner(address account) public virtual onlyOwner {
        grantRole(BURNER_ROLE, account);
    }

    function removeMinter(address account) public virtual onlyOwner {
        revokeRole(MINTER_ROLE, account);
    }

    function removeBurner(address account) public virtual onlyOwner {
        revokeRole(BURNER_ROLE, account);
    }
}


// File contracts/common/ProxyAccessCommon.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;


contract ProxyAccessCommon is AccessRoleCommon, AccessControl {
    modifier onlyOwner() {
        require(isAdmin(msg.sender) || isProxyAdmin(msg.sender), "Accessible: Caller is not an admin");
        _;
    }

    modifier onlyProxyOwner() {
        require(isProxyAdmin(msg.sender), "Accessible: Caller is not an proxy admin");
        _;
    }

    function addProxyAdmin(address _owner)
        external
        onlyProxyOwner
    {
        _setupRole(DEFAULT_ADMIN_ROLE, _owner);
    }

    function removeProxyAdmin()
        public virtual onlyProxyOwner
    {
        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function transferProxyAdmin(address newAdmin)
        external virtual
        onlyProxyOwner
    {
        require(newAdmin != address(0), "Accessible: zero address");
        require(msg.sender != newAdmin, "Accessible: same admin");

        grantRole(DEFAULT_ADMIN_ROLE, newAdmin);
        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }


    /// @dev add admin
    /// @param account  address to add
    function addAdmin(address account) public virtual onlyProxyOwner {
        grantRole(PROJECT_ADMIN_ROLE, account);
    }

    /// @dev remove admin
    function removeAdmin() public virtual onlyOwner {
        renounceRole(PROJECT_ADMIN_ROLE, msg.sender);
    }

    /// @dev transfer admin
    /// @param newAdmin new admin address
    function transferAdmin(address newAdmin) external virtual onlyOwner {
        require(newAdmin != address(0), "Accessible: zero address");
        require(msg.sender != newAdmin, "Accessible: same admin");

        grantRole(PROJECT_ADMIN_ROLE, newAdmin);
        renounceRole(PROJECT_ADMIN_ROLE, msg.sender);
    }

    /// @dev whether admin
    /// @param account  address to check
    function isAdmin(address account) public view virtual returns (bool) {
        return hasRole(PROJECT_ADMIN_ROLE, account);
    }

    function isProxyAdmin(address account) public view virtual returns (bool) {
        return hasRole(DEFAULT_ADMIN_ROLE, account);
    }
}


// File contracts/interfaces/IIDepositManager.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

interface IIDepositManager {
    function globalWithdrawalDelay()
        external
        view
        returns (uint256 withdrawalDelay);

    function accStaked(address layer2, address account)
        external
        view
        returns (uint256 wtonAmount);

    function pendingUnstaked(address layer2, address account)
        external
        view
        returns (uint256 wtonAmount);

    function accUnstaked(address layer2, address account)
        external
        view
        returns (uint256 wtonAmount);

    function deposit(address layer2, uint256 amount) external returns (bool);

    function requestWithdrawal(address layer2, uint256 amount)
        external
        returns (bool);

    function processRequest(address layer2, bool receiveTON)
        external
        returns (bool);

    function requestWithdrawalAll(address layer2) external returns (bool);

    function processRequests(
        address layer2,
        uint256 n,
        bool receiveTON
    ) external returns (bool);
}


// File contracts/interfaces/IISeigManager.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

interface IISeigManager {
    function stakeOf(address layer2, address account)
        external
        view
        returns (uint256);
}


// File contracts/interfaces/IIStake1Vault.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IIStake1Vault {
    function closeSale() external;

    function totalRewardAmount(address _account)
        external
        view
        returns (uint256);

    function claim(address _to, uint256 _amount) external returns (bool);

    function orderedEndBlocksAll() external view returns (uint256[] memory);

    function blockTotalReward() external view returns (uint256);

    function stakeEndBlockTotal(uint256 endblock)
        external
        view
        returns (uint256 totalStakedAmount);

    function saleClosed() external view returns (bool);
}


// File contracts/interfaces/ITokamakStaker.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface ITokamakStaker {
    /// @dev set the tokamak Layer2 address
    /// @param _layer2 new the tokamak Layer2 address
    function setTokamakLayer2(address _layer2) external;

    /// @dev get the addresses yhat used in uniswap interfaces
    /// @return uniswapRouter the address of uniswapV3 Router
    /// @return npm the address of positionManagerAddress
    /// @return ext the address of ext
    /// @return fee the amount of fee
    /// @return uniswapV2Router uniswapV2 router address
    function getUniswapInfo()
        external
        view
        returns (
            address uniswapRouter,
            address npm,
            address ext,
            uint256 fee,
            address uniswapV2Router
        );

    /// @dev Change the TON holded in contract have to WTON, or change WTON to TON.
    /// @param amount the amount to be changed
    /// @param toWTON if it's true, TON->WTON , else WTON->TON
    function swapTONtoWTON(uint256 amount, bool toWTON) external;

    /// @dev  staking the staked TON in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    /// @param stakeAmount the amount that stake to layer2
    function tokamakStaking(address _layer2, uint256 stakeAmount) external;

    /// @dev  request unstaking the wtonAmount in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    /// @param wtonAmount the amount requested to unstaking
    function tokamakRequestUnStaking(address _layer2, uint256 wtonAmount)
        external;

    /// @dev  request unstaking the wtonAmount in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    function tokamakRequestUnStakingAll(address _layer2) external;

    /// @dev process unstaking in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    function tokamakProcessUnStaking(address _layer2) external;

    /// @dev exchange holded WTON to TOS using uniswap-v3
    /// @param _amountIn the input amount
    /// @param _amountOutMinimum the minimun output amount
    /// @param _deadline deadline
    /// @param _sqrtPriceLimitX96 sqrtPriceLimitX96
    /// @param _kind the function type, if 0, use exactInputSingle function, else if, use exactInput function
    function exchangeWTONtoTOS(
        uint256 _amountIn,
        uint256 _amountOutMinimum,
        uint256 _deadline,
        uint160 _sqrtPriceLimitX96,
        uint256 _kind
    ) external returns (uint256 amountOut);
}


// File contracts/interfaces/ITON.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

interface ITON {
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    function approveAndCall(
        address spender,
        uint256 amount,
        bytes memory data
    ) external returns (bool);

    function balanceOf(address account) external view returns (uint256);

    function onApprove(
        address owner,
        address spender,
        uint256 tonAmount,
        bytes calldata data
    ) external returns (bool);

    function burnFrom(address account, uint256 amount) external;

    function swapToTON(uint256 wtonAmount) external returns (bool);

    function swapFromTON(uint256 tonAmount) external returns (bool);

    function swapToTONAndTransfer(address to, uint256 wtonAmount)
        external
        returns (bool);

    function swapFromTONAndTransfer(address to, uint256 tonAmount)
        external
        returns (bool);

    function renounceTonMinter() external;
}


// File contracts/libraries/LibTokenStake1.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

library LibTokenStake1 {
    enum DefiStatus {
        NONE,
        APPROVE,
        DEPOSITED,
        REQUESTWITHDRAW,
        REQUESTWITHDRAWALL,
        WITHDRAW,
        END
    }
    struct DefiInfo {
        string name;
        address router;
        address ext1;
        address ext2;
        uint256 fee;
        address routerV2;
    }
    struct StakeInfo {
        string name;
        uint256 startBlock;
        uint256 endBlock;
        uint256 balance;
        uint256 totalRewardAmount;
        uint256 claimRewardAmount;
    }

    struct StakedAmount {
        uint256 amount;
        uint256 claimedBlock;
        uint256 claimedAmount;
        uint256 releasedBlock;
        uint256 releasedAmount;
        uint256 releasedTOSAmount;
        bool released;
    }

    struct StakedAmountForSTOS {
        uint256 amount;
        uint256 startBlock;
        uint256 periodBlock;
        uint256 rewardPerBlock;
        uint256 claimedBlock;
        uint256 claimedAmount;
        uint256 releasedBlock;
        uint256 releasedAmount;
    }
}


// File contracts/stake/Stake1Storage.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

/// @title The base storage of stakeContract
contract Stake1Storage {
    /// @dev reward token : TOS
    address public token;

    /// @dev registry
    address public stakeRegistry;

    /// @dev paytoken is the token that the user stakes. ( if paytoken is ether, paytoken is address(0) )
    address public paytoken;

    /// @dev A vault that holds TOS rewards.
    address public vault;

    /// @dev the start block for sale.
    uint256 public saleStartBlock;

    /// @dev the staking start block, once staking starts, users can no longer apply for staking.
    uint256 public startBlock;

    /// @dev the staking end block.
    uint256 public endBlock;

    /// @dev the total amount claimed
    uint256 public rewardClaimedTotal;

    /// @dev the total staked amount
    uint256 public totalStakedAmount;

    /// @dev information staked by user
    mapping(address => LibTokenStake1.StakedAmount) public userStaked;

    /// @dev total stakers
    uint256 public totalStakers;

    uint256 internal _lock;

    /// @dev flag for pause proxy
    bool public pauseProxy;

    /// @dev extra address storage
    address public defiAddr;

    ///@dev for migrate L2
    bool public migratedL2;

    /// @dev user's staked information
    function getUserStaked(address user)
        external
        view
        returns (
            uint256 amount,
            uint256 claimedBlock,
            uint256 claimedAmount,
            uint256 releasedBlock,
            uint256 releasedAmount,
            uint256 releasedTOSAmount,
            bool released
        )
    {
        return (
            userStaked[user].amount,
            userStaked[user].claimedBlock,
            userStaked[user].claimedAmount,
            userStaked[user].releasedBlock,
            userStaked[user].releasedAmount,
            userStaked[user].releasedTOSAmount,
            userStaked[user].released
        );
    }

    /// @dev Give the infomation of this stakeContracts
    /// @return paytoken, vault, [saleStartBlock, startBlock, endBlock], rewardClaimedTotal, totalStakedAmount, totalStakers
    function infos()
        external
        view
        returns (
            address,
            address,
            uint256[3] memory,
            uint256,
            uint256,
            uint256
        )
    {
        return (
            paytoken,
            vault,
            [saleStartBlock, startBlock, endBlock],
            rewardClaimedTotal,
            totalStakedAmount,
            totalStakers
        );
    }
}


// File contracts/stake/StakeTONStorage.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

/// @title the storage of StakeTONStorage
contract StakeTONStorage is Stake1Storage {
    /// @dev TON address
    address public ton;

    /// @dev WTON address
    address public wton;

    /// @dev SeigManager address
    address public seigManager;

    /// @dev DepositManager address
    address public depositManager;

    /// @dev swapProxy address
    address public swapProxy;

    /// @dev the layer2 address in Tokamak
    address public tokamakLayer2;

    /// @dev the accumulated TON amount staked into tokamak , in wei unit
    uint256 public toTokamak;

    /// @dev the accumulated WTON amount unstaked from tokamak , in ray unit
    uint256 public fromTokamak;

    /// @dev the accumulated WTON amount swapped using uniswap , in ray unit
    uint256 public toUniswapWTON;

    /// @dev the TOS balance in this contract
    uint256 public swappedAmountTOS;

    /// @dev the TON balance in this contract when withdraw at first
    uint256 public finalBalanceTON;

    /// @dev the WTON balance in this contract when withdraw at first
    uint256 public finalBalanceWTON;

    /// @dev defi status
    uint256 public defiStatus;

    /// @dev the number of requesting unstaking to tokamak , when process unstaking, reset zero.
    uint256 public requestNum;

    /// @dev the withdraw flag, when withdraw at first, set true
    bool public withdrawFlag;
}


// File contracts/connection/TokamakStaker.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;
pragma abicoder v2;







interface IERC20BASE {
    function totalSupply() external view returns (uint256);

    function balanceOf(address owner) external view returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);
}

interface IIWTON {
    function swapToTON(uint256 wtonAmount) external returns (bool);
}

interface ITokamakRegistry {
    function getTokamak()
        external
        view
        returns (
            address,
            address,
            address,
            address,
            address
        );

    function getUniswap()
        external
        view
        returns (
            address,
            address,
            address,
            uint256,
            address
        );
}

/// @title The connector that integrates tokamak
contract TokamakStaker is StakeTONStorage, AccessibleCommon, ITokamakStaker {
    using SafeMath for uint256;

    modifier nonZero(address _addr) {
        require(_addr != address(0), "TokamakStaker: zero address");
        _;
    }

    modifier sameTokamakLayer(address _addr) {
        require(tokamakLayer2 == _addr, "TokamakStaker:different layer");
        _;
    }

    modifier lock() {
        require(_lock == 0, "TokamakStaker:LOCKED");
        _lock = 1;
        _;
        _lock = 0;
    }

    modifier onlyClosed() {
        require(IIStake1Vault(vault).saleClosed(), "TokamakStaker: not closed");
        _;
    }

    /// @dev event on set the registry address
    /// @param registry the registry address
    event SetRegistry(address registry);

    /// @dev event on set the tokamak Layer2 address
    /// @param layer2 the tokamak Layer2 address
    event SetTokamakLayer2(address layer2);

    /// @dev event on staking the staked TON in layer2 in tokamak
    /// @param layer2 the layer2 address in tokamak
    /// @param amount the amount that stake to layer2
    event TokamakStaked(address layer2, uint256 amount);

    /// @dev event on request unstaking the wtonAmount in layer2 in tokamak
    /// @param layer2 the layer2 address in tokamak
    /// @param amount the amount requested to unstaking
    event TokamakRequestedUnStaking(address layer2, uint256 amount);

    /// @dev event on process unstaking in layer2 in tokamak
    /// @param layer2 the layer2 address in tokamak
    /// @param rn the number of requested unstaking
    /// @param receiveTON if is true ,TON , else is WTON
    event TokamakProcessedUnStaking(
        address layer2,
        uint256 rn,
        bool receiveTON
    );

    /// @dev event on request unstaking the amount of all in layer2 in tokamak
    /// @param layer2 the layer2 address in tokamak
    event TokamakRequestedUnStakingAll(address layer2);

    /// @dev exchange WTON to TOS using uniswap v3
    /// @param caller the sender
    /// @param amountIn the input amount
    /// @return amountOut the amount of exchanged out token

    event ExchangedWTONtoTOS(
        address caller,
        uint256 amountIn,
        uint256 amountOut
    );

    /// @dev exchange WTON to TOS using uniswap v2
    /// @param caller the sender
    /// @param amountIn the input amount
    /// @return amountOut the amount of exchanged out token

    event ExchangedWTONtoTOS2(
        address caller,
        uint256 amountIn,
        uint256 amountOut
    );

    /// @dev set registry address
    /// @param _registry new registry address
    function setRegistry(address _registry)
        external
        onlyOwner
        nonZero(_registry)
    {
        stakeRegistry = _registry;

        emit SetRegistry(stakeRegistry);
    }

    /// @dev set the tokamak Layer2 address
    /// @param _layer2 new the tokamak Layer2 address
    function setTokamakLayer2(address _layer2) external override onlyOwner {
        require(
            _layer2 != address(0) && tokamakLayer2 != _layer2,
            "TokamakStaker:tokamakLayer2 zero "
        );
        tokamakLayer2 = _layer2;

        emit SetTokamakLayer2(_layer2);
    }

    /// @dev get the addresses that used in uniswap interfaces
    /// @return uniswapRouter the address of uniswapRouter
    /// @return npm the address of positionManagerAddress
    /// @return ext the address of ext
    /// @return fee the amount of fee
    function getUniswapInfo()
        external
        view
        override
        returns (
            address uniswapRouter,
            address npm,
            address ext,
            uint256 fee,
            address uniswapRouterV2
        )
    {
        return ITokamakRegistry(stakeRegistry).getUniswap();
    }

    /// @dev Change the TON holded in contract have to WTON, or change WTON to TON.
    /// @param amount the amount to be changed
    /// @param toWTON if it's true, TON->WTON , else WTON->TON
    function swapTONtoWTON(uint256 amount, bool toWTON) external override lock {
        checkTokamak();

        if (toWTON) {
            require(
                swapProxy != address(0),
                "TokamakStaker: swapProxy is zero"
            );
            require(
                IERC20BASE(ton).balanceOf(address(this)) >= amount,
                "TokamakStaker: swapTONtoWTON ton balance is insufficient"
            );
            bytes memory data = abi.encode(swapProxy, swapProxy);
            require(
                ITON(ton).approveAndCall(wton, amount, data),
                "TokamakStaker:swapTONtoWTON approveAndCall fail"
            );
        } else {
            require(
                IERC20BASE(wton).balanceOf(address(this)) >= amount,
                "TokamakStaker: swapTONtoWTON wton balance is insufficient"
            );
            require(
                IIWTON(wton).swapToTON(amount),
                "TokamakStaker:swapToTON fail"
            );
        }
    }

    /// @dev If the tokamak addresses is not set, set the addresses.
    function checkTokamak() public {
        if (ton == address(0)) {
            (
                address _ton,
                address _wton,
                address _depositManager,
                address _seigManager,
                address _swapProxy
            ) = ITokamakRegistry(stakeRegistry).getTokamak();

            ton = _ton;
            wton = _wton;
            depositManager = _depositManager;
            seigManager = _seigManager;
            swapProxy = _swapProxy;
        }
        require(
            ton != address(0) &&
                wton != address(0) &&
                seigManager != address(0) &&
                depositManager != address(0) &&
                swapProxy != address(0),
            "TokamakStaker:tokamak zero"
        );
    }

    /// @dev  staking the staked TON in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    /// @param stakeAmount the amount that stake to layer2
    function tokamakStaking(address _layer2, uint256 stakeAmount)
        external
        override
        lock
        nonZero(stakeRegistry)
        nonZero(_layer2)
        onlyClosed
    {
        require(block.number <= endBlock, "TokamakStaker:period end");
        require(stakeAmount > 0, "TokamakStaker:stakeAmount is zero");

        defiStatus = uint256(LibTokenStake1.DefiStatus.DEPOSITED);

        checkTokamak();

        uint256 globalWithdrawalDelay =
            IIDepositManager(depositManager).globalWithdrawalDelay();
        require(
            block.number < endBlock - globalWithdrawalDelay,
            "TokamakStaker:period(withdrawalDelay) end"
        );

        if (tokamakLayer2 == address(0)) tokamakLayer2 = _layer2;
        else {
            if (
                IISeigManager(seigManager).stakeOf(
                    tokamakLayer2,
                    address(this)
                ) >
                0 ||
                IIDepositManager(depositManager).pendingUnstaked(
                    tokamakLayer2,
                    address(this)
                ) >
                0
            ) {
                require(
                    tokamakLayer2 == _layer2,
                    "TokamakStaker:different layer"
                );
            } else {
                if (tokamakLayer2 != _layer2) tokamakLayer2 = _layer2;
            }
        }

        require(
            IERC20BASE(ton).balanceOf(address(this)) >= stakeAmount,
            "TokamakStaker: ton balance is insufficient"
        );
        toTokamak = toTokamak.add(stakeAmount);
        bytes memory data = abi.encode(depositManager, _layer2);
        require(
            ITON(ton).approveAndCall(wton, stakeAmount, data),
            "TokamakStaker:approveAndCall fail"
        );

        emit TokamakStaked(_layer2, stakeAmount);
    }

    /// @dev  request unstaking the wtonAmount in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    /// @param wtonAmount the amount requested to unstaking
    function tokamakRequestUnStaking(address _layer2, uint256 wtonAmount)
        external
        override
        lock
        nonZero(stakeRegistry)
        onlyClosed
        sameTokamakLayer(_layer2)
    {
        defiStatus = uint256(LibTokenStake1.DefiStatus.REQUESTWITHDRAW);
        requestNum = requestNum.add(1);
        checkTokamak();

        uint256 stakeOf =
            IISeigManager(seigManager).stakeOf(_layer2, address(this));

        require(stakeOf >= wtonAmount, "TokamakStaker:lack");

        IIDepositManager(depositManager).requestWithdrawal(_layer2, wtonAmount);

        emit TokamakRequestedUnStaking(_layer2, wtonAmount);
    }

    /// @dev  request unstaking the amount of all in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    function tokamakRequestUnStakingAll(address _layer2)
        external
        override
        lock
        nonZero(stakeRegistry)
        onlyClosed
        sameTokamakLayer(_layer2)
    {
        defiStatus = uint256(LibTokenStake1.DefiStatus.REQUESTWITHDRAW);
        requestNum = requestNum.add(1);
        checkTokamak();

        IIDepositManager(depositManager).requestWithdrawalAll(_layer2);

        emit TokamakRequestedUnStakingAll(_layer2);
    }

    /// @dev process unstaking in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    function tokamakProcessUnStaking(address _layer2)
        external
        override
        lock
        nonZero(stakeRegistry)
        onlyClosed
        sameTokamakLayer(_layer2)
    {
        require(
            defiStatus != uint256(LibTokenStake1.DefiStatus.WITHDRAW),
            "TokamakStaker:Already ProcessUnStaking"
        );

        defiStatus = uint256(LibTokenStake1.DefiStatus.WITHDRAW);
        uint256 rn = requestNum;
        requestNum = 0;
        checkTokamak();

        if (
            IISeigManager(seigManager).stakeOf(tokamakLayer2, address(this)) ==
            0
        ) tokamakLayer2 = address(0);

        fromTokamak = fromTokamak.add(
            IIDepositManager(depositManager).pendingUnstaked(
                _layer2,
                address(this)
            )
        );

        // receiveTON = false . to WTON
        IIDepositManager(depositManager).processRequests(_layer2, rn, true);

        emit TokamakProcessedUnStaking(_layer2, rn, true);
    }

    /// @dev exchange holded WTON to TOS using uniswap
    /// @param _amountIn the input amount
    /// @param _amountOutMinimum the minimun output amount
    /// @param _deadline deadline
    /// @param _sqrtPriceLimitX96 sqrtPriceLimitX96
    /// @param _kind the function type, if 0, use exactInputSingle function, else if, use exactInput function
    /// @return amountOut the amount of exchanged out token
    function exchangeWTONtoTOS(
        uint256 _amountIn,
        uint256 _amountOutMinimum,
        uint256 _deadline,
        uint160 _sqrtPriceLimitX96,
        uint256 _kind
    ) external override lock onlyClosed returns (uint256 amountOut) {
        require(block.number <= endBlock, "TokamakStaker: period end");
        require(_kind < 2, "TokamakStaker: not available kind");
        checkTokamak();

        {
            uint256 _amountWTON = IERC20BASE(wton).balanceOf(address(this));
            uint256 _amountTON = IERC20BASE(ton).balanceOf(address(this));
            uint256 stakeOf = 0;
            if (tokamakLayer2 != address(0)) {
                stakeOf = IISeigManager(seigManager).stakeOf(
                    tokamakLayer2,
                    address(this)
                );
                stakeOf = stakeOf.add(
                    IIDepositManager(depositManager).pendingUnstaked(
                        tokamakLayer2,
                        address(this)
                    )
                );
            }
            uint256 holdAmount = _amountWTON;
            if (_amountTON > 0)
                holdAmount = holdAmount.add(_amountTON.mul(10**9));
            require(
                holdAmount >= _amountIn,
                "TokamakStaker: wton insufficient"
            );

            if (stakeOf > 0) holdAmount = holdAmount.add(stakeOf);

            require(
                holdAmount > totalStakedAmount.mul(10**9) &&
                    holdAmount.sub(totalStakedAmount.mul(10**9)) >= _amountIn,
                "TokamakStaker:insufficient"
            );
            if (_amountWTON < _amountIn) {
                bytes memory data = abi.encode(swapProxy, swapProxy);
                uint256 swapTON = _amountIn.sub(_amountWTON).div(10**9);
                require(
                    ITON(ton).approveAndCall(wton, swapTON, data),
                    "TokamakStaker:exchangeWTONtoTOS approveAndCall fail"
                );
            }
        }

        toUniswapWTON = toUniswapWTON.add(_amountIn);
        (address uniswapRouter, , address wethAddress, uint256 _fee, ) =
            ITokamakRegistry(stakeRegistry).getUniswap();
        require(uniswapRouter != address(0), "TokamakStaker:uniswap zero");
        require(
            IERC20BASE(wton).approve(uniswapRouter, _amountIn),
            "TokamakStaker:can't approve uniswapRouter"
        );

        if (_kind == 0) {
            ISwapRouter.ExactInputSingleParams memory params =
                ISwapRouter.ExactInputSingleParams({
                    tokenIn: wton,
                    tokenOut: token,
                    fee: uint24(_fee),
                    recipient: address(this),
                    deadline: _deadline,
                    amountIn: _amountIn,
                    amountOutMinimum: _amountOutMinimum,
                    sqrtPriceLimitX96: _sqrtPriceLimitX96
                });
            amountOut = ISwapRouter(uniswapRouter).exactInputSingle(params);
        } else if (_kind == 1) {
            ISwapRouter.ExactInputParams memory params =
                ISwapRouter.ExactInputParams({
                    path: abi.encodePacked(
                        wton,
                        uint24(_fee),
                        wethAddress,
                        uint24(_fee),
                        token
                    ),
                    recipient: address(this),
                    deadline: _deadline,
                    amountIn: _amountIn,
                    amountOutMinimum: _amountOutMinimum
                });
            amountOut = ISwapRouter(uniswapRouter).exactInput(params);
        }

        emit ExchangedWTONtoTOS(msg.sender, _amountIn, amountOut);
    }

    /*
    function exactInputSingle(uint256 _amountIn, uint256 _amountOutMinimum, uint256 _deadline, uint256 _sqrtPriceLimitX96)
        external onlyOwner lock returns (uint256 amountOut)
    {
        checkTokamak();

        (address uniswapRouter, , address wethAddress, uint256 _fee, ) =
            ITokamakRegistry(stakeRegistry).getUniswap();

        // address uniswapRouter = 0xE592427A0AEce92De3Edee1F18E0157C05861564;
        // address wethAddress = 0xc778417E063141139Fce010982780140Aa0cD5Ab;
        // uint256 _fee = 500;

        require(
            IERC20BASE(wton).approve(uniswapRouter, _amountIn),
            "TokamakStaker:can't approve uniswapRouter"
        );

        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams(
            wton,
            token,
            uint24(_fee),
            address(this),
            _deadline,
            _amountIn,
            _amountOutMinimum,
            uint160(_sqrtPriceLimitX96)
        );
        amountOut = ISwapRouter(uniswapRouter).exactInputSingle(params);
    }

    function exactInputView(address _wton, address _weth, address _tos, uint256 _amountIn, uint256 _amountOutMinimum, uint256 _deadline,  bytes memory _path)
        external view returns (address uniswapRouter, address wethAddress, bytes memory outBytes , uint256 _fee)
    {
        ( uniswapRouter, ,  wethAddress,  _fee, ) =
            ITokamakRegistry(stakeRegistry).getUniswap();

        outBytes = abi.encodePacked(
                        _wton,
                        uint24(_fee),
                        _weth,
                        uint24(_fee),
                        _tos
                    );
    }

    function exactInput(uint256 _amountIn, uint256 _amountOutMinimum, uint256 _deadline,  address _target, bytes memory _path)
        external lock returns (uint256 amountOut )
    {
        checkTokamak();

        (address uniswapRouter, , address wethAddress, uint256 _fee, ) =
            ITokamakRegistry(stakeRegistry).getUniswap();

        require(
            IERC20BASE(wton).approve(uniswapRouter, _amountIn),
            "TokamakStaker:can't approve uniswapRouter"
        );

        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams(
             _path,
             _target,
             _deadline,
             _amountIn,
            _amountOutMinimum
        );
        amountOut = ISwapRouter(uniswapRouter).exactInput(params);
    }*/
}


// File contracts/connection/TokamakStakeUpgrade.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;
pragma abicoder v2;







interface IERC20BASE1 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address owner) external view returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);
}

interface IIWTON1 {
    function swapToTON(uint256 wtonAmount) external returns (bool);
}

interface ITokamakRegistry1 {
    function getTokamak()
        external
        view
        returns (
            address,
            address,
            address,
            address,
            address
        );

    function getUniswap()
        external
        view
        returns (
            address,
            address,
            address,
            uint256,
            address
        );
}

/// @title The connector that integrates tokamak
contract TokamakStakeUpgrade is StakeTONStorage, AccessibleCommon, ITokamakStaker {
    using SafeMath for uint256;

    modifier nonZero(address _addr) {
        require(_addr != address(0), "TokamakStaker: zero address");
        _;
    }

    modifier sameTokamakLayer(address _addr) {
        require(tokamakLayer2 == _addr, "TokamakStaker:different layer");
        _;
    }

    modifier lock() {
        require(_lock == 0, "TokamakStaker:LOCKED");
        _lock = 1;
        _;
        _lock = 0;
    }

    modifier onlyClosed() {
        require(IIStake1Vault(vault).saleClosed(), "TokamakStaker: not closed");
        _;
    }

    /// @dev event on set the registry address
    /// @param registry the registry address
    event SetRegistry(address registry);

    /// @dev event on set the tokamak Layer2 address
    /// @param layer2 the tokamak Layer2 address
    event SetTokamakLayer2(address layer2);

    /// @dev event on staking the staked TON in layer2 in tokamak
    /// @param layer2 the layer2 address in tokamak
    /// @param amount the amount that stake to layer2
    event TokamakStaked(address layer2, uint256 amount);

    /// @dev event on request unstaking the wtonAmount in layer2 in tokamak
    /// @param layer2 the layer2 address in tokamak
    /// @param amount the amount requested to unstaking
    event TokamakRequestedUnStaking(address layer2, uint256 amount);

    /// @dev event on process unstaking in layer2 in tokamak
    /// @param layer2 the layer2 address in tokamak
    /// @param rn the number of requested unstaking
    /// @param receiveTON if is true ,TON , else is WTON
    event TokamakProcessedUnStaking(
        address layer2,
        uint256 rn,
        bool receiveTON
    );

    /// @dev event on request unstaking the amount of all in layer2 in tokamak
    /// @param layer2 the layer2 address in tokamak
    event TokamakRequestedUnStakingAll(address layer2);

    /// @dev exchange WTON to TOS using uniswap v3
    /// @param caller the sender
    /// @param amountIn the input amount
    /// @return amountOut the amount of exchanged out token

    event ExchangedWTONtoTOS(
        address caller,
        uint256 amountIn,
        uint256 amountOut
    );

    /// @dev set registry address
    /// @param _registry new registry address
    function setRegistry(address _registry)
        external
        onlyOwner
        nonZero(_registry)
    {
        stakeRegistry = _registry;

        emit SetRegistry(stakeRegistry);
    }

    /// @dev set the tokamak Layer2 address
    /// @param _layer2 new the tokamak Layer2 address
    function setTokamakLayer2(address _layer2) external override onlyOwner {
        require(
            _layer2 != address(0) && tokamakLayer2 != _layer2,
            "TokamakStaker:tokamakLayer2 zero "
        );
        tokamakLayer2 = _layer2;

        emit SetTokamakLayer2(_layer2);
    }

    /// @dev get the addresses that used in uniswap interfaces
    /// @return uniswapRouter the address of uniswapRouter
    /// @return npm the address of positionManagerAddress
    /// @return ext the address of ext
    /// @return fee the amount of fee
    function getUniswapInfo()
        external
        view
        override
        returns (
            address uniswapRouter,
            address npm,
            address ext,
            uint256 fee,
            address uniswapRouterV2
        )
    {
        return ITokamakRegistry1(stakeRegistry).getUniswap();
    }

    /// @dev Change the TON holded in contract have to WTON, or change WTON to TON.
    /// @param amount the amount to be changed
    /// @param toWTON if it's true, TON->WTON , else WTON->TON
    function swapTONtoWTON(uint256 amount, bool toWTON) external override lock {
        checkTokamak();

        if (toWTON) {
            require(
                swapProxy != address(0),
                "TokamakStaker: swapProxy is zero"
            );
            require(
                IERC20BASE1(ton).balanceOf(address(this)) >= amount,
                "TokamakStaker: swapTONtoWTON ton balance is insufficient"
            );
            bytes memory data = abi.encode(swapProxy, swapProxy);
            require(
                ITON(ton).approveAndCall(wton, amount, data),
                "TokamakStaker:swapTONtoWTON approveAndCall fail"
            );
        } else {
            require(
                IERC20BASE1(wton).balanceOf(address(this)) >= amount,
                "TokamakStaker: swapTONtoWTON wton balance is insufficient"
            );
            require(
                IIWTON1(wton).swapToTON(amount),
                "TokamakStaker:swapToTON fail"
            );
        }
    }

    /// @dev If the tokamak addresses is not set, set the addresses.
    function checkTokamak() public {
        if (ton == address(0)) {
            (
                address _ton,
                address _wton,
                address _depositManager,
                address _seigManager,
                address _swapProxy
            ) = ITokamakRegistry1(stakeRegistry).getTokamak();

            ton = _ton;
            wton = _wton;
            depositManager = _depositManager;
            seigManager = _seigManager;
            swapProxy = _swapProxy;
        }
        require(
            ton != address(0) &&
                wton != address(0) &&
                seigManager != address(0) &&
                depositManager != address(0) &&
                swapProxy != address(0),
            "TokamakStaker:tokamak zero"
        );
    }

    /// @dev  staking the staked TON in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    /// @param stakeAmount the amount that stake to layer2
    function tokamakStaking(address _layer2, uint256 stakeAmount)
        external
        override
        lock
        nonZero(stakeRegistry)
        nonZero(_layer2)
        onlyClosed
    {
        require(block.number <= endBlock, "TokamakStaker:period end");
        require(stakeAmount > 0, "TokamakStaker:stakeAmount is zero");

        defiStatus = uint256(LibTokenStake1.DefiStatus.DEPOSITED);

        checkTokamak();

        uint256 globalWithdrawalDelay =
            IIDepositManager(depositManager).globalWithdrawalDelay();
        require(
            block.number < endBlock.sub(globalWithdrawalDelay),
            "TokamakStaker:period(withdrawalDelay) end"
        );

        if (tokamakLayer2 == address(0)) tokamakLayer2 = _layer2;
        else {
            if (
                IISeigManager(seigManager).stakeOf(
                    tokamakLayer2,
                    address(this)
                ) >
                0 ||
                IIDepositManager(depositManager).pendingUnstaked(
                    tokamakLayer2,
                    address(this)
                ) >
                0
            ) {
                require(
                    tokamakLayer2 == _layer2,
                    "TokamakStaker:different layer"
                );
            } else {
                if (tokamakLayer2 != _layer2) tokamakLayer2 = _layer2;
            }
        }

        require(
            IERC20BASE1(ton).balanceOf(address(this)) >= stakeAmount,
            "TokamakStaker: ton balance is insufficient"
        );
        toTokamak = toTokamak.add(stakeAmount);
        bytes memory data = abi.encode(depositManager, _layer2);
        require(
            ITON(ton).approveAndCall(wton, stakeAmount, data),
            "TokamakStaker:approveAndCall fail"
        );

        emit TokamakStaked(_layer2, stakeAmount);
    }

    function version() external pure returns (string memory) {
        return "upgrade.20210803";
    }

    /// @dev  request unstaking the amount excluding principal   in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    /// @param wtonAmount Exists for existing interfaces. not used.
    function tokamakRequestUnStaking(address _layer2, uint256 wtonAmount)
        external
        override
        lock
        nonZero(stakeRegistry)
        nonZero(_layer2)
        onlyClosed
        sameTokamakLayer(_layer2)
    {
        defiStatus = uint256(LibTokenStake1.DefiStatus.REQUESTWITHDRAW);
        requestNum = requestNum.add(1);
        checkTokamak();

        uint256 stakeOf = IISeigManager(seigManager).stakeOf(
            _layer2,
            address(this)
        );
        require(stakeOf > 0, "TokamakStaker: stakeOf is zero");

        uint256 principalAmount = totalStakedAmount.mul(10**9);

        uint256 availableAmount = 0;
        if(principalAmount > 0 && principalAmount < stakeOf.sub(100)){
            availableAmount = stakeOf.sub(principalAmount).sub(100);
        }

        require(availableAmount > 0, "TokamakStaker: no withdraw-able amount not yet");

        IIDepositManager(depositManager).requestWithdrawal(_layer2, availableAmount);

        emit TokamakRequestedUnStaking(_layer2, availableAmount);
    }

    /// @dev  Check whether unstaking is possible in layer2
    /// @param _layer2 the layer2 address in tokamak
    /// @return canUnStakingAmount available unStaking amount
    function canTokamakRequestUnStaking(address _layer2)
        external view returns (uint256 canUnStakingAmount){

        canUnStakingAmount = 0;
        if(tokamakLayer2 != address(0) && tokamakLayer2 == _layer2 && seigManager != address(0)){
            uint256 stakeOf = IISeigManager(seigManager).stakeOf(
                _layer2,
                address(this)
            );
            if(stakeOf > 0 && totalStakedAmount > 0 && totalStakedAmount.mul(10**9) < stakeOf){
                canUnStakingAmount = stakeOf.sub(totalStakedAmount.mul(10**9));
            }
        }
    }

    /// @dev  request unstaking the amount of all in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    function tokamakRequestUnStakingAll(address _layer2)
        external
        override
        lock
        nonZero(stakeRegistry)
        nonZero(_layer2)
        onlyClosed
        sameTokamakLayer(_layer2)
    {
        defiStatus = uint256(LibTokenStake1.DefiStatus.REQUESTWITHDRAW);
        requestNum = requestNum.add(1);
        checkTokamak();

        uint256 globalWithdrawalDelay =
            IIDepositManager(depositManager).globalWithdrawalDelay();

        uint256 stakeOf = IISeigManager(seigManager).stakeOf(
                _layer2,
                address(this)
            );
        require(stakeOf > 0, "TokamakStaker: stakeOf is zero");

        uint256 interval = globalWithdrawalDelay / 14;

        require(
            block.number > endBlock.sub(globalWithdrawalDelay).sub(interval),
            "TokamakStaker:The executable block has not passed"
        );

        IIDepositManager(depositManager).requestWithdrawalAll(_layer2);

        emit TokamakRequestedUnStakingAll(_layer2);
    }

    /// @dev  Check whether unstakingAll is possible in layer2
    /// @param _layer2 the layer2 address in tokamak
    /// @return can whether can tokamakRequestUnStakingAll
    function canTokamakRequestUnStakingAll(address _layer2)
        external view returns (bool can){

        can = false;
        if(tokamakLayer2 != address(0) && tokamakLayer2 == _layer2
            && depositManager != address(0) && seigManager != address(0)){

            uint256 globalWithdrawalDelay = IIDepositManager(depositManager).globalWithdrawalDelay();
            uint256 interval = globalWithdrawalDelay / 14;
            uint256 stakeOf = IISeigManager(seigManager).stakeOf(
                _layer2,
                address(this)
            );
            if(stakeOf> 0 && block.number > endBlock.sub(globalWithdrawalDelay).sub(interval))
                can = true;
        }
    }

    /// @dev  Check whether unstakingAll is possible in layer2
    /// @param _layer2 the layer2 address in tokamak
    /// @return _block  the block to can tokamakRequestUnStakingAll
    function canTokamakRequestUnStakingAllBlock(address _layer2)
        external view returns (uint256 _block){

        if(tokamakLayer2 != address(0) && tokamakLayer2 == _layer2 && depositManager != address(0)){

            uint256 globalWithdrawalDelay = IIDepositManager(depositManager).globalWithdrawalDelay();
            uint256 interval = globalWithdrawalDelay / 14;

            if(endBlock > globalWithdrawalDelay.add(interval))
                _block = endBlock.sub(globalWithdrawalDelay).sub(interval);
        }
    }

    /// @dev process unstaking in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    function tokamakProcessUnStaking(address _layer2)
        external
        override
        lock
        nonZero(stakeRegistry)
        onlyClosed
        sameTokamakLayer(_layer2)
    {
        require(
            defiStatus != uint256(LibTokenStake1.DefiStatus.WITHDRAW),
            "TokamakStaker:Already ProcessUnStaking"
        );

        defiStatus = uint256(LibTokenStake1.DefiStatus.WITHDRAW);
        uint256 rn = requestNum;
        requestNum = 0;
        checkTokamak();

        if (
            IISeigManager(seigManager).stakeOf(tokamakLayer2, address(this)) ==
            0
        ) tokamakLayer2 = address(0);

        fromTokamak = fromTokamak.add(
            IIDepositManager(depositManager).pendingUnstaked(
                _layer2,
                address(this)
            )
        );

        // receiveTON = false . to WTON
        IIDepositManager(depositManager).processRequests(_layer2, rn, true);

        emit TokamakProcessedUnStaking(_layer2, rn, true);
    }

    /// @dev exchange holded WTON to TOS using uniswap
    /// @param _amountIn the input amount
    /// @param _amountOutMinimum the minimun output amount
    /// @param _deadline deadline
    /// @param _sqrtPriceLimitX96 sqrtPriceLimitX96
    /// @param _kind the function type, if 0, use exactInputSingle function, else if, use exactInput function
    /// @return amountOut the amount of exchanged out token
    function exchangeWTONtoTOS(
        uint256 _amountIn,
        uint256 _amountOutMinimum,
        uint256 _deadline,
        uint160 _sqrtPriceLimitX96,
        uint256 _kind
    ) external override lock onlyClosed returns (uint256 amountOut) {
        require(block.number <= endBlock, "TokamakStaker: period end");
        require(_kind < 2, "TokamakStaker: not available kind");
        checkTokamak();

        {
            uint256 _amountWTON = IERC20BASE1(wton).balanceOf(address(this));
            uint256 _amountTON = IERC20BASE1(ton).balanceOf(address(this));
            uint256 stakeOf = 0;
            if (tokamakLayer2 != address(0)) {
                stakeOf = IISeigManager(seigManager).stakeOf(
                    tokamakLayer2,
                    address(this)
                );
                stakeOf = stakeOf.add(
                    IIDepositManager(depositManager).pendingUnstaked(
                        tokamakLayer2,
                        address(this)
                    )
                );
            }
            uint256 holdAmount = _amountWTON;
            if (_amountTON > 0)
                holdAmount = holdAmount.add(_amountTON.mul(10**9));
            require(
                holdAmount >= _amountIn,
                "TokamakStaker: wton insufficient"
            );

            if (stakeOf > 0) holdAmount = holdAmount.add(stakeOf);

            require(
                holdAmount > totalStakedAmount.mul(10**9) &&
                    holdAmount.sub(totalStakedAmount.mul(10**9)) >= _amountIn,
                "TokamakStaker:insufficient"
            );
            if (_amountWTON < _amountIn) {
                bytes memory data = abi.encode(swapProxy, swapProxy);
                uint256 swapTON = _amountIn.sub(_amountWTON).div(10**9);
                require(
                    ITON(ton).approveAndCall(wton, swapTON, data),
                    "TokamakStaker:exchangeWTONtoTOS approveAndCall fail"
                );
            }
        }

        toUniswapWTON = toUniswapWTON.add(_amountIn);
        (address uniswapRouter, , address wethAddress, uint256 _fee, ) =
            ITokamakRegistry1(stakeRegistry).getUniswap();
        require(uniswapRouter != address(0), "TokamakStaker:uniswap zero");
        require(
            IERC20BASE1(wton).approve(uniswapRouter, _amountIn),
            "TokamakStaker:can't approve uniswapRouter"
        );

        if (_kind == 0) {
            ISwapRouter.ExactInputSingleParams memory params =
                ISwapRouter.ExactInputSingleParams({
                    tokenIn: wton,
                    tokenOut: token,
                    fee: uint24(_fee),
                    recipient: address(this),
                    deadline: _deadline,
                    amountIn: _amountIn,
                    amountOutMinimum: _amountOutMinimum,
                    sqrtPriceLimitX96: _sqrtPriceLimitX96
                });
            amountOut = ISwapRouter(uniswapRouter).exactInputSingle(params);
        } else if (_kind == 1) {
            ISwapRouter.ExactInputParams memory params =
                ISwapRouter.ExactInputParams({
                    path: abi.encodePacked(
                        wton,
                        uint24(_fee),
                        wethAddress,
                        uint24(_fee),
                        token
                    ),
                    recipient: address(this),
                    deadline: _deadline,
                    amountIn: _amountIn,
                    amountOutMinimum: _amountOutMinimum
                });
            amountOut = ISwapRouter(uniswapRouter).exactInput(params);
        }

        emit ExchangedWTONtoTOS(msg.sender, _amountIn, amountOut);
    }

}


// File contracts/interfaces/IIIDepositManager.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

interface IIIDepositManager {
    function globalWithdrawalDelay()
        external
        view
        returns (uint256 withdrawalDelay);

    function accStaked(address layer2, address account)
        external
        view
        returns (uint256 wtonAmount);

    function accStakedLayer2(address layer2)
        external
        view
        returns (uint256 wtonAmount);

    function accStakedAccount(address account)
        external
        view
        returns (uint256 wtonAmount);

    function pendingUnstaked(address layer2, address account)
        external
        view
        returns (uint256 wtonAmount);

    function pendingUnstakedLayer2(address layer2)
        external
        view
        returns (uint256 wtonAmount);

    function pendingUnstakedAccount(address account)
        external
        view
        returns (uint256 wtonAmount);

    function accUnstaked(address layer2, address account)
        external
        view
        returns (uint256 wtonAmount);

    function accUnstakedLayer2(address layer2)
        external
        view
        returns (uint256 wtonAmount);

    function accUnstakedAccount(address account)
        external
        view
        returns (uint256 wtonAmount);

    function withdrawalRequestIndex(address layer2, address account)
        external
        view
        returns (uint256 index);

    // solhint-disable-next-line max-line-length
    function withdrawalRequest(
        address layer2,
        address account,
        uint256 index
    )
        external
        view
        returns (
            uint128 withdrawableBlockNumber,
            uint128 amount,
            bool processed
        );

    function WITHDRAWAL_DELAY() external view returns (uint256);

    function deposit(address layer2, uint256 amount) external returns (bool);

    function requestWithdrawal(address layer2, uint256 amount)
        external
        returns (bool);

    function processRequest(address layer2, bool receiveTON)
        external
        returns (bool);

    function requestWithdrawalAll(address layer2) external returns (bool);

    function processRequests(
        address layer2,
        uint256 n,
        bool receiveTON
    ) external returns (bool);

    function numRequests(address layer2, address account)
        external
        view
        returns (uint256);

    function numPendingRequests(address layer2, address account)
        external
        view
        returns (uint256);
}


// File contracts/connection/TokamakStakeUpgrade2.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;
pragma abicoder v2;







interface IERC20BASE2 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address owner) external view returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);
}

interface IIWTON2 {
    function swapToTON(uint256 wtonAmount) external returns (bool);
}

interface ITokamakRegistry2 {
    function getTokamak()
        external
        view
        returns (
            address,
            address,
            address,
            address,
            address
        );

    function getUniswap()
        external
        view
        returns (
            address,
            address,
            address,
            uint256,
            address
        );
}

/// @title The connector that integrates tokamak
contract TokamakStakeUpgrade2 is
    StakeTONStorage,
    AccessibleCommon,
    ITokamakStaker
{
    using SafeMath for uint256;

    modifier nonZero(address _addr) {
        require(_addr != address(0), "TokamakStaker: zero address");
        _;
    }

    modifier sameTokamakLayer(address _addr) {
        require(tokamakLayer2 == _addr, "TokamakStaker:different layer");
        _;
    }

    modifier lock() {
        require(_lock == 0, "TokamakStaker:LOCKED");
        _lock = 1;
        _;
        _lock = 0;
    }

    modifier onlyClosed() {
        require(IIStake1Vault(vault).saleClosed(), "TokamakStaker: not closed");
        _;
    }

    /// @dev event on set the registry address
    /// @param registry the registry address
    event SetRegistry(address registry);

    /// @dev event on set the tokamak Layer2 address
    /// @param layer2 the tokamak Layer2 address
    event SetTokamakLayer2(address layer2);

    /// @dev event on staking the staked TON in layer2 in tokamak
    /// @param layer2 the layer2 address in tokamak
    /// @param amount the amount that stake to layer2
    event TokamakStaked(address layer2, uint256 amount);

    /// @dev event on request unstaking the wtonAmount in layer2 in tokamak
    /// @param layer2 the layer2 address in tokamak
    /// @param amount the amount requested to unstaking
    event TokamakRequestedUnStaking(address layer2, uint256 amount);

    /// @dev event on process unstaking in layer2 in tokamak
    /// @param layer2 the layer2 address in tokamak
    /// @param rn the number of requested unstaking
    /// @param receiveTON if is true ,TON , else is WTON
    event TokamakProcessedUnStaking(
        address layer2,
        uint256 rn,
        bool receiveTON
    );

    /// @dev event on request unstaking the amount of all in layer2 in tokamak
    /// @param layer2 the layer2 address in tokamak
    event TokamakRequestedUnStakingAll(address layer2);

    /// @dev exchange WTON to TOS using uniswap v3
    /// @param caller the sender
    /// @param amountIn the input amount
    /// @return amountOut the amount of exchanged out token

    event ExchangedWTONtoTOS(
        address caller,
        uint256 amountIn,
        uint256 amountOut
    );

    /// @dev set registry address
    /// @param _registry new registry address
    function setRegistry(address _registry)
        external
        onlyOwner
        nonZero(_registry)
    {
        stakeRegistry = _registry;

        emit SetRegistry(stakeRegistry);
    }

    /// @dev set the tokamak Layer2 address
    /// @param _layer2 new the tokamak Layer2 address
    function setTokamakLayer2(address _layer2) external override onlyOwner {
        require(
            _layer2 != address(0) && tokamakLayer2 != _layer2,
            "TokamakStaker:tokamakLayer2 zero "
        );
        tokamakLayer2 = _layer2;

        emit SetTokamakLayer2(_layer2);
    }

    /// @dev get the addresses that used in uniswap interfaces
    /// @return uniswapRouter the address of uniswapRouter
    /// @return npm the address of positionManagerAddress
    /// @return ext the address of ext
    /// @return fee the amount of fee
    function getUniswapInfo()
        external
        view
        override
        returns (
            address uniswapRouter,
            address npm,
            address ext,
            uint256 fee,
            address uniswapRouterV2
        )
    {
        return ITokamakRegistry2(stakeRegistry).getUniswap();
    }

    /// @dev Change the TON holded in contract have to WTON, or change WTON to TON.
    /// @param amount the amount to be changed
    /// @param toWTON if it's true, TON->WTON , else WTON->TON
    function swapTONtoWTON(uint256 amount, bool toWTON) external override lock {
        checkTokamak();

        if (toWTON) {
            require(
                swapProxy != address(0),
                "TokamakStaker: swapProxy is zero"
            );
            require(
                IERC20BASE2(ton).balanceOf(address(this)) >= amount,
                "TokamakStaker: swapTONtoWTON ton balance is insufficient"
            );
            bytes memory data = abi.encode(swapProxy, swapProxy);
            require(
                ITON(ton).approveAndCall(wton, amount, data),
                "TokamakStaker:swapTONtoWTON approveAndCall fail"
            );
        } else {
            require(
                IERC20BASE2(wton).balanceOf(address(this)) >= amount,
                "TokamakStaker: swapTONtoWTON wton balance is insufficient"
            );
            require(
                IIWTON2(wton).swapToTON(amount),
                "TokamakStaker:swapToTON fail"
            );
        }
    }

    /// @dev If the tokamak addresses is not set, set the addresses.
    function checkTokamak() public {
        if (ton == address(0)) {
            (
                address _ton,
                address _wton,
                address _depositManager,
                address _seigManager,
                address _swapProxy
            ) = ITokamakRegistry2(stakeRegistry).getTokamak();

            ton = _ton;
            wton = _wton;
            depositManager = _depositManager;
            seigManager = _seigManager;
            swapProxy = _swapProxy;
        }
        require(
            ton != address(0) &&
                wton != address(0) &&
                seigManager != address(0) &&
                depositManager != address(0) &&
                swapProxy != address(0),
            "TokamakStaker:tokamak zero"
        );
    }

    /// @dev  staking the staked TON in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    /// @param stakeAmount the amount that stake to layer2
    function tokamakStaking(address _layer2, uint256 stakeAmount)
        external
        override
        lock
        nonZero(stakeRegistry)
        nonZero(_layer2)
        onlyClosed
    {
        require(block.number <= endBlock, "TokamakStaker:period end");
        require(stakeAmount > 0, "TokamakStaker:stakeAmount is zero");

        defiStatus = uint256(LibTokenStake1.DefiStatus.DEPOSITED);

        checkTokamak();

        uint256 globalWithdrawalDelay =
            IIIDepositManager(depositManager).globalWithdrawalDelay();
        require(
            block.number < endBlock.sub(globalWithdrawalDelay),
            "TokamakStaker:period(withdrawalDelay) end"
        );

        if (tokamakLayer2 == address(0)) tokamakLayer2 = _layer2;
        else {
            if (
                IISeigManager(seigManager).stakeOf(
                    tokamakLayer2,
                    address(this)
                ) >
                0 ||
                IIIDepositManager(depositManager).pendingUnstaked(
                    tokamakLayer2,
                    address(this)
                ) >
                0
            ) {
                require(
                    tokamakLayer2 == _layer2,
                    "TokamakStaker:different layer"
                );
            } else {
                if (tokamakLayer2 != _layer2) tokamakLayer2 = _layer2;
            }
        }

        require(
            IERC20BASE2(ton).balanceOf(address(this)) >= stakeAmount,
            "TokamakStaker: ton balance is insufficient"
        );
        toTokamak = toTokamak.add(stakeAmount);
        bytes memory data = abi.encode(depositManager, _layer2);
        require(
            ITON(ton).approveAndCall(wton, stakeAmount, data),
            "TokamakStaker:approveAndCall fail"
        );

        emit TokamakStaked(_layer2, stakeAmount);
    }

    function version() external pure returns (string memory) {
        return "phase1.upgrade.v2";
    }

    /// @dev  request unstaking the amount excluding principal   in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    /// @param wtonAmount Exists for existing interfaces. not used.
    function tokamakRequestUnStaking(address _layer2, uint256 wtonAmount)
        external
        override
        lock
        nonZero(stakeRegistry)
        nonZero(_layer2)
        onlyClosed
        sameTokamakLayer(_layer2)
    {
        defiStatus = uint256(LibTokenStake1.DefiStatus.REQUESTWITHDRAW);
        requestNum = requestNum.add(1);
        checkTokamak();

        uint256 stakeOf =
            IISeigManager(seigManager).stakeOf(_layer2, address(this));
        require(stakeOf > 0, "TokamakStaker: stakeOf is zero");

        uint256 principalAmount = totalStakedAmount.mul(10**9);

        uint256 availableAmount = 0;
        if (principalAmount > 0 && principalAmount < stakeOf.sub(100)) {
            availableAmount = stakeOf.sub(principalAmount).sub(100);
        }

        require(
            availableAmount > 0,
            "TokamakStaker: no withdraw-able amount not yet"
        );

        IIIDepositManager(depositManager).requestWithdrawal(
            _layer2,
            availableAmount
        );

        emit TokamakRequestedUnStaking(_layer2, availableAmount);
    }

    /// @dev  Check whether unstaking is possible in layer2
    /// @param _layer2 the layer2 address in tokamak
    /// @return canUnStakingAmount available unStaking amount
    function canTokamakRequestUnStaking(address _layer2)
        external
        view
        returns (uint256 canUnStakingAmount)
    {
        canUnStakingAmount = 0;
        if (
            tokamakLayer2 != address(0) &&
            tokamakLayer2 == _layer2 &&
            seigManager != address(0)
        ) {
            uint256 stakeOf =
                IISeigManager(seigManager).stakeOf(_layer2, address(this));
            if (
                stakeOf > 0 &&
                totalStakedAmount > 0 &&
                totalStakedAmount.mul(10**9) < stakeOf
            ) {
                canUnStakingAmount = stakeOf.sub(totalStakedAmount.mul(10**9));
            }
        }
    }

    /// @dev  request unstaking the amount of all in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    function tokamakRequestUnStakingAll(address _layer2)
        external
        override
        lock
        nonZero(stakeRegistry)
        nonZero(_layer2)
        onlyClosed
        sameTokamakLayer(_layer2)
    {
        defiStatus = uint256(LibTokenStake1.DefiStatus.REQUESTWITHDRAW);
        requestNum = requestNum.add(1);
        checkTokamak();

        uint256 globalWithdrawalDelay =
            IIIDepositManager(depositManager).globalWithdrawalDelay();

        uint256 stakeOf =
            IISeigManager(seigManager).stakeOf(_layer2, address(this));
        require(stakeOf > 0, "TokamakStaker: stakeOf is zero");

        uint256 interval = globalWithdrawalDelay / 14;

        require(
            block.number > endBlock.sub(globalWithdrawalDelay).sub(interval),
            "TokamakStaker:The executable block has not passed"
        );

        IIIDepositManager(depositManager).requestWithdrawalAll(_layer2);

        emit TokamakRequestedUnStakingAll(_layer2);
    }

    /// @dev  Check whether unstakingAll is possible in layer2
    /// @param _layer2 the layer2 address in tokamak
    /// @return can whether can tokamakRequestUnStakingAll
    function canTokamakRequestUnStakingAll(address _layer2)
        external
        view
        returns (bool can)
    {
        can = false;
        if (
            tokamakLayer2 != address(0) &&
            tokamakLayer2 == _layer2 &&
            depositManager != address(0) &&
            seigManager != address(0)
        ) {
            uint256 globalWithdrawalDelay =
                IIIDepositManager(depositManager).globalWithdrawalDelay();
            uint256 interval = globalWithdrawalDelay / 14;
            uint256 stakeOf =
                IISeigManager(seigManager).stakeOf(_layer2, address(this));
            if (
                stakeOf > 0 &&
                block.number > endBlock.sub(globalWithdrawalDelay).sub(interval)
            ) can = true;
        }
    }

    /// @dev  Check whether unstakingAll is possible in layer2
    /// @param _layer2 the layer2 address in tokamak
    /// @return _block  the block to can tokamakRequestUnStakingAll
    function canTokamakRequestUnStakingAllBlock(address _layer2)
        external
        view
        returns (uint256 _block)
    {
        if (
            tokamakLayer2 != address(0) &&
            tokamakLayer2 == _layer2 &&
            depositManager != address(0)
        ) {
            uint256 globalWithdrawalDelay =
                IIIDepositManager(depositManager).globalWithdrawalDelay();
            uint256 interval = globalWithdrawalDelay / 14;

            if (endBlock > globalWithdrawalDelay.add(interval))
                _block = endBlock.sub(globalWithdrawalDelay).sub(interval);
        }
    }

    /// @dev process unstaking in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    function tokamakProcessUnStaking(address _layer2)
        external
        override
        lock
        nonZero(stakeRegistry)
        onlyClosed
        sameTokamakLayer(_layer2)
    {
        defiStatus = uint256(LibTokenStake1.DefiStatus.WITHDRAW);

        checkTokamak();

        uint256 num = 0;
        uint256 pamount = 0;
        (num, pamount) = canTokamakProcessUnStakingCount(_layer2);

        require(num > 0 && pamount > 0, "TokamakStaker: no able request");
        fromTokamak = fromTokamak.add(pamount);
        if (requestNum >= num) requestNum = requestNum.sub(num);

        // receiveTON = false . to WTON
        IIIDepositManager(depositManager).processRequests(_layer2, num, true);

        emit TokamakProcessedUnStaking(_layer2, num, true);
    }

    /// @dev TokamakProcessUnStaking Number and amount of withdrawals possible
    /// @param _layer2 the layer2 address in tokamak
    function canTokamakProcessUnStakingCount(address _layer2)
        public
        view
        nonZero(stakeRegistry)
        nonZero(_layer2)
        onlyClosed
        sameTokamakLayer(_layer2)
        returns (uint256 count, uint256 amount)
    {
        uint128 num = 0;
        uint128 pamount = 0;
        uint256 startIndex =
            IIIDepositManager(depositManager).withdrawalRequestIndex(
                _layer2,
                address(this)
            );
        uint256 numPendingRequests =
            IIIDepositManager(depositManager)
                .numPendingRequests(_layer2, address(this))
                .add(startIndex);

        for (uint256 i = startIndex; i < numPendingRequests; i++) {
            uint128 _block = 0;
            uint128 _amount = 0;
            bool processed = false;
            (_block, _amount, processed) = IIIDepositManager(depositManager)
                .withdrawalRequest(_layer2, address(this), i);

            if (
                processed == false &&
                (uint256(_block) > 0 && uint256(_block) < block.number)
            ) {
                num++;
                pamount += _amount;
            } else {
                break;
            }
        }

        return (uint256(num), uint256(pamount));
    }

    /// @dev exchange holded WTON to TOS using uniswap
    /// @param _amountIn the input amount
    /// @param _amountOutMinimum the minimun output amount
    /// @param _deadline deadline
    /// @param _sqrtPriceLimitX96 sqrtPriceLimitX96
    /// @param _kind the function type, if 0, use exactInputSingle function, else if, use exactInput function
    /// @return amountOut the amount of exchanged out token
    function exchangeWTONtoTOS(
        uint256 _amountIn,
        uint256 _amountOutMinimum,
        uint256 _deadline,
        uint160 _sqrtPriceLimitX96,
        uint256 _kind
    ) external override lock onlyClosed returns (uint256 amountOut) {
        require(block.number <= endBlock, "TokamakStaker: period end");
        require(_kind < 2, "TokamakStaker: not available kind");
        checkTokamak();

        {
            uint256 _amountWTON = IERC20BASE2(wton).balanceOf(address(this));
            uint256 _amountTON = IERC20BASE2(ton).balanceOf(address(this));
            uint256 stakeOf = 0;
            if (tokamakLayer2 != address(0)) {
                stakeOf = IISeigManager(seigManager).stakeOf(
                    tokamakLayer2,
                    address(this)
                );
                stakeOf = stakeOf.add(
                    IIIDepositManager(depositManager).pendingUnstaked(
                        tokamakLayer2,
                        address(this)
                    )
                );
            }
            uint256 holdAmount = _amountWTON;
            if (_amountTON > 0)
                holdAmount = holdAmount.add(_amountTON.mul(10**9));
            require(
                holdAmount >= _amountIn,
                "TokamakStaker: wton insufficient"
            );

            if (stakeOf > 0) holdAmount = holdAmount.add(stakeOf);

            require(
                holdAmount > totalStakedAmount.mul(10**9) &&
                    holdAmount.sub(totalStakedAmount.mul(10**9)) >= _amountIn,
                "TokamakStaker:insufficient"
            );
            if (_amountWTON < _amountIn) {
                bytes memory data = abi.encode(swapProxy, swapProxy);
                uint256 swapTON = _amountIn.sub(_amountWTON).div(10**9);
                require(
                    ITON(ton).approveAndCall(wton, swapTON, data),
                    "TokamakStaker:exchangeWTONtoTOS approveAndCall fail"
                );
            }
        }

        toUniswapWTON = toUniswapWTON.add(_amountIn);
        (address uniswapRouter, , , uint256 _fee, ) =
            ITokamakRegistry2(stakeRegistry).getUniswap();
        require(uniswapRouter != address(0), "TokamakStaker:uniswap zero");
        require(
            IERC20BASE2(wton).approve(uniswapRouter, _amountIn),
            "TokamakStaker:can't approve uniswapRouter"
        );

        //if (_kind == 0) {
        ISwapRouter.ExactInputSingleParams memory params =
            ISwapRouter.ExactInputSingleParams({
                tokenIn: wton,
                tokenOut: token,
                fee: uint24(_fee),
                recipient: address(this),
                deadline: _deadline,
                amountIn: _amountIn,
                amountOutMinimum: _amountOutMinimum,
                sqrtPriceLimitX96: _sqrtPriceLimitX96
            });
        amountOut = ISwapRouter(uniswapRouter).exactInputSingle(params);
        /*
        } else if (_kind == 1) {
            ISwapRouter.ExactInputParams memory params =
                ISwapRouter.ExactInputParams({
                    path: abi.encodePacked(
                        wton,
                        uint24(_fee),
                        wethAddress,
                        uint24(_fee),
                        token
                    ),
                    recipient: address(this),
                    deadline: _deadline,
                    amountIn: _amountIn,
                    amountOutMinimum: _amountOutMinimum
                });
            amountOut = ISwapRouter(uniswapRouter).exactInput(params);
        } */

        emit ExchangedWTONtoTOS(msg.sender, _amountIn, amountOut);
    }
}


// File contracts/libraries/FixedPoint96.sol

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.7.6;

/// @title FixedPoint96
/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)
/// @dev Used in SqrtPriceMath.sol
library FixedPoint96 {
    uint8 internal constant RESOLUTION = 96;
    uint256 internal constant Q96 = 0x1000000000000000000000000;
}


// File contracts/libraries/FullMath.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

/// @title Contains 512-bit math functions
/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision
/// @dev Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits
library FullMath {
    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
    /// @param a The multiplicand
    /// @param b The multiplier
    /// @param denominator The divisor
    /// @return result The 256-bit result
    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
    function mulDiv(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        // Handle division by zero
        require(denominator > 0);

        // 512-bit multiply [prod1 prod0] = a * b
        // Compute the product mod 2**256 and mod 2**256 - 1
        // then use the Chinese Remainder Theorem to reconstruct
        // the 512 bit result. The result is stored in two 256
        // variables such that product = prod1 * 2**256 + prod0
        uint256 prod0; // Least significant 256 bits of the product
        uint256 prod1; // Most significant 256 bits of the product
        assembly {
            let mm := mulmod(a, b, not(0))
            prod0 := mul(a, b)
            prod1 := sub(sub(mm, prod0), lt(mm, prod0))
        }

        // Handle non-overflow cases, 256 by 256 division
        if (prod1 == 0) {
            // require(denominator > 0);
            assembly {
                result := div(prod0, denominator)
            }
            return result;
        }

        // Make sure the result is less than 2**256.
        // Also prevents denominator == 0
        require(denominator > prod1);

        ///////////////////////////////////////////////
        // 512 by 256 division.
        ///////////////////////////////////////////////

        // Make division exact by subtracting the remainder from [prod1 prod0]
        // Compute remainder using mulmod
        uint256 remainder;
        assembly {
            remainder := mulmod(a, b, denominator)
        }

        // Subtract 256 bit number from 512 bit number
        assembly {
            prod1 := sub(prod1, gt(remainder, prod0))
            prod0 := sub(prod0, remainder)
        }

        // Factor powers of two out of denominator
        // Compute largest power of two divisor of denominator.
        // Always >= 1.
        // 2022.0314.modified
        //uint256 twos = -denominator & denominator;
        //uint256 twos = denominator & (~denominator + 1);
        uint256 twos = (type(uint256).max - denominator + 1) & denominator;

        // Divide denominator by power of two
        assembly {
            denominator := div(denominator, twos)
        }

        // Divide [prod1 prod0] by the factors of two
        assembly {
            prod0 := div(prod0, twos)
        }
        // Shift in bits from prod1 into prod0. For this we need
        // to flip `twos` such that it is 2**256 / twos.
        // If twos is zero, then it becomes one
        assembly {
            twos := add(div(sub(0, twos), twos), 1)
        }

        //unchecked {
            prod0 |= prod1 * twos;
            // Invert denominator mod 2**256
            // Now that denominator is an odd number, it has an inverse
            // modulo 2**256 such that denominator * inv = 1 mod 2**256.
            // Compute the inverse by starting with a seed that is correct
            // correct for four bits. That is, denominator * inv = 1 mod 2**4

            uint256 inv = (3 * denominator) ^ 2;

            // Now use Newton-Raphson iteration to improve the precision.
            // Thanks to Hensel's lifting lemma, this also works in modular
            // arithmetic, doubling the correct bits in each step.
            inv *= 2 - denominator * inv; // inverse mod 2**8
            inv *= 2 - denominator * inv; // inverse mod 2**16
            inv *= 2 - denominator * inv; // inverse mod 2**32
            inv *= 2 - denominator * inv; // inverse mod 2**64
            inv *= 2 - denominator * inv; // inverse mod 2**128
            inv *= 2 - denominator * inv; // inverse mod 2**256

            // Because the division is now exact we can divide by multiplying
            // with the modular inverse of denominator. This will give us the
            // correct result modulo 2**256. Since the precoditions guarantee
            // that the outcome is less than 2**256, this is the final result.
            // We don't need to compute the high bits of the result and prod1
            // is no longer required.
            result = prod0 * inv;
        //}
        return result;
    }

    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
    /// @param a The multiplicand
    /// @param b The multiplier
    /// @param denominator The divisor
    /// @return result The 256-bit result
    function mulDivRoundingUp(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        result = mulDiv(a, b, denominator);
        if (mulmod(a, b, denominator) > 0) {
            require(result < type(uint256).max);
            result++;
        }
    }
}


// File contracts/libraries/TickMath.sol

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.7.6;

/// @title Math library for computing sqrt prices from ticks and vice versa
/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports
/// prices between 2**-128 and 2**128
library TickMath {
    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128
    int24 internal constant MIN_TICK = -887272;
    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128
    int24 internal constant MAX_TICK = -MIN_TICK;

    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
    uint160 internal constant MIN_SQRT_RATIO = 4295128739;
    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;

    /// @notice Calculates sqrt(1.0001^tick) * 2^96
    /// @dev Throws if |tick| > max tick
    /// @param tick The input tick for the above formula
    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
    /// at the given tick
    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
        require(absTick <= uint256(int256(MAX_TICK)), 'T');

        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;

        if (tick > 0) ratio = type(uint256).max / ratio;

        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint
        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent
        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
    }

    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio
    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may
    /// ever return.
    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96
    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio
    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
        // second inequality must be < because the price can never reach the price at the max tick
        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
        uint256 ratio = uint256(sqrtPriceX96) << 32;

        uint256 r = ratio;
        uint256 msb = 0;

        assembly {
            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(5, gt(r, 0xFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(4, gt(r, 0xFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(3, gt(r, 0xFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(2, gt(r, 0xF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(1, gt(r, 0x3))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := gt(r, 0x1)
            msb := or(msb, f)
        }

        if (msb >= 128) r = ratio >> (msb - 127);
        else r = ratio << (127 - msb);

        int256 log_2 = (int256(msb) - 128) << 64;

        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(63, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(62, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(61, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(60, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(59, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(58, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(57, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(56, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(55, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(54, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(53, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(52, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(51, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(50, f))
        }

        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number

        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);

        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
    }
}


// File contracts/libraries/OracleLibrary.sol

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.7.6;


interface IIIUniswapV3Pool {

    function observe(uint32[] calldata secondsAgos)
        external
        view
        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);


}

/// @title Oracle library
/// @notice Provides functions to integrate with V3 pool oracle
library OracleLibrary {

    /// @notice Fetches time-weighted average tick using Uniswap V3 oracle
    /// @param pool Address of Uniswap V3 pool that we want to observe
    /// @param period Number of seconds in the past to start calculating time-weighted average
    /// @return timeWeightedAverageTick The time-weighted average tick from (block.timestamp - period) to block.timestamp
    function consult(address pool, uint32 period) internal view returns (int24 timeWeightedAverageTick) {
        require(period != 0, 'BP');

        uint32[] memory secondAgos = new uint32[](2);
        secondAgos[0] = period;
        secondAgos[1] = 0;

        (int56[] memory tickCumulatives, ) = IIIUniswapV3Pool(pool).observe(secondAgos);
        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];

        timeWeightedAverageTick = int24(tickCumulativesDelta / int56( int32(period) ));

        // Always round to negative infinity
        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56( int32(period) ) != 0)) timeWeightedAverageTick--;
    }

    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange
    /// @param tick Tick value used to calculate the quote
    /// @param baseAmount Amount of token to be converted
    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination
    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination
    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken
    function getQuoteAtTick(
        int24 tick,
        uint128 baseAmount,
        address baseToken,
        address quoteToken
    ) internal pure returns (uint256 quoteAmount) {
        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);

        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself
        if (sqrtRatioX96 <= type(uint128).max) {
            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;
            quoteAmount = baseToken < quoteToken
                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)
                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);
        } else {
            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);
            quoteAmount = baseToken < quoteToken
                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)
                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);
        }
    }
}


// File contracts/connection/TokamakStakeUpgrade4.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;
pragma abicoder v2;









interface IIUniswapV3Factory {
    function getPool(address,address,uint24) external view returns (address);
}

interface IIUniswapV3Pool {

    function token0() external view returns (address);
    function token1() external view returns (address);

    function slot0()
        external
        view
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        );

}

interface IERC20BASE2 {
    function decimals() external view returns (uint256);
    function balanceOf(address owner) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
}


interface ITokamakRegistry2 {
    function getTokamak()
        external
        view
        returns (
            address,
            address,
            address,
            address,
            address
        );

    function getUniswap()
        external
        view
        returns (
            address,
            address,
            address,
            uint256,
            address
        );
}

/// @title The connector that integrates tokamak
contract TokamakStakeUpgrade4 is
    StakeTONStorage,
    AccessibleCommon
{
    using SafeMath for uint256;


    modifier lock() {
        require(_lock == 0, "TokamakStaker:LOCKED");
        _lock = 1;
        _;
        _lock = 0;
    }

    modifier onlyClosed() {
        require(IIStake1Vault(vault).saleClosed(), "TokamakStaker: not closed");
        _;
    }

    /// @dev exchange WTON to TOS using uniswap v3
    /// @param caller the sender
    /// @param amountIn the input amount
    /// @return amountOut the amount of exchanged out token
    event ExchangedWTONtoTOS(
        address caller,
        uint256 amountIn,
        uint256 amountOut
    );


    /// @dev If the tokamak addresses is not set, set the addresses.
    function checkTokamak() public {
        if (ton == address(0)) {
            (
                address _ton,
                address _wton,
                address _depositManager,
                address _seigManager,
                address _swapProxy
            ) = ITokamakRegistry2(stakeRegistry).getTokamak();

            ton = _ton;
            wton = _wton;
            depositManager = _depositManager;
            seigManager = _seigManager;
            swapProxy = _swapProxy;
        }
        require(
            ton != address(0) &&
                wton != address(0) &&
                seigManager != address(0) &&
                depositManager != address(0) &&
                swapProxy != address(0),
            "TokamakStaker:tokamak zero"
        );
    }

    function version() external pure returns (string memory) {
        return "phase1.upgrade.v4";
    }

    function getQuoteAtTick(
        int24 tick,
        uint128 amountIn,
        address baseToken,
        address quoteToken
    ) public pure returns (uint256 amountOut) {
        return OracleLibrary.getQuoteAtTick(tick, amountIn, baseToken, quoteToken);
    }

    /// @dev exchange holded WTON to TOS using uniswap
    /// @param amountIn the input amount
    function exchangeWTONtoTOS(
        uint256 amountIn
    ) external lock onlyClosed {
        require(amountIn > 0, "zero input amount");
        require(block.number <= endBlock, "TokamakStaker: period end");

        checkTokamak();

        IIUniswapV3Pool pool = IIUniswapV3Pool(getPoolAddress());
        require(address(pool) != address(0), "pool didn't exist");

        (uint160 sqrtPriceX96, int24 tick,,,,,) =  pool.slot0();
        require(sqrtPriceX96 > 0, "pool is not initialized");

        // uint24 fee = 3000;
        // int24 tickSpacings = 60;
        // int24 acceptTickChangeInterval = 8; +=5% 까지만 허용
        // minimumTickInterval = 18; 가격이 떨어져도 +-10프로, 수수료가 있어서 2틱정도 더내림
        int24 timeWeightedAverageTick = OracleLibrary.consult(address(pool), 120);
        require(
            acceptMinTick(timeWeightedAverageTick, 60, 8) <= tick
            && tick < acceptMaxTick(timeWeightedAverageTick, 60, 8),
            "It's not allowed changed tick range."
        );

        (uint256 amountOutMinimum, , uint160 sqrtPriceLimitX96)
            = limitPrameters(amountIn, address(pool), wton, token, 18);

        {
            uint256 _amountWTON = IERC20BASE2(wton).balanceOf(address(this));
            uint256 _amountTON = IERC20BASE2(ton).balanceOf(address(this));
            uint256 stakeOf = 0;
            if (tokamakLayer2 != address(0)) {
                stakeOf = IISeigManager(seigManager).stakeOf(
                    tokamakLayer2,
                    address(this)
                );
                stakeOf = stakeOf.add(
                    IIIDepositManager(depositManager).pendingUnstaked(
                        tokamakLayer2,
                        address(this)
                    )
                );
            }

            uint256 holdAmount = _amountWTON;
            if (_amountTON > 0)
                holdAmount = holdAmount.add(_amountTON.mul(10**9));
            require(
                holdAmount >= amountIn,
                "TokamakStaker: wton insufficient"
            );

            if (stakeOf > 0) holdAmount = holdAmount.add(stakeOf);

            require(
                holdAmount > totalStakedAmount.mul(10**9) &&
                    holdAmount.sub(totalStakedAmount.mul(10**9)) >= amountIn,
                "TokamakStaker:insufficient"
            );

            uint256 _amountIn = amountIn;
            if (_amountWTON < _amountIn) {
                bytes memory data = abi.encode(swapProxy, swapProxy);
                uint256 swapTON = _amountIn.sub(_amountWTON).div(10**9);
                require(
                    ITON(ton).approveAndCall(wton, swapTON, data),
                    "TokamakStaker:exchangeWTONtoTOS approveAndCall fail"
                );
            }
        }

        toUniswapWTON = toUniswapWTON.add(amountIn);
        (address uniswapRouter, , , uint256 _fee, ) =
            ITokamakRegistry2(stakeRegistry).getUniswap();
        require(uniswapRouter != address(0), "TokamakStaker:uniswap zero");
        require(
            IERC20BASE2(wton).approve(uniswapRouter, amountIn),
            "TokamakStaker:can't approve uniswapRouter"
        );

        ISwapRouter.ExactInputSingleParams memory params =
            ISwapRouter.ExactInputSingleParams({
                tokenIn: wton,
                tokenOut: token,
                fee: uint24(_fee),
                recipient: address(this),
                deadline: block.timestamp + 100,
                amountIn: amountIn,
                amountOutMinimum: amountOutMinimum,
                sqrtPriceLimitX96: sqrtPriceLimitX96
            });
        uint256 amountOut = ISwapRouter(uniswapRouter).exactInputSingle(params);

        emit ExchangedWTONtoTOS(msg.sender, amountIn, amountOut);
    }

    function getPoolAddress() public view returns(address) {
        address factory = 0x1F98431c8aD98523631AE4a59f267346ea31F984;
        return IIUniswapV3Factory(factory).getPool(wton, token, 3000);
    }

    function getDecimals(address token0, address token1) public view returns(uint256 token0Decimals, uint256 token1Decimals) {
        return (IERC20BASE2(token0).decimals(), IERC20BASE2(token1).decimals());
    }

    function getPriceX96FromSqrtPriceX96(uint160 sqrtPriceX96) public pure returns(uint256 priceX96) {
        return FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, FixedPoint96.Q96);
    }

    function getMiniTick(int24 tickSpacings) public pure returns (int24){
           return (TickMath.MIN_TICK / tickSpacings) * tickSpacings ;
    }

    function getMaxTick(int24 tickSpacings) public pure  returns (int24){
           return (TickMath.MAX_TICK / tickSpacings) * tickSpacings ;
    }

    function acceptMinTick(int24 _tick, int24 _tickSpacings, int24 _acceptTickInterval) public pure returns (int24)
    {

        int24 _minTick = getMiniTick(_tickSpacings);
        int24 _acceptMinTick = _tick - (_tickSpacings * _acceptTickInterval);

        if(_minTick < _acceptMinTick) return _acceptMinTick;
        else return _minTick;
    }

    function acceptMaxTick(int24 _tick, int24 _tickSpacings, int24 _acceptTickInterval) public pure returns (int24)
    {
        int24 _maxTick = getMaxTick(_tickSpacings);
        int24 _acceptMinTick = _tick + (_tickSpacings * _acceptTickInterval);

        if(_maxTick < _acceptMinTick) return _maxTick;
        else return _acceptMinTick;
    }

    function limitPrameters(
        uint256 amountIn,
        address _pool,
        address token0,
        address token1,
        int24 acceptTickCounts
    ) public view returns  (uint256 amountOutMinimum, uint256 priceLimit, uint160 sqrtPriceX96Limit)
    {
        IIUniswapV3Pool pool = IIUniswapV3Pool(_pool);
        (, int24 tick,,,,,) =  pool.slot0();

        int24 _tick = tick;
        if(token0 < token1) {
            _tick = tick - acceptTickCounts * 60;
            if(_tick < TickMath.MIN_TICK ) _tick =  TickMath.MIN_TICK ;
        } else {
            _tick = tick + acceptTickCounts * 60;
            if(_tick > TickMath.MAX_TICK ) _tick =  TickMath.MAX_TICK ;
        }
        address token1_ = token1;
        address token0_ = token0;
        return (
              getQuoteAtTick(
                _tick,
                uint128(amountIn),
                token0_,
                token1_
                ),
             getQuoteAtTick(
                _tick,
                uint128(10**27),
                token0_,
                token1_
             ),
             TickMath.getSqrtRatioAtTick(_tick)
        );
    }

}


// File contracts/interfaces/IEventLog.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;


/// @title IEventLog
interface IEventLog {

    /// @dev logEvent function
    /// @param contractNameHash contractNameHash
    /// @param eventNameHash eventNameHash
    /// @param contractAddress contractAddress
    /// @param data data
    function logEvent(
        bytes32 contractNameHash,
        bytes32 eventNameHash,
        address contractAddress,
        bytes memory data
        )
        external;
}


// File contracts/interfaces/IPublicSaleProxyFactory.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IPublicSaleProxyFactory {

    /// @dev Create a PublicSaleProxyFactory
    /// @param name name
    /// @param _owner proxyOwner address
    /// @param saleAddresses  [saleTokenAddress,getTokenOwner,liquidityVaultAddress]
    /// @param _index liquidityVault index
    /// @return proxy contract address
    function create(
        string calldata name,
        address _owner,
        address[3] calldata saleAddresses,
        uint256 _index
    )
        external
        returns (address);

    /// @dev setting the basicAddress
    /// @param _basicAddress [tonAddress, wtonAddress, sTOSAddress, tosAddres, uniRouterAddress, publicLogic]
    function basicSet(
        address[6] calldata _basicAddress
    )
        external;

    /// @dev setting the address, value
    /// @param _addr [upgradeAdmin, initailVault, eventLog]
    /// @param _value [minTOS, maxTOS, sTOSTier1, sTOSTier2, sTOSTier3, sTOSTier4, delayTime]
    function allSet(
        address[3] calldata _addr,
        uint256[7] calldata _value
    ) 
        external;

    /// @dev setting the admin
    /// @param addr ontherProxyManagerMasterAddress
    function setUpgradeAdmin(
        address addr
    )   
        external;

    /// @dev setting the min, max
    /// @param _min ton -> tos min percents
    /// @param _max ton -> tos max percents
    function setMaxMin(
        uint256 _min,
        uint256 _max
    )
        external;

    /// @dev setting the initialLiquidityFactoryAddress
    /// @param _vaultFactory factoryAddress
    function setVault(
        address _vaultFactory
    )
        external;

    /// @dev setting the eventLog
    /// @param _addr logContract addr
    function setEventLog(
        address _addr
    )
        external;

    /// @dev set the sTOSstandard
    /// @param _tier1 tier1 STOS
    /// @param _tier2 tier2 STOS
    /// @param _tier3 tier3 STOS
    /// @param _tier4 tier4 STOS
    function setSTOS(
        uint256 _tier1,
        uint256 _tier2,
        uint256 _tier3,
        uint256 _tier4
    ) 
        external;

    /// @dev set the delayTime
    /// @param _delay delayTime set
    function setDelay(
        uint256 _delay
    )
        external;

    /// @dev Last generated contract information
    function lastestCreated() external view returns (address contractAddress, string memory name);

    /// @dev Contract information stored in the index
    function getContracts(uint256 _index) external view returns (address contractAddress, string memory name);


}


// File contracts/interfaces/IVaultFactory.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IVaultFactory {

    /// ###### only admin ######

    /// @dev designate an admin to upgrade the vault logic later.
    /// @param addr the upgradeAdmin address
    function setUpgradeAdmin(
        address addr
    )   external;


    /// @dev set the logic address
    /// @param _logic  the logic address
    function setLogic(
        address _logic
    )   external;


    /// @dev set the contract's logic
    /// @param _contract  the contract address
    /// @param _logic  the logic address
    /// @param _index  logic index
    /// @param _alive  alive flag , true or false
    function upgradeContractLogic(
        address _contract,
        address _logic,
        uint256 _index,
        bool _alive
    )   external;


    /// @dev set the contract's function's logic
    /// @param _contract  the contract address
    /// @param _selectors  function's selectors
    /// @param _imp  logic  address
    function upgradeContractFunction(
        address _contract,
        bytes4[] calldata _selectors,
        address _imp
    )   external;


    /// @dev view the upgradeAdmin address
    /// @param admin  the upgradeAdmin address
    function upgradeAdmin() external view returns (address admin);


    /// @dev view the logic address
    /// @param logic the logic address
    function vaultLogic() external view returns (address logic);


    /// ### anybody can use

    /// @dev Last generated contract information
    /// @return contractAddress the address created
    /// @return name name
    function lastestCreated() external view returns (address contractAddress, string memory name);


    /// @dev Contract information stored in the index
    /// @return contractAddress the vault address
    /// @return name name
    function getContracts(uint256 _index) external view returns (address contractAddress, string memory name);


    /// @dev the number of total created contracts
    /// @return total  total count
    function totalCreatedContracts() external view returns (uint256 total);

}


// File contracts/interfaces/IPublicSale.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IPublicSale {
    /// @dev set changeTONOwner
    function changeTONOwner(
        address _address
    ) external; 

    /// @dev set the allsetting
    /// @param _Tier _Tier[0~3] : set the sTOS Tier standard, _Tier[4~7] : set the Tier percents
    /// @param _amount _amount[0] : Round1 Sale Amount, _amount[1] : Round2 Sale Amount, _amount[2] : saleToken Price, _amount[3] : TON Price, _amount[4] : hardcap amount, _amount[5] : ton to tos %
    /// @param _time _time[0] : sTOS snapshot time, _time[1] : whitelist startTime, _time[2] : whitelist endTime, _time[3] : round1 sale startTime, _time[4] : round1 sale endTime, _time[5] : round2 deposit startTime, _time[6] : round2 deposit endTime, _time[7] : totalClaimCounts
    /// @param _claimTimes _claimTimes[] : claim time array
    /// @param _claimPercents _claimPercents[] : claim percents array (this is need sum 100)
    function setAllsetting(
        uint256[8] calldata _Tier,
        uint256[6] calldata _amount,
        uint256[8] calldata _time,
        uint256[] calldata _claimTimes,
        uint256[] calldata _claimPercents
    ) external;
    
    /// @dev set snapshot
    /// @param _snapshot _snapshot timestamp
    function setSnapshot(uint256 _snapshot) external;

    /// @dev set information related to exclusive sale
    /// @param _startAddWhiteTime start time of addwhitelist
    /// @param _endAddWhiteTime end time of addwhitelist
    /// @param _startExclusiveTime start time of exclusive sale
    /// @param _endExclusiveTime start time of exclusive sale
    function setExclusiveTime(
        uint256 _startAddWhiteTime,
        uint256 _endAddWhiteTime,
        uint256 _startExclusiveTime,
        uint256 _endExclusiveTime
    ) external;

    /// @dev set information related to open sale
    /// @param _startDepositTime start time of deposit
    /// @param _endDepositTime end time of deposit
    function setOpenTime(
        uint256 _startDepositTime,
        uint256 _endDepositTime
    ) external;

    /// @dev set information related to open sale
    /// @param _claimCounts totalClaimCounts from this contract
    /// @param _claimTimes claim time array
    /// @param _claimPercents claim percents array (this is need sum 100)
    function setEachClaim(
        uint256 _claimCounts,
        uint256[] calldata _claimTimes,
        uint256[] calldata _claimPercents
    ) external;

    /// @dev set information related to tier and tierPercents
    /// @param _tier[4] sTOS condition setting
    /// @param _tierPercent[4] tier proportion setting
    function setAllTier(
        uint256[4] calldata _tier,
        uint256[4] calldata _tierPercent
    ) external;

    /// @dev set information related to tier
    /// @param _tier1 tier1 condition of STOS hodings
    /// @param _tier2 tier2 condition of STOS hodings
    /// @param _tier3 tier3 condition of STOS hodings
    /// @param _tier4 tier4 condition of STOS hodings
    function setTier(
        uint256 _tier1,
        uint256 _tier2,
        uint256 _tier3,
        uint256 _tier4
    ) external;

    /// @dev set information related to tier proportion for exclusive sale
    /// @param _tier1 tier1 proportion (If it is 6%, enter as 600 -> To record up to the 2nd decimal point)
    /// @param _tier2 tier2 proportion
    /// @param _tier3 tier3 proportion
    /// @param _tier4 tier4 proportion
    function setTierPercents(
        uint256 _tier1,
        uint256 _tier2,
        uint256 _tier3,
        uint256 _tier4
    ) external;

    /// @dev set information related to saleAmount and tokenPrice
    /// @param _expectAmount[2] saleAmount setting
    /// @param _priceAmount[2] tokenPrice setting
    function setAllAmount(
        uint256[2] calldata _expectAmount,
        uint256[2] calldata _priceAmount
    ) external;

    /// @dev set information related to sale amount
    /// @param _totalExpectSaleAmount expected amount of exclusive sale
    /// @param _totalExpectOpenSaleAmount expected amount of open sale
    function setSaleAmount(
        uint256 _totalExpectSaleAmount,
        uint256 _totalExpectOpenSaleAmount
    ) external;

    /// @dev set information related to token price
    /// @param _saleTokenPrice the sale token price
    /// @param _payTokenPrice  the funding(pay) token price
    function setTokenPrice(uint256 _saleTokenPrice, uint256 _payTokenPrice)
        external;

    /// @dev set the minimum getTONAmount and TON -> TOS change Percents
    /// @param _hardcapAmount the sale token price
    /// @param _changePercent  the funding(pay) token price
    function setHardcap (
        uint256 _hardcapAmount,
        uint256 _changePercent
    ) external;

    /// @dev view totalExpectOpenSaleAmount
    function totalExpectOpenSaleAmountView()
        external
        view
        returns(uint256);

    /// @dev view totalRound1NonSaleAmount
    function totalRound1NonSaleAmount() 
        external 
        view 
        returns(uint256);

    /// @dev calculate the sale Token amount
    /// @param _amount th amount
    function calculSaleToken(uint256 _amount) external view returns (uint256);

    /// @dev calculate the pay Token amount
    /// @param _amount th amount
    function calculPayToken(uint256 _amount) external view returns (uint256);

    /// @dev calculate the tier
    /// @param _address user address
    function calculTier(address _address) external view returns (uint256);

    /// @dev calculate the tier's amount
    /// @param _address user address
    function calculTierAmount(address _address) external view returns (uint256);

    /// @dev calculate the open sale amount
    /// @param _account user address
    /// @param _amount  amount
    function calculOpenSaleAmount(address _account, uint256 _amount)
        external
        view
        returns (uint256);

    /// @dev calculate the open sale amount
    /// @param _account user address
    function calculClaimAmount(address _account, uint256 _period)
        external
        view
        returns (uint256 _reward, uint256 _totalClaim, uint256 _refundAmount);


    /// @dev view totalSaleUserAmount
    function totalSaleUserAmount(address user) 
        external 
        view 
        returns (uint256 _realPayAmount, uint256 _realSaleAmount, uint256 _refundAmount);

    /// @dev view openSaleUserAmount
    function openSaleUserAmount(address user) 
        external 
        view 
        returns (uint256 _realPayAmount, uint256 _realSaleAmount, uint256 _refundAmount);
    
    /// @dev view totalOpenSaleAmount
    function totalOpenSaleAmount() 
        external 
        view 
        returns (uint256);

    /// @dev view totalOpenPurchasedAmount
    function totalOpenPurchasedAmount() 
        external
        view 
        returns (uint256);

    /// @dev execute add whitelist
    function addWhiteList() external;

    /// @dev execute exclusive sale
    /// @param _sender user address
    /// @param _amount  amount
    function exclusiveSale(address _sender,uint256 _amount) external;

    /// @dev execute deposit
    /// @param _sender user address
    /// @param _amount  amount
    function deposit(address _sender,uint256 _amount) external;

    /// @dev execute the claim
    function claim() external;

    /// @dev execute the claim
    function depositWithdraw() external;

    function _decodeApproveData(
        bytes memory data
    ) external pure returns (uint256 approveData);

    function _toWAD(uint256 v) external pure returns (uint256);

}


// File contracts/interfaces/IPublicSaleProxy.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IPublicSaleProxy {
    /// @dev set the logic
    /// @param _impl publicSaleContract Address;
    function setImplementation(address _impl) external;
    /// @dev Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external;

    /// @dev Set implementation contract
    /// @param _impl New implementation contract address
    function upgradeTo(address _impl) external;

    /// @dev view implementation address
    /// @return the logic address
    function implementation() external view returns (address);

    /// @dev initialize
    function initialize(
        address _saleTokenAddress,
        address _getTokenOwner,
        address _vaultAddress
    ) external;

    /// @dev changeBasicSet
    function changeBasicSet(
        address _getTokenAddress,
        address _sTOS,
        address _wton,
        address _uniswapRouter,
        address _TOS
    ) external;

    /// @dev set Max,Min
    /// @param _min wton->tos min Percent
    /// @param _max wton->tos max Percent
    function setMaxMinPercent(
        uint256 _min,
        uint256 _max
    ) external;

    /// @dev set sTOSstandrard
    /// @param _tier1 tier1 standrard
    /// @param _tier2 tier2 standrard
    /// @param _tier3 tier3 standrard
    /// @param _tier4 tier4 standrard
    function setSTOSstandard(
        uint256 _tier1,
        uint256 _tier2,
        uint256 _tier3,
        uint256 _tier4
    ) external;

    /// @dev set delayTime
    /// @param _delay delayTime
    function setDelayTime(
        uint256 _delay
    ) external;
}


// File contracts/interfaces/IWTON.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

interface IWTON {
    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    function onApprove(
        address owner,
        address spender,
        uint256 tonAmount,
        bytes calldata data
    ) external returns (bool);

    function burnFrom(address account, uint256 amount) external;

    function swapToTON(uint256 wtonAmount) external returns (bool);

    function swapFromTON(uint256 tonAmount) external returns (bool);

    function swapToTONAndTransfer(address to, uint256 wtonAmount)
        external
        returns (bool);

    function swapFromTONAndTransfer(address to, uint256 tonAmount)
        external
        returns (bool);

    function renounceTonMinter() external;

    function approve(address spender, uint256 amount) external returns (bool);

    function allowance(address sender, address recipient) external returns (uint256);

}


// File contracts/sale/OnApprove.sol

//SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

abstract contract OnApprove is ERC165 {
  constructor() {
    _registerInterface(OnApprove(this).onApprove.selector);
  }

  function onApprove(address owner, address spender, uint256 amount, bytes calldata data) external virtual returns (bool);
}


// File contracts/libraries/LibLockTOS.sol

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

library LibLockTOS {
    struct Point {
        int256 bias;
        int256 slope;
        uint256 timestamp;
    }

    struct LockedBalance {
        uint256 start;
        uint256 end;
        uint256 amount;
        bool withdrawn;
    }

    struct SlopeChange {
        int256 bias;
        int256 slope;
        uint256 changeTime;
    }

    struct LockedBalanceInfo {
        uint256 id;
        uint256 start;
        uint256 end;
        uint256 amount;
        uint256 balance;
    }
}


// File contracts/interfaces/ILockTOS.sol

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;
pragma abicoder v2;

interface ILockTOS {
    
    /// @dev Returns addresses of all holders of LockTOS
    function allHolders() external returns (address[] memory);

    /// @dev Returns addresses of active holders of LockTOS
    function activeHolders() external returns (address[] memory);

    /// @dev Returns all withdrawable locks
    function withdrawableLocksOf(address user) external view returns (uint256[] memory);

    /// @dev Returns all locks of `_addr`
    function locksOf(address _addr) external view returns (uint256[] memory);

    /// @dev Returns all locks of `_addr`
    function activeLocksOf(address _addr) external view returns (uint256[] memory);

    /// @dev Total locked amount of `_addr`
    function totalLockedAmountOf(address _addr) external view returns (uint256);

    /// @dev     jhswuqhdiuwjhdoiehdoijijf   bhabcgfzvg tqafstqfzys amount of `_addr`
    function withdrawableAmountOf(address _addr) external view returns (uint256);

    /// @dev Returns all locks of `_addr`
    function locksInfo(uint256 _lockId)
        external
        view
        returns (
            uint256,
            uint256,
            uint256
        );

    /// @dev Returns all history of `_addr`
    function pointHistoryOf(uint256 _lockId)
        external
        view
        returns (LibLockTOS.Point[] memory);

    /// @dev Total vote weight
    function totalSupply() external view returns (uint256);

    /// @dev Total vote weight at `_timestamp`
    function totalSupplyAt(uint256 _timestamp) external view returns (uint256);

    /// @dev Vote weight of lock at `_timestamp`
    function balanceOfLockAt(uint256 _lockId, uint256 _timestamp)
        external
        view
        returns (uint256);

    /// @dev Vote weight of lock
    function balanceOfLock(uint256 _lockId) external view returns (uint256);

    /// @dev Vote weight of a user at `_timestamp`
    function balanceOfAt(address _addr, uint256 _timestamp)
        external
        view
        returns (uint256 balance);

    /// @dev Vote weight of a iser
    function balanceOf(address _addr) external view returns (uint256 balance);

    /// @dev Increase amount
    function increaseAmount(uint256 _lockId, uint256 _value) external;

    /// @dev Deposits value for '_addr'
    function depositFor(
        address _addr,
        uint256 _lockId,
        uint256 _value
    ) external;

    /// @dev Create lock using permit
    function createLockWithPermit(
        uint256 _value,
        uint256 _unlockTime,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external returns (uint256 lockId);

    /// @dev Create lock
    function createLock(uint256 _value, uint256 _unlockTime)
        external
        returns (uint256 lockId);

    /// @dev Increase
    function increaseUnlockTime(uint256 _lockId, uint256 unlockTime) external;

    /// @dev Withdraw all TOS
    function withdrawAll() external;

    /// @dev Withdraw TOS
    function withdraw(uint256 _lockId) external;
    
    /// @dev needCheckpoint
    function needCheckpoint() external view returns (bool need);

    /// @dev Global checkpoint
    function globalCheckpoint() external;

    /// @dev set MaxTime
    function setMaxTime(uint256 _maxTime) external;
}


// File contracts/libraries/LibPublicSale.sol

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

library LibPublicSale {
    struct UserInfoEx {
        bool join;
        uint tier;
        uint256 payAmount;
        uint256 saleAmount;
    }

    struct UserInfoOpen {
        bool join;
        uint256 depositAmount;
        uint256 payAmount;
    }

    struct UserClaim {
        bool exec;
        uint256 claimAmount;
        uint256 refundAmount;
    }
}


// File contracts/sale/PublicSaleStorage.sol

//SPDX-License-Identifier: Unlicense

pragma solidity ^0.7.6;




contract PublicSaleStorage  {
    /// @dev flag for pause proxy
    bool public pauseProxy;

    uint256 public snapshot = 0;
    uint256 public deployTime;              //contract 배포된 시간
    uint256 public delayTime;               //contract와 snapshot사이 시간

    uint256 public startAddWhiteTime = 0;
    uint256 public endAddWhiteTime = 0;
    uint256 public startExclusiveTime = 0;
    uint256 public endExclusiveTime = 0;

    uint256 public startDepositTime = 0;        //청약 시작시간
    uint256 public endDepositTime = 0;          //청약 끝시간

    uint256 public startClaimTime = 0;

    uint256 public totalUsers = 0;              //전체 세일 참여자 (라운드1,라운드2 포함, 유니크)
    uint256 public totalRound1Users = 0;         //라운드 1 참여자
    uint256 public totalRound2Users = 0;         //라운드 2 참여자
    uint256 public totalRound2UsersClaim = 0;    //라운드 2 참여자중 claim한사람

    uint256 public totalExSaleAmount = 0;       //총 exclu 실제 판매토큰 양 (exclusive)
    uint256 public totalExPurchasedAmount = 0;  //총 지불토큰 받은 양 (exclusive)

    uint256 public totalDepositAmount;          //총 청약 한 양 (openSale)

    uint256 public totalExpectSaleAmount;       //예정된 판매토큰 양 (exclusive)
    uint256 public totalExpectOpenSaleAmount;   //예정된 판매 토큰량 (opensale)

    uint256 public saleTokenPrice;  //판매하는 토큰(DOC)
    uint256 public payTokenPrice;   //받는 토큰(TON)

    uint256 public claimInterval; //클레임 간격 (epochtime)
    uint256 public claimPeriod;   //클레임 횟수
    uint256 public claimFirst;    //초기 클레임 percents

    uint256 public hardCap;       //hardcap 수량 (ton 기준)
    uint256 public changeTOS;     //ton -> tos로 변경하는 %
    uint256 public minPer;        //변경하는 % min
    uint256 public maxPer;        //변경하는 % max

    uint256 public stanTier1;     //최소 기준 Tier1
    uint256 public stanTier2;     //최소 기준 Tier2
    uint256 public stanTier3;     //최소 기준 Tier3
    uint256 public stanTier4;     //최소 기준 Tier4

    address public liquidityVaultAddress; //liquidityVault의 Address
    ISwapRouter public uniswapRouter;
    uint24 public constant poolFee = 3000;

    address public getTokenOwner;
    address public wton;
    address public getToken;

    IERC20 public saleToken;
    IERC20 public tos;
    ILockTOS public sTOS;

    address[] public depositors;
    address[] public whitelists;

    bool public adminWithdraw; //withdraw 실행여부

    uint256 public totalClaimCounts;
    uint256[] public claimTimes;
    uint256[] public claimPercents; 

    mapping (address => LibPublicSale.UserInfoEx) public usersEx;
    mapping (address => LibPublicSale.UserInfoOpen) public usersOpen;
    mapping (address => LibPublicSale.UserClaim) public usersClaim;

    mapping (uint => uint256) public tiers;         //티어별 가격 설정
    mapping (uint => uint256) public tiersAccount;  //티어별 화이트리스트 참여자 숫자 기록
    mapping (uint => uint256) public tiersExAccount;  //티어별 exclusiveSale 참여자 숫자 기록
    mapping (uint => uint256) public tiersPercents;  //티어별 퍼센트 기록
}


// File contracts/stake/ProxyBase.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

abstract contract ProxyBase {
    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1))
    bytes32 internal constant IMPLEMENTATION_SLOT =
        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    /// @dev Sets the implementation address of the proxy.
    /// @param newImplementation Address of the new implementation.
    function _setImplementation(address newImplementation) internal {
        require(
            Address.isContract(newImplementation),
            "ProxyBase: Cannot set a proxy implementation to a non-contract address"
        );

        bytes32 slot = IMPLEMENTATION_SLOT;

        assembly {
            sstore(slot, newImplementation)
        }
    }

    function _implementation() internal view returns (address impl) {
        bytes32 slot = IMPLEMENTATION_SLOT;
        assembly {
            impl := sload(slot)
        }
    }
}


// File contracts/sale/PublicSaleProxy.sol

// SPDX-License-Identifier: MIT

pragma solidity ^0.7.6;





contract PublicSaleProxy is
    PublicSaleStorage,
    ProxyAccessCommon,
    ProxyBase,
    OnApprove,
    IPublicSaleProxy
{
    event Upgraded(address indexed implementation);

    event Pause(address indexed addr, uint256 time);

    /// @dev constructor of PublicSaleProxy
    constructor() {
        assert(
            IMPLEMENTATION_SLOT ==
                bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1)
        );

        _setRoleAdmin(PROJECT_ADMIN_ROLE, PROJECT_ADMIN_ROLE);
        _setupRole(PROJECT_ADMIN_ROLE, msg.sender);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    /// @dev set the logic
    /// @param _impl the logic address of PublicSaleProxy
    function setImplementation(address _impl) external override onlyProxyOwner {
        require(_impl != address(0), "PublicSaleProxy: logic is zero");

        _setImplementation(_impl);
    }

    /// @notice Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external override onlyOwner {
        pauseProxy = _pause;
        emit Pause(msg.sender,block.timestamp);
    }

    /// @notice Set implementation contract
    /// @param impl New implementation contract address
    function upgradeTo(address impl) external override onlyProxyOwner {
        require(impl != address(0), "PublicSaleProxy: input is zero");
        require(_implementation() != impl, "PublicSaleProxy: same");
        _setImplementation(impl);
        emit Upgraded(impl);
    }

    /// @dev returns the implementation
    function implementation() public override view returns (address) {
        return _implementation();
    }

    /// @dev receive ether
    receive() external payable {
        revert("cannot receive Ether");
    }

    /// @dev fallback function , execute on undefined function call
    fallback() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    function _fallback() internal {
        address _impl = _implementation();
        require(
            _impl != address(0) && !pauseProxy,
            "PublicSaleProxy: impl OR proxy is false"
        );

        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }

    /// @dev Initialize
    function initialize(
        address _saleTokenAddress,
        address _getTokenOwner,
        address _vaultAddress
    ) external override onlyProxyOwner {
        require(startAddWhiteTime == 0, "possible to setting the whiteTime before");
        saleToken = IERC20(_saleTokenAddress);
        getTokenOwner = _getTokenOwner;
        liquidityVaultAddress = _vaultAddress;
        deployTime = block.timestamp;
    }

    function changeBasicSet(
        address _getTokenAddress,
        address _sTOS,
        address _wton,
        address _uniswapRouter,
        address _TOS
    ) external override onlyProxyOwner {
        require(startAddWhiteTime == 0, "possible to setting the whiteTime before");
        getToken = _getTokenAddress;
        sTOS = ILockTOS(_sTOS);
        wton = _wton;
        uniswapRouter = ISwapRouter(_uniswapRouter);
        tos = IERC20(_TOS);
        IERC20(wton).approve(
            address(uniswapRouter),
            type(uint256).max
        );
        IERC20(getToken).approve(
            wton,
            type(uint256).max
        );
    }

    function setMaxMinPercent(
        uint256 _min,
        uint256 _max
    ) external override onlyProxyOwner {
        require(_min < _max, "need min < max");
        minPer = _min;
        maxPer = _max;
    }

    function setSTOSstandard(
        uint256 _tier1,
        uint256 _tier2,
        uint256 _tier3,
        uint256 _tier4
    ) external override onlyProxyOwner {
        require(
            (_tier1 < _tier2) &&
            (_tier2 < _tier3) &&
            (_tier3 < _tier4),
            "tier set error"
        );
        stanTier1 = _tier1;
        stanTier2 = _tier2;
        stanTier3 = _tier3;
        stanTier4 = _tier4;
    }

    function setDelayTime(
        uint256 _delay
    ) external override onlyProxyOwner {
        delayTime = _delay;
    }

    function onApprove(
        address sender,
        address spender,
        uint256 amount,
        bytes calldata data
    ) external override returns (bool) {
        require(msg.sender == address(getToken) || msg.sender == address(IWTON(wton)), "PublicSale: only accept TON and WTON approve callback");
        if(msg.sender == address(getToken)) {
            uint256 wtonAmount = IPublicSale(address(this))._decodeApproveData(data);
            if(wtonAmount == 0){
                if(block.timestamp >= startExclusiveTime && block.timestamp < endExclusiveTime) {
                    IPublicSale(address(this)).exclusiveSale(sender,amount);
                } else {
                    require(block.timestamp >= startDepositTime && block.timestamp < endDepositTime, "PublicSale: not SaleTime");
                    IPublicSale(address(this)).deposit(sender,amount);
                }
            } else {
                uint256 totalAmount = amount + wtonAmount;
                if(block.timestamp >= startExclusiveTime && block.timestamp < endExclusiveTime) {
                    IPublicSale(address(this)).exclusiveSale(sender,totalAmount);
                }
                else {
                    require(block.timestamp >= startDepositTime && block.timestamp < endDepositTime, "PublicSale: not SaleTime");
                    IPublicSale(address(this)).deposit(sender,totalAmount);
                }
            }
        } else if (msg.sender == address(IWTON(wton))) {
            uint256 wtonAmount = IPublicSale(address(this))._toWAD(amount);
            if(block.timestamp >= startExclusiveTime && block.timestamp < endExclusiveTime) {
                IPublicSale(address(this)).exclusiveSale(sender,wtonAmount);
            }
            else {
                require(block.timestamp >= startDepositTime && block.timestamp < endDepositTime, "PublicSale: not SaleTime");
                IPublicSale(address(this)).deposit(sender,wtonAmount);
            }
        }

        return true;
    }
}


// File contracts/factory/PublicSaleProxyFactory.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;





/// @title A factory that creates a PublicSaleProxy
contract PublicSaleProxyFactory is AccessibleCommon, IPublicSaleProxyFactory {

    event CreatedPublicSaleProxy(address contractAddress, string name);

    modifier nonZeroAddress(address _addr) {
        require(_addr != address(0), "PublicSaleProxyFactory: zero");
        _;
    }
    struct ContractInfo {
        address contractAddress;
        string name;
    }

    /// @dev Total number of contracts created
    uint256 public totalCreatedContracts ;

    uint256 public minTOS;
    uint256 public maxTOS;

    address public tonAddress;
    address public wtonAddress;
    address public sTOSAddress;
    address public tosAddress;
    address public uniRouterAddress;

    address public vaultFactory;
    address public logEventAddress;

    address public publicLogic;    
    address public upgradeAdmin;
    
    uint256 public tier1;
    uint256 public tier2;
    uint256 public tier3;
    uint256 public tier4;

    uint256 public delayTime;

    /// @dev Contract information by index
    mapping(uint256 => ContractInfo) public createdContracts;

    /// @dev constructor of PublicSaleProxyFactory
    constructor() {
        totalCreatedContracts = 0;

        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, msg.sender);
        upgradeAdmin = msg.sender;
    }

    /// @inheritdoc IPublicSaleProxyFactory
    /// @notice _logic = PublicSale, _owner = contract admin
    /// saleAddress[0] = _saleTokenAddress, saleAddress[1] = getTokenOwner, saleAddress[2] = liquidityVaultAddress
    function create(
        string calldata name,
        address _owner,
        address[3] calldata saleAddresses,
        uint256 _index
    )
        external override
        nonZeroAddress(_owner)
        nonZeroAddress(saleAddresses[0])
        nonZeroAddress(saleAddresses[1])
        nonZeroAddress(saleAddresses[2])
        returns (address)
    {
        require(bytes(name).length > 0,"name is empty");

        PublicSaleProxy proxy = new PublicSaleProxy();

        require(
            address(proxy) != address(0),
            "proxy zero"
        );

        (address initialVault, ) = IVaultFactory(vaultFactory).getContracts(_index);
        require(initialVault == saleAddresses[2], "another liquidityVault");

        proxy.addProxyAdmin(upgradeAdmin);
        proxy.addAdmin(upgradeAdmin);
        proxy.addAdmin(_owner);
        proxy.setImplementation(publicLogic);

        proxy.initialize(
            saleAddresses[0],
            saleAddresses[1],
            saleAddresses[2]
        );

        proxy.changeBasicSet(
            tonAddress,
            sTOSAddress,
            wtonAddress,
            uniRouterAddress,
            tosAddress
        );

        proxy.setMaxMinPercent(
            minTOS,
            maxTOS
        );

        proxy.setSTOSstandard(
            tier1,
            tier2,
            tier3,
            tier4
        );

        proxy.setDelayTime(
            delayTime
        );


        proxy.removeAdmin();

        createdContracts[totalCreatedContracts] = ContractInfo(address(proxy), name);
        totalCreatedContracts++;

        bytes memory abiencode = abi.encode(address(proxy), name);

        IEventLog(logEventAddress).logEvent(
            keccak256("PublicSaleProxyFactory"),
            keccak256("CreatedPublicSaleProxy"),
            address(this),
            abiencode
        );

        emit CreatedPublicSaleProxy(address(proxy), name);

        return address(proxy);
    }

    /// @inheritdoc IPublicSaleProxyFactory
    function basicSet(
        address[6] calldata _basicAddress
    )
        external 
        override
        onlyOwner
    {
        tonAddress = _basicAddress[0];
        wtonAddress = _basicAddress[1];
        sTOSAddress = _basicAddress[2];
        tosAddress = _basicAddress[3];
        uniRouterAddress = _basicAddress[4];
        publicLogic = _basicAddress[5];
    }

    function allSet(
        address[3] calldata _addr,
        uint256[7] calldata _value
    ) 
        external
        override
        onlyOwner
    {
        setUpgradeAdmin(_addr[0]);
        setVault(_addr[1]);
        setEventLog(_addr[2]);
        setMaxMin(_value[0],_value[1]);
        setSTOS(_value[2],_value[3],_value[4],_value[5]);
        setDelay(_value[6]);
    }

    function setUpgradeAdmin(
        address addr
    )   
        public
        override 
        onlyOwner
        nonZeroAddress(addr)
    {
        require(addr != upgradeAdmin, "same addrs");
        upgradeAdmin = addr;
    }

    function setVault(
        address _vaultFactory
    )
        public
        override
        onlyOwner
    {
        require(_vaultFactory != vaultFactory, "same addrs");
        vaultFactory = _vaultFactory;
    }

    function setEventLog(
        address _addr
    )
        public
        override
        onlyOwner
    {   
        require(_addr != logEventAddress, "same addrs");
        logEventAddress = _addr;
    }

    function setMaxMin(
        uint256 _min,
        uint256 _max
    )
        public
        override
        onlyOwner
    {
        require(_min < _max, "need min < max");
        minTOS = _min;
        maxTOS = _max;
    }

    function setSTOS(
        uint256 _tier1,
        uint256 _tier2,
        uint256 _tier3,
        uint256 _tier4
    ) 
        public
        override
        onlyOwner
    {
        require(
            (_tier1 < _tier2) &&
            (_tier2 < _tier3) &&
            (_tier3 < _tier4),
            "tier set error"
        );
        tier1 = _tier1;
        tier2 = _tier2;
        tier3 = _tier3;
        tier4 = _tier4;
    }

    function setDelay(
        uint256 _delay
    )
        public
        override
        onlyOwner
    {
        require(delayTime != _delay, "same value");
        delayTime = _delay;
    }
    
    

    /// @inheritdoc IPublicSaleProxyFactory
    function lastestCreated() external view override returns (address contractAddress, string memory name){
        if(totalCreatedContracts > 0){
            return (createdContracts[totalCreatedContracts-1].contractAddress, createdContracts[totalCreatedContracts-1].name );
        } else {
            return (address(0), "");
        }
    }

    /// @inheritdoc IPublicSaleProxyFactory
    function getContracts(uint256 _index) external view override returns (address contractAddress, string memory name){
        if(_index < totalCreatedContracts){
            return (createdContracts[_index].contractAddress, createdContracts[_index].name);
        } else {
            return (address(0), "");
        }
    }

}


// File contracts/interfaces/IStakeCoinageFactory.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

interface IStakeCoinageFactory {
    function deploy(address owner) external returns (address);
}


// File contracts/interfaces/IAutoRefactorCoinageWithTokenId.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

interface IAutoRefactorCoinageWithTokenId {
    function factor() external view returns (uint256);

    function _factor() external view returns (uint256);

    function refactorCount() external view returns (uint256);

    function balancesTokenId(uint256 tokenId)
        external
        view
        returns (
            uint256 balance,
            uint256 refactoredCount,
            uint256 remain
        );

    function setFactor(uint256 factor_) external returns (uint256);

    function burn(
        address tokenOwner,
        uint256 tokenId,
        uint256 amount
    ) external;

    function mint(
        address tokenOwner,
        uint256 tokenId,
        uint256 amount
    ) external returns (bool);

    function totalSupply() external view returns (uint256);

    function balanceOf(uint256 tokenId) external view returns (uint256);

    function burnTokenId(address tokenOwner, uint256 tokenId) external;
}


// File contracts/libraries/DSMath.sol

// SPDX-License-Identifier: GPL-3.0-or-later
// https://github.com/dapphub/ds-math/blob/de45767/src/math.sol
/// math.sol -- mixin for inline numerical wizardry

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity >0.4.13;

contract DSMath {
    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require((z = x + y) >= x, "ds-math-add-overflow");
    }

    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require((z = x - y) <= x, "ds-math-sub-underflow");
    }

    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");
    }

    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {
        return x <= y ? x : y;
    }

    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {
        return x >= y ? x : y;
    }

    function imin(int256 x, int256 y) internal pure returns (int256 z) {
        return x <= y ? x : y;
    }

    function imax(int256 x, int256 y) internal pure returns (int256 z) {
        return x >= y ? x : y;
    }

    uint256 constant WAD = 10**18;
    uint256 constant RAY = 10**27;

    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = add(mul(x, y), WAD / 2) / WAD;
    }

    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = add(mul(x, y), RAY / 2) / RAY;
    }

    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = add(mul(x, WAD), y / 2) / y;
    }

    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = add(mul(x, RAY), y / 2) / y;
    }

    function wmul2(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = mul(x, y) / WAD;
    }

    function rmul2(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = mul(x, y) / RAY;
    }

    function wdiv2(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = mul(x, WAD) / y;
    }

    function rdiv2(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = mul(x, RAY) / y;
    }

    // This famous algorithm is called "exponentiation by squaring"
    // and calculates x^n with x as fixed-point and n as regular unsigned.
    //
    // It's O(log n), instead of O(n) for naive repeated multiplication.
    //
    // These facts are why it works:
    //
    //  If n is even, then x^n = (x^2)^(n/2).
    //  If n is odd,  then x^n = x * x^(n-1),
    //   and applying the equation for even x gives
    //  x^n = x * (x^2)^((n-1) / 2).
    //
    //  Also, EVM division is flooring and
    //  floor[(n-1) / 2] = floor[n / 2].
    //
    function wpow(uint256 x, uint256 n) internal pure returns (uint256 z) {
        z = n % 2 != 0 ? x : WAD;

        for (n /= 2; n != 0; n /= 2) {
            x = wmul(x, x);

            if (n % 2 != 0) {
                z = wmul(z, x);
            }
        }
    }

    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {
        z = n % 2 != 0 ? x : RAY;

        for (n /= 2; n != 0; n /= 2) {
            x = rmul(x, x);

            if (n % 2 != 0) {
                z = rmul(z, x);
            }
        }
    }
}


// File contracts/tokens/AutoRefactorCoinageWithTokenId.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;



/**
 * @dev Implementation of coin age token based on ERC20 of openzeppelin-solidity
 *
 * AutoRefactorCoinageWithTokenId stores `_totalSupply` and `_balances` as RAY BASED value,
 * `_allowances` as RAY FACTORED value.
 *
 * This takes public function (including _approve) parameters as RAY FACTORED value
 * and internal function (including approve) parameters as RAY BASED value, and emits event in RAY FACTORED value.
 *
 * `RAY BASED` = `RAY FACTORED`  / factor
 *
 *  factor increases exponentially for each block mined.
 */
contract AutoRefactorCoinageWithTokenId is
    DSMath,
    AccessibleCommon,
    IAutoRefactorCoinageWithTokenId
{
    struct Balance {
        uint256 balance;
        uint256 refactoredCount;
        uint256 remain;
    }

    // string public _name;
    // string public _symbol;
    uint8 public decimal = 27;
    uint256 public REFACTOR_BOUNDARY = 10**28;
    uint256 public REFACTOR_DIVIDER = 2;

    uint256 public override refactorCount;

    mapping(uint256 => Balance) public balances;

    Balance public _totalSupply;

    uint256 public override _factor;

    bool internal _transfersEnabled;

    event FactorSet(uint256 previous, uint256 current, uint256 shiftCount);

    modifier nonZero(uint256 tokenId) {
        require(tokenId != 0, "AutoRefactorCoinageWithTokenId:zero address");
        _;
    }
    modifier nonZeroAddress(address account) {
        require(
            account != address(0),
            "AutoRefactorCoinageWithTokenId:zero address"
        );
        _;
    }

    /// @dev event on mining
    /// @param tokenOwner owner of tokenId
    /// @param tokenId mining tokenId
    /// @param amount  mined amount
    event Mined(
        address indexed tokenOwner,
        uint256 indexed tokenId,
        uint256 amount
    );

    /// @dev event on burn
    /// @param tokenOwner owner of tokenId
    /// @param tokenId mining tokenId
    /// @param amount  mined amount
    event Burned(
        address indexed tokenOwner,
        uint256 indexed tokenId,
        uint256 amount
    );

    constructor(uint256 initfactor) {
        _factor = initfactor;

        //_factorIncrement = factorIncrement;
        //_lastBlock = block.number;
        //_transfersEnabled = transfersEnabled;

        //_setupDecimals(decimal);

        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function factor() public view override returns (uint256) {
        uint256 result = _factor;
        for (uint256 i = 0; i < refactorCount; i++) {
            result = result * (REFACTOR_DIVIDER);
        }
        return result;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view override returns (uint256) {
        return
            _applyFactor(_totalSupply.balance, _totalSupply.refactoredCount) +
            (_totalSupply.remain);
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(uint256 tokenId) public view override returns (uint256) {
        Balance storage b = balances[tokenId];

        return _applyFactor(b.balance, b.refactoredCount) + (b.remain);
    }

    /** @dev Creates `amount` tokens and assigns them to `tokenId`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(
        address tokenOwner,
        uint256 tokenId,
        uint256 amount
    ) internal {
        require(
            tokenId != 0,
            "AutoRefactorCoinageWithTokenId: mint to the zero tokenId"
        );
        Balance storage b = balances[tokenId];

        uint256 currentBalance = balanceOf(tokenId);
        uint256 newBalance = currentBalance + amount;

        uint256 rbAmount = _toRAYBased(newBalance);
        b.balance = rbAmount;
        b.refactoredCount = refactorCount;

        addTotalSupply(amount);
        emit Mined(tokenOwner, tokenId, _toRAYFactored(rbAmount));
    }

    /**
     * @dev Destroys `amount` tokens from `tokenId`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `tokenId` cannot be the zero .
     * - `tokenId` must have at least `amount` tokens.
     */
    function _burn(
        address tokenOwner,
        uint256 tokenId,
        uint256 amount
    ) internal {
        require(
            tokenId != 0,
            "AutoRefactorCoinageWithTokenId: burn from the zero tokenId"
        );
        Balance storage b = balances[tokenId];

        uint256 currentBalance = balanceOf(tokenId);
        uint256 newBalance = currentBalance - amount;

        uint256 rbAmount = _toRAYBased(newBalance);
        b.balance = rbAmount;
        b.refactoredCount = refactorCount;

        subTotalSupply(amount);
        emit Burned(tokenOwner, tokenId, _toRAYFactored(rbAmount));
    }

    // helpers

    /**
     * @param v the value to be factored
     */
    function _applyFactor(uint256 v, uint256 refactoredCount)
        internal
        view
        returns (uint256)
    {
        if (v == 0) {
            return 0;
        }

        v = rmul2(v, _factor);

        for (uint256 i = refactoredCount; i < refactorCount; i++) {
            v = v * (REFACTOR_DIVIDER);
        }

        return v;
    }

    /**
     * @dev Calculate RAY BASED from RAY FACTORED
     */
    function _toRAYBased(uint256 rf) internal view returns (uint256 rb) {
        return rdiv2(rf, _factor);
    }

    /**
     * @dev Calculate RAY FACTORED from RAY BASED
     */
    function _toRAYFactored(uint256 rb) internal view returns (uint256 rf) {
        return rmul2(rb, _factor);
    }

    // new

    function setFactor(uint256 infactor)
        external
        override
        onlyOwner
        returns (uint256)
    {
        uint256 previous = _factor;

        uint256 count = 0;
        uint256 f = infactor;
        for (; f >= REFACTOR_BOUNDARY; f = (f / REFACTOR_DIVIDER)) {
            count = count + 1;
        }

        refactorCount = count;
        _factor = f;
        emit FactorSet(previous, f, count);

        return _factor;
    }

    function addTotalSupply(uint256 amount) internal {
        uint256 currentSupply =
            _applyFactor(_totalSupply.balance, _totalSupply.refactoredCount);
        uint256 newSupply = currentSupply + amount;

        uint256 rbAmount = _toRAYBased(newSupply);
        _totalSupply.balance = rbAmount;
        _totalSupply.refactoredCount = refactorCount;
    }

    function subTotalSupply(uint256 amount) internal {
        uint256 currentSupply =
            _applyFactor(_totalSupply.balance, _totalSupply.refactoredCount);
        uint256 newSupply = currentSupply - amount;

        uint256 rbAmount = _toRAYBased(newSupply);
        _totalSupply.balance = rbAmount;
        _totalSupply.refactoredCount = refactorCount;
    }

    /**
     * @dev See {ERC20-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the {MinterRole}.
     */
    function mint(
        address tokenOwner,
        uint256 tokenId,
        uint256 amount
    )
        public
        override
        onlyOwner
        nonZeroAddress(tokenOwner)
        nonZero(tokenId)
        returns (bool)
    {
        _mint(tokenOwner, tokenId, amount);
        return true;
    }

    /**
     * @dev Destroys `amount` tokens from the caller.
     *
     * See {ERC20-_burn}.
     */
    function burn(
        address tokenOwner,
        uint256 tokenId,
        uint256 amount
    ) public override onlyOwner {
        require(
            amount <= balanceOf(tokenId),
            "AutoRefactorCoinageWithTokenId: Insufficient balance of token ID"
        );
        if (amount > totalSupply()) _burn(tokenOwner, tokenId, totalSupply());
        else _burn(tokenOwner, tokenId, amount);
    }

    function burnTokenId(address tokenOwner, uint256 tokenId)
        public
        override
        onlyOwner
    {
        uint256 amount = totalSupply();
        if (amount < balanceOf(tokenId)) _burn(tokenOwner, tokenId, amount);
        else _burn(tokenOwner, tokenId, balanceOf(tokenId));
    }

    function balancesTokenId(uint256 tokenId)
        public
        view
        override
        returns (
            uint256 balance,
            uint256 refactoredCount,
            uint256 remain
        )
    {
        return (
            balances[tokenId].balance,
            balances[tokenId].refactoredCount,
            balances[tokenId].remain
        );
    }
}


// File contracts/factory/StakeCoinageFactory.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;


contract StakeCoinageFactory is IStakeCoinageFactory {
    uint256 public constant RAY = 10**27; // 1 RAY
    uint256 internal constant _DEFAULT_FACTOR = RAY;

    function deploy(address owner) external override returns (address) {
        AutoRefactorCoinageWithTokenId c =
            new AutoRefactorCoinageWithTokenId(_DEFAULT_FACTOR);

        c.transferAdmin(owner);

        return address(c);
    }
}


// File contracts/interfaces/IStakeContractFactory.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStakeContractFactory {
    /// @dev Create a stake contract that can stake TON.
    /// @param _addr the array of [token, paytoken, vault, defiAddr]
    /// @param _registry  the registry address
    /// @param _intdata the array of [saleStartBlock, startBlock, periodBlocks]
    /// @param owner  owner address
    /// @return contract address
    function create(
        address[4] calldata _addr,
        address _registry,
        uint256[3] calldata _intdata,
        address owner
    ) external returns (address);
}


// File contracts/interfaces/IStakeDefiProxy.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStakeDefiProxy {
    /// @dev Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external;

    /// @dev Set implementation contract
    /// @param impl New implementation contract address
    function upgradeTo(address impl) external;

    /// @dev view implementation address
    /// @return the logic address
    function implementation() external view returns (address);
}


// File contracts/stake/StakeDefiProxy.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;




/// @title Proxy for stake defi contract
contract StakeDefiProxy is
    Stake1Storage,
    AccessibleCommon,
    ProxyBase,
    IStakeDefiProxy
{
    event Upgraded(address indexed implementation);

    /// @dev constructor of StakeDefiProxy
    /// @param _logic the logic address that used in proxy
    constructor(address _logic) {
        assert(
            IMPLEMENTATION_SLOT ==
                bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1)
        );

        require(_logic != address(0), "StakeDefiProxy: logic is zero");

        _setImplementation(_logic);

        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, address(this));
    }

    /// @dev Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external override onlyOwner {
        pauseProxy = _pause;
    }

    /// @dev Set implementation contract
    /// @param impl New implementation contract address
    function upgradeTo(address impl) external override onlyOwner {
        require(impl != address(0), "StakeDefiProxy: input is zero");
        require(_implementation() != impl, "same");
        _setImplementation(impl);
        emit Upgraded(impl);
    }

    /// @dev returns the implementation
    function implementation() external view override returns (address) {
        return _implementation();
    }

    /// @dev receive ether
    receive() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    fallback() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    function _fallback() internal {
        address _impl = _implementation();
        require(
            _impl != address(0) && !pauseProxy,
            "StakeDefiProxy: impl is zero OR proxy is false"
        );

        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }

    /// @dev set initial storage
    /// @param _addr the array addresses of token, paytoken, vault, defiAddr
    /// @param _registry teh registry address
    /// @param _intdata the array valued of saleStartBlock, stakeStartBlock, periodBlocks
    function setInit(
        address[4] memory _addr,
        address _registry,
        uint256[3] memory _intdata
    ) external onlyOwner {
        require(token == address(0), "StakeDefiProxy: already initialized");
        require(
            _addr[2] != address(0) && _intdata[0] < _intdata[1],
            "StakeDefiProxy: setInit fail"
        );
        token = _addr[0];
        paytoken = _addr[1];
        vault = _addr[2];
        defiAddr = _addr[3];

        stakeRegistry = _registry;

        saleStartBlock = _intdata[0];
        startBlock = _intdata[1];
        endBlock = startBlock + _intdata[2];
    }
}


// File contracts/factory/StakeDefiFactory.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;



/// @title A factory that creates a stake contract that can function as a DeFi function
contract StakeDefiFactory is AccessRoleCommon, IStakeContractFactory {
    address public stakeDefiLogic;

    /// @dev constructor of StakeDefiFactory
    /// @param _stakeDefiLogic the logic address used in StakeDefiFactory
    constructor(address _stakeDefiLogic) {
        require(_stakeDefiLogic != address(0), "StakeDefiFactory: logic zero");
        stakeDefiLogic = _stakeDefiLogic;
    }

    /// @dev Create a stake contract that can operate the staked amount as a DeFi project.
    /// @param _addr array of [token, paytoken, vault, defiAddr]
    /// @param _registry  registry address
    /// @param _intdata array of [saleStartBlock, startBlock, periodBlocks]
    /// @param owner  owner address
    /// @return contract address
    function create(
        address[4] calldata _addr,
        address _registry,
        uint256[3] calldata _intdata,
        address owner
    ) external override returns (address) {
        StakeDefiProxy proxy = new StakeDefiProxy(stakeDefiLogic);
        require(address(proxy) != address(0), "StakeDefiFactory: proxy zero");

        proxy.setInit(_addr, _registry, _intdata);
        proxy.grantRole(ADMIN_ROLE, owner);
        proxy.revokeRole(ADMIN_ROLE, address(this));

        return address(proxy);
    }
}


// File contracts/interfaces/IStakeFactory.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStakeFactory {
    /// @dev Create a stake contract that calls the desired stake factory according to stakeType
    /// @param stakeType if 0, stakeTONFactory, else if 1 , stakeSimpleFactory , else if 2, stakeUniswapV3Factory
    /// @param _addr array of [token, paytoken, vault, _defiAddr]
    /// @param registry  registry address
    /// @param _intdata array of [saleStartBlock, startBlock, periodBlocks]
    /// @return contract address
    function create(
        uint256 stakeType,
        address[4] calldata _addr,
        address registry,
        uint256[3] calldata _intdata
    ) external returns (address);

    /// @dev Set factory address by StakeType
    /// @param _stakeType the stake type , 0:TON, 1: Simple, 2: UniswapV3LP
    /// @param _factory the factory address
    function setFactoryByStakeType(uint256 _stakeType, address _factory)
        external;
}


// File contracts/factory/StakeFactory.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;


/// @title A factory that calls the desired stake factory according to stakeType
contract StakeFactory is IStakeFactory, AccessibleCommon {
    mapping(uint256 => address) public factory;

    modifier nonZero(address _addr) {
        require(_addr != address(0), "StakeFactory: zero");
        _;
    }

    /// @dev constructor of StakeFactory
    /// @param _stakeSimpleFactory the logic address used in StakeSimpleFactory
    /// @param _stakeTONFactory the logic address used in StakeTONFactory
    /// @param _stakeUniswapV3Factory the logic address used in StakeUniswapV3Factory
    constructor(
        address _stakeSimpleFactory,
        address _stakeTONFactory,
        address _stakeUniswapV3Factory
    ) {
        require(_stakeTONFactory != address(0), "StakeFactory: init fail");

        factory[0] = _stakeTONFactory;
        //factory[1] = _stakeSimpleFactory;
        //factory[2] = _stakeUniswapV3Factory;

        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    /// @dev Set factory address by StakeType
    /// @param _stakeType the stake type , 0:TON, 1: Simple, 2: UniswapV3LP, may continue to be added.
    /// @param _factory the factory address
    function setFactoryByStakeType(uint256 _stakeType, address _factory)
        external
        override
        onlyOwner
        nonZero(_factory)
    {
        factory[_stakeType] = _factory;
    }

    /// @dev Create a stake contract that calls the desired stake factory according to stakeType
    /// @param stakeType if 0, stakeTONFactory, else if 1 , stakeSimpleFactory , else if 2, stakeUniswapV3Factory
    /// @param _addr array of [token, paytoken, vault, _defiAddr]
    ///         or when stakeTyoe ==2 , [tos,0 , vault, 0 ]
    /// @param registry  registry address
    /// @param _intdata array of [saleStartBlock, startBlock, periodBlocks]
    ///         or when stakeTyoe ==2 , [cap, rewardPerBlock, 0]
    /// @return contract address
    function create(
        uint256 stakeType,
        address[4] calldata _addr,
        address registry,
        uint256[3] calldata _intdata
    ) external override onlyOwner returns (address) {
        require(
            factory[stakeType] != address(0),
            "StakeFactory: zero factory "
        );
        require(_addr[2] != address(0), "StakeFactory: vault zero");

        address proxy =
            IStakeContractFactory(factory[stakeType]).create(
                _addr,
                registry,
                _intdata,
                msg.sender
            );

        require(proxy != address(0), "StakeFactory: proxy zero");

        return proxy;
    }
}


// File contracts/stake/StakeSimpleProxy.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;
//pragma abicoder v2;



/// @title Proxy for Simple Stake contracts
/// @notice
contract StakeSimpleProxy is Stake1Storage, AccessibleCommon, ProxyBase {
    event Upgraded(address indexed implementation);

    constructor(address _logic) {
        assert(
            IMPLEMENTATION_SLOT ==
                bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1)
        );
        require(_logic != address(0), "StakeSimpleProxy: logic is zero");

        _setImplementation(_logic);

        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, address(this));
    }

    /// @notice Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external onlyOwner {
        pauseProxy = _pause;
    }

    /// @notice Set implementation contract
    /// @param impl New implementation contract address
    function upgradeTo(address impl) external onlyOwner {
        require(impl != address(0), "StakeSimpleProxy: input is zero");
        require(_implementation() != impl, "StakeSimpleProxy: same");
        _setImplementation(impl);
        emit Upgraded(impl);
    }

    /// @dev returns the implementation
    function implementation() public view returns (address) {
        return _implementation();
    }

    receive() external payable {
        _fallback();
    }

    fallback() external payable {
        _fallback();
    }

    function _fallback() internal {
        address _impl = _implementation();
        require(
            _impl != address(0) && !pauseProxy,
            "StakeSimpleProxy: impl is zero OR proxy is false"
        );

        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }

    /// @dev set initial storage
    /// @param _addr the array addresses of token, paytoken, vault, defiAddr
    /// @param _intdata the array valued of saleStartBlock, stakeStartBlock, periodBlocks
    function setInit(
        address[4] memory _addr,
        address _registry,
        uint256[3] memory _intdata
    ) external onlyOwner {
        require(token == address(0), "StakeSimpleProxy: already initialized");
        require(
            _addr[2] != address(0) && _intdata[0] < _intdata[1],
            "StakeSimpleProxy: setInit fail"
        );
        token = _addr[0];
        paytoken = _addr[1];
        vault = _addr[2];
        defiAddr = _addr[3];

        stakeRegistry = _registry;

        saleStartBlock = _intdata[0];
        startBlock = _intdata[1];
        endBlock = startBlock + _intdata[2];
    }
}


// File contracts/factory/StakeSimpleFactory.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;



/// @title A factory that creates a stake contract
contract StakeSimpleFactory is AccessRoleCommon, IStakeContractFactory {
    address public stakeSimpleLogic;

    /// @dev constructor of StakeSimpleFactory
    /// @param _stakeSimpleLogic the logic address used in StakeSimpleFactory
    constructor(address _stakeSimpleLogic) {
        require(
            _stakeSimpleLogic != address(0),
            "StakeSimpleFactory: logic zero"
        );
        stakeSimpleLogic = _stakeSimpleLogic;
    }

    /// @dev Create a stake contract that can operate the staked amount as a DeFi project.
    /// @param _addr array of [token, paytoken, vault, defiAddr]
    /// @param _intdata array of [saleStartBlock, startBlock, periodBlocks]
    /// @param owner  owner address
    /// @return contract address
    function create(
        address[4] calldata _addr,
        address _registry,
        uint256[3] calldata _intdata,
        address owner
    ) external override returns (address) {
        StakeSimpleProxy proxy = new StakeSimpleProxy(stakeSimpleLogic);
        require(address(proxy) != address(0), "StakeSimpleFactory: proxy zero");

        proxy.setInit(_addr, _registry, _intdata);
        proxy.grantRole(ADMIN_ROLE, owner);
        proxy.revokeRole(ADMIN_ROLE, address(this));

        return address(proxy);
    }
}


// File contracts/interfaces/IStakeTONProxyFactory.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

interface IStakeTONProxyFactory {
    /// @dev Create a StakeTONProxy that can stake TON.
    /// @param _logic the logic contract address used in proxy
    /// @param _addr the array of [token, paytoken, vault, defiAddr]
    /// @param _registry the registry address
    /// @param _intdata the array of [saleStartBlock, startBlock, periodBlocks]
    /// @param owner  owner address
    /// @return contract address
    function deploy(
        address _logic,
        address[4] calldata _addr,
        address _registry,
        uint256[3] calldata _intdata,
        address owner
    ) external returns (address);
}


// File contracts/factory/StakeTONFactory.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;


/// @title A factory that creates a stake contract that can stake TON
contract StakeTONFactory is IStakeContractFactory {
    address public stakeTONProxyFactory;
    address public stakeTONLogic;

    /// @dev constructor of StakeTONFactory
    /// @param _stakeTONProxyFactory the StakeTONProxyFactory address used in StakeTONFactory
    /// @param _stakeTONLogic the StakeTONLogic address used in StakeTONFactory
    constructor(address _stakeTONProxyFactory, address _stakeTONLogic) {
        require(
            _stakeTONProxyFactory != address(0) && _stakeTONLogic != address(0),
            "StakeTONFactory: zero"
        );
        stakeTONProxyFactory = _stakeTONProxyFactory;
        stakeTONLogic = _stakeTONLogic;
    }

    /// @dev Create a stake contract that can stake TON.
    /// @param _addr the array of [token, paytoken, vault, defiAddr]
    /// @param _registry  the registry address
    /// @param _intdata the array of [saleStartBlock, startBlock, periodBlocks]
    /// @param owner  owner address
    /// @return contract address
    function create(
        address[4] memory _addr,
        address _registry,
        uint256[3] memory _intdata,
        address owner
    ) external override returns (address) {
        address proxy =
            IStakeTONProxyFactory(stakeTONProxyFactory).deploy(
                stakeTONLogic,
                _addr,
                _registry,
                _intdata,
                owner
            );

        require(proxy != address(0), "StakeTONFactory: proxy zero");

        return proxy;
    }
}


// File contracts/interfaces/IIERC20.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IIERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function mint(address account, uint256 amount) external;

     /**
     * @dev Destroys `amount` tokens from the caller.
     *
     * See {ERC20-_burn}.
     */
    function burn(uint256 amount) external ;


    /**
    * @dev  Moves `amount` tokens from the caller's account to `recipient`.
    */
    function safeTransfer(address recipient, uint256 amount) external;

    /**
    * @dev Moves `amount` tokens from the caller's account to `recipient`.
    */
    function safeTransfer(address recipient, uint256 amount, bytes memory data)  external;

    /**
    * @dev Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism.
    * `amount` is then deducted from the caller's allowance.
    */
    function safeTransferFrom(address sender, address recipient, uint256 amount) external ;

    /**
    * @dev Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism.
    * `amount` is then deducted from the caller's allowance.
    */
    function safeTransferFrom(address sender, address recipient, uint256 amount, bytes memory data) external ;

    /**
     * @dev Destroys `amount` tokens from `account`, deducting from the caller's
     * allowance.
     *
     * See {ERC20-_burn} and {ERC20-allowance}.
     *
     * Requirements:
     *
     * - the caller must have allowance for ``accounts``'s tokens of at least
     * `amount`.
     */
    function burnFrom(address account, uint256 amount) external ;

    function approveAndCall(address spender, uint256 amount, bytes memory data) external returns (bool) ;

    /**
     * @dev See {IERC20Permit-permit}.
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;


    /**
    onlyRole(SNAPSHOT_ROLE)
     */
    function snapshot() external returns (uint256) ;

    /**
     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.
     */
    function balanceOfAt(address account, uint256 snapshotId) external view returns (uint256) ;

    /**
     * @dev Retrieves the total supply at the time `snapshotId` was created.
     */
    function totalSupplyAt(uint256 snapshotId) external view returns (uint256) ;


    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) external view returns (bool);

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {AccessControl-_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) external;

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {AccessControl-_setupRole}.
     */
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

}


// File contracts/interfaces/IStakeVaultStorage.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;
pragma abicoder v2;

interface IStakeVaultStorage {
    /// @dev reward token : TOS
    function tos() external view returns (address);

    /// @dev paytoken is the token that the user stakes.
    function paytoken() external view returns (address);

    /// @dev allocated amount of TOS
    function cap() external view returns (uint256);

    /// @dev Operation type of staking amount
    function stakeType() external view returns (uint256);

    /// @dev External contract address used when operating the staking amount
    function defiAddr() external view returns (address);

    /// @dev the start block for sale.
    function saleStartBlock() external view returns (uint256);

    /// @dev the staking start block
    function stakeStartBlock() external view returns (uint256);

    /// @dev the staking end block.
    function stakeEndBlock() external view returns (uint256);

    /// @dev the staking real end block.
    function realEndBlock() external view returns (uint256);

    /// @dev reward amount per block
    function blockTotalReward() external view returns (uint256);

    /// @dev sale closed flag
    function saleClosed() external view returns (bool);

    /// @dev the total staked amount stored at orderedEndBlock’s end block time
    function stakeEndBlockTotal(uint256 endblock)
        external
        view
        returns (uint256 totalStakedAmount);
}


// File contracts/tokens/OnApprove.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

abstract contract OnApprove is ERC165 {
    constructor() {
        _registerInterface(OnApprove(this).onApprove.selector);
    }

    // solhint-disable-next-line max-line-length
    function onApprove(
        address owner,
        address spender,
        uint256 amount,
        bytes calldata data
    ) external virtual returns (bool);
}


// File contracts/stake/StakeTONProxy.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;
pragma abicoder v2;







/// @title Proxy for Stake contracts in Phase 1
contract StakeTONProxy is
    StakeTONStorage,
    AccessibleCommon,
    ProxyBase,
    OnApprove
{
    using SafeMath for uint256;

    event Upgraded(address indexed implementation);

    /// @dev event on staking TON
    /// @param to the sender
    /// @param amount the amount of staking
    event Staked(address indexed to, uint256 amount);

    /// @dev the constructor of StakeTONProxy
    /// @param _logic the logic address of StakeTONProxy
    constructor(address _logic) {
        assert(
            IMPLEMENTATION_SLOT ==
                bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1)
        );

        require(_logic != address(0), "StakeTONProxy: logic is zero");

        _setImplementation(_logic);

        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, address(this));
    }

    /// @notice Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external onlyOwner {
        pauseProxy = _pause;
    }

    /// @notice Set implementation contract
    /// @param impl New implementation contract address
    function upgradeTo(address impl) external onlyOwner {
        require(impl != address(0), "StakeTONProxy: input is zero");
        require(
            _implementation() != impl,
            "StakeTONProxy: The input address is same as the state"
        );
        _setImplementation(impl);
        emit Upgraded(impl);
    }

    /// @dev returns the implementation
    function implementation() public view returns (address) {
        return _implementation();
    }

    /// @dev receive ether
    receive() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    fallback() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    function _fallback() internal {
        address _impl = _implementation();
        require(
            _impl != address(0) && !pauseProxy,
            "StakeTONProxy: impl is zero OR proxy is false"
        );

        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }

    /// @dev Approves function
    /// @dev call by WTON
    /// @param owner  who actually calls
    /// @param spender  Who gives permission to use
    /// @param tonAmount  how much will be available
    /// @param data  Amount data to use with users
    function onApprove(
        address owner,
        address spender,
        uint256 tonAmount,
        bytes calldata data
    ) external override returns (bool) {
        (address _spender, uint256 _amount) = _decodeStakeData(data);
        require(
            tonAmount == _amount && spender == _spender,
            "StakeTONProxy: tonAmount != stakingAmount "
        );
        require(
            stakeOnApprove(msg.sender, owner, _spender, _amount),
            "StakeTONProxy: stakeOnApprove fails "
        );
        return true;
    }

    function _decodeStakeData(bytes calldata input)
        internal
        pure
        returns (address spender, uint256 amount)
    {
        (spender, amount) = abi.decode(input, (address, uint256));
    }

    /// @dev stake with WTON
    /// @param from  WTON
    /// @param _owner  who actually calls
    /// @param _spender  Who gives permission to use
    /// @param _amount  how much will be available
    function stakeOnApprove(
        address from,
        address _owner,
        address _spender,
        uint256 _amount
    ) public returns (bool) {
        require(
            (paytoken == from && _amount > 0 && _spender == address(this)),
            "StakeTONProxy: stakeOnApprove init fail"
        );
        require(
            block.number >= saleStartBlock && block.number < startBlock,
            "StakeTONProxy: period not allowed"
        );

        require(
            !IStakeVaultStorage(vault).saleClosed(),
            "StakeTONProxy: end sale"
        );
        require(
            IIERC20(paytoken).balanceOf(_owner) >= _amount,
            "StakeTONProxy: insuffient"
        );

        LibTokenStake1.StakedAmount storage staked = userStaked[_owner];
        if (staked.amount == 0) totalStakers = totalStakers.add(1);

        staked.amount = staked.amount.add(_amount);
        totalStakedAmount = totalStakedAmount.add(_amount);
        require(
            IIERC20(from).transferFrom(_owner, _spender, _amount),
            "StakeTONProxy: transfer fail"
        );

        emit Staked(_owner, _amount);
        return true;
    }

    /// @dev set initial storage
    /// @param _addr the array addresses of token, paytoken, vault, defiAddress
    /// @param _registry the registry address
    /// @param _intdata the array valued of saleStartBlock, stakeStartBlock, periodBlocks
    function setInit(
        address[4] memory _addr,
        address _registry,
        uint256[3] memory _intdata
    ) external onlyOwner {
        require(token == address(0), "StakeTONProxy: already initialized");

        require(
            _registry != address(0) &&
                _addr[2] != address(0) &&
                _intdata[0] < _intdata[1],
            "StakeTONProxy: setInit fail"
        );
        token = _addr[0];
        paytoken = _addr[1];
        vault = _addr[2];
        defiAddr = _addr[3];

        stakeRegistry = _registry;

        tokamakLayer2 = address(0);

        saleStartBlock = _intdata[0];
        startBlock = _intdata[1];
        endBlock = startBlock.add(_intdata[2]);
    }
}


// File contracts/factory/StakeTONProxyFactory.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;



/// @title A factory that creates a stakeTONProxy
contract StakeTONProxyFactory is AccessRoleCommon, IStakeTONProxyFactory {
    /// @dev Create a StakeTONProxy that can stake TON.
    /// @param _logic the logic contract address used in proxy
    /// @param _addr the array of [token, paytoken, vault, defiAddr]
    /// @param _registry the registry address
    /// @param _intdata the array of [saleStartBlock, startBlock, periodBlocks]
    /// @param owner  owner address
    /// @return contract address
    function deploy(
        address _logic,
        address[4] calldata _addr,
        address _registry,
        uint256[3] calldata _intdata,
        address owner
    ) external override returns (address) {
        StakeTONProxy proxy = new StakeTONProxy(_logic);

        require(
            address(proxy) != address(0),
            "StakeTONProxyFactory: proxy zero"
        );

        proxy.setInit(_addr, _registry, _intdata);

        proxy.grantRole(ADMIN_ROLE, owner);
        proxy.revokeRole(ADMIN_ROLE, address(this));

        return address(proxy);
    }
}


// File contracts/interfaces/IStakeUniswapV3Factory.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStakeUniswapV3Factory {
    /// @dev Create a stake contract that can operate the staked amount as a DeFi project.
    /// @param _addr array of [token, paytoken, vault]
    /// @param _registry  registry address
    /// @param _intdata array of [saleStartBlock, startBlock, periodBlocks]
    /// @param owner  owner address
    /// @return contract address
    function create(
        address[4] calldata _addr,
        address _registry,
        uint256[3] calldata _intdata,
        address owner
    ) external returns (address);
}


// File contracts/interfaces/IStakeRegistry.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStakeRegistry {
    /// @dev Set addresses for Tokamak integration
    /// @param _ton TON address
    /// @param _wton WTON address
    /// @param _depositManager DepositManager address
    /// @param _seigManager SeigManager address
    /// @param _swapProxy Proxy address that can swap TON and WTON
    function setTokamak(
        address _ton,
        address _wton,
        address _depositManager,
        address _seigManager,
        address _swapProxy
    ) external;

    /// @dev Add information related to Defi
    /// @param _name name . ex) UNISWAP_V3
    /// @param _router entry point of defi
    /// @param _ex1  additional variable . ex) positionManagerAddress in Uniswap V3
    /// @param _ex2  additional variable . ex) WETH Address in Uniswap V3
    /// @param _fee  fee
    /// @param _routerV2 In case of uniswap, router address of uniswapV2
    function addDefiInfo(
        string calldata _name,
        address _router,
        address _ex1,
        address _ex2,
        uint256 _fee,
        address _routerV2
    ) external;

    /// @dev Add Vault
    /// @dev It is excuted by proxy
    /// @param _vault vault address
    /// @param _phase phase ex) 1,2,3
    /// @param _vaultName  hash of vault's name
    function addVault(
        address _vault,
        uint256 _phase,
        bytes32 _vaultName
    ) external;

    /// @dev Add StakeContract in vault
    /// @dev It is excuted by proxy
    /// @param _vault vault address
    /// @param _stakeContract  StakeContract address
    function addStakeContract(address _vault, address _stakeContract) external;

    /// @dev Get addresses for Tokamak interface
    /// @return (ton, wton, depositManager, seigManager)
    function getTokamak()
        external
        view
        returns (
            address,
            address,
            address,
            address,
            address
        );

    /// @dev Get indos for UNISWAP_V3 interface
    /// @return (uniswapRouter, npm, wethAddress, fee)
    function getUniswap()
        external
        view
        returns (
            address,
            address,
            address,
            uint256,
            address
        );

    /// @dev Checks if a vault is withing the given phase
    /// @param _phase the phase number
    /// @param _vault the vault's address
    /// @return valid true or false
    function validVault(uint256 _phase, address _vault)
        external
        view
        returns (bool valid);

    function phasesAll(uint256 _index) external view returns (address[] memory);

    function stakeContractsOfVaultAll(address _vault)
        external
        view
        returns (address[] memory);

    /// @dev view defi info
    /// @param _name  hash name : keccak256(abi.encodePacked(_name));
    /// @return name  _name ex) UNISWAP_V3, UNISWAP_V3_token0_token1
    /// @return router entry point of defi
    /// @return ext1  additional variable . ex) positionManagerAddress in Uniswap V3
    /// @return ext2  additional variable . ex) WETH Address in Uniswap V3
    /// @return fee  fee
    /// @return routerV2 In case of uniswap, router address of uniswapV2

    function defiInfo(bytes32 _name)
        external
        returns (
            string calldata name,
            address router,
            address ext1,
            address ext2,
            uint256 fee,
            address routerV2
        );
}


// File contracts/interfaces/IStakeUniswapV3Proxy.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStakeUniswapV3Proxy {
    /// @dev Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external;

    /// @dev Set implementation contract
    /// @param impl New implementation contract address
    function upgradeTo(address impl) external;

    /// @dev view implementation address
    /// @return the logic address
    function implementation() external view returns (address);

    /// @dev set initial storage
    /// @param _addr  [tos, vault,  ,   ]
    /// @param _registry teh registry address
    /// @param _intdata [cap, rewardPerBlock, 0]
    function setInit(
        address[4] memory _addr,
        address _registry,
        uint256[3] memory _intdata
    ) external;

    function deployCoinage() external;

    function setPool(address[4] memory uniswapInfo) external;
}


// File contracts/stake/CoinageFactorySLOT.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

abstract contract CoinageFactorySLOT {
    // bytes32(uint256(keccak256('eip1967.proxy.coinagefactory')) ))
    bytes32 internal constant COINAGEFACTORY_SLOT =
        0xc7786c8b03ed9d3280cb3993e8a3aa05e40c849d7d1560c7764528bab63ba0ea;

    /// @dev Sets the implementation address of the proxy.
    /// @param newAddress Address of the new coinageFactory.
    function _setCoinageFactory(address newAddress) internal {
        require(
            Address.isContract(newAddress),
            "CoinageFactorySLOT: Cannot set a proxy coinage factory to a non-contract address"
        );

        bytes32 slot = COINAGEFACTORY_SLOT;

        assembly {
            sstore(slot, newAddress)
        }
    }

    function _coinageFactory() internal view returns (address cf) {
        bytes32 slot = COINAGEFACTORY_SLOT;
        assembly {
            cf := sload(slot)
        }
    }
}


// File contracts/libraries/LibUniswapV3Stake.sol

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

library LibUniswapV3Stake {
    struct StakeLiquidity {
        address owner;
        uint256 idIndex;
        uint128 liquidity;
        int24 tickLower;
        int24 tickUpper;
        uint32 startTime;
        uint32 claimedTime;
        uint160 secondsInsideInitial;
        uint160 secondsInsideLast;
        bool claimLock;
        bool withdraw;
    }

    struct StakedTokenAmount {
        uint256 amount;
        uint32 startTime;
        uint32 claimedTime;
        uint256 claimedAmount;
        uint256 nonMiningAmount;
    }

    struct StakedTotalTokenAmount {
        bool staked;
        uint256 totalDepositAmount;
        uint256 totalMiningAmount;
        uint256 totalNonMiningAmount;
    }
}


// File contracts/stake/StakeUniswapV3Storage.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;


/// @title The base storage of stakeContract
contract StakeUniswapV3Storage {
    /// @dev reward token : TOS
    address public token;

    /// @dev registry
    address public stakeRegistry;

    /// @dev A vault that holds tos rewards.
    address public vault;

    /// @dev the total minied amount
    uint256 public miningAmountTotal;

    /// @dev Rewards have been allocated,
    ///      but liquidity is lost, and burned amount .
    uint256 public nonMiningAmountTotal;

    /// @dev the total staked amount
    uint256 public totalStakedAmount;

    /// @dev user's tokenIds
    mapping(address => uint256[]) public userStakedTokenIds;

    /// @dev  Deposited token ID information
    mapping(uint256 => LibUniswapV3Stake.StakeLiquidity) public depositTokens;

    /// @dev Amount that Token ID put into Coinage
    mapping(uint256 => LibUniswapV3Stake.StakedTokenAmount)
        public stakedCoinageTokens;

    /// @dev Total staked information of users
    mapping(address => LibUniswapV3Stake.StakedTotalTokenAmount)
        public userTotalStaked;

    /// @dev total stakers
    uint256 public totalStakers;

    /// @dev lock
    uint256 internal _lock;

    /// @dev flag for pause proxy
    bool public pauseProxy;

    /// @dev stakeStartTime is set when staking for the first time
    uint256 public stakeStartTime;

    /// @dev saleStartTime
    uint256 public saleStartTime;

    /// @dev Mining interval can be given to save gas cost.
    uint256 public miningIntervalSeconds;

    /// @dev pools's token
    address public poolToken0;
    address public poolToken1;
    address public poolAddress;
    uint256 public poolFee;

    /// @dev Rewards per second liquidity inside (3년간 8000000 TOS)
    /// uint256 internal MINING_PER_SECOND = 84559445290038900;

    /// @dev UniswapV3 Nonfungible position manager
    INonfungiblePositionManager public nonfungiblePositionManager;

    /// @dev UniswapV3 pool factory
    address public uniswapV3FactoryAddress;

    /// @dev coinage for reward 리워드 계산을 위한 코인에이지
    address public coinage;

    /// @dev  recently mined time (in seconds)
    uint256 public coinageLastMintBlockTimetamp;

    /// @dev total tokenIds
    uint256 public totalTokens;

    ///@dev for migrate L2
    bool public migratedL2;

    modifier nonZeroAddress(address _addr) {
        require(_addr != address(0), "StakeUniswapV3Storage: zero address");
        _;
    }
    modifier lock() {
        require(_lock == 0, "StakeUniswapV3Storage: LOCKED");
        _lock = 1;
        _;
        _lock = 0;
    }
}


// File contracts/stake/StakeUniswapV3Proxy.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;






/// @title Proxy for stake based coinage contract
contract StakeUniswapV3Proxy is
    StakeUniswapV3Storage,
    AccessibleCommon,
    ProxyBase,
    CoinageFactorySLOT,
    IStakeUniswapV3Proxy
{
    event Upgraded(address indexed implementation);
    event SetCoinageFactory(address indexed coinageFactory);

    /// @dev constructor of Stake1Proxy
    /// @param _logic the logic address that used in proxy
    constructor(address _logic, address _coinageFactory) {
        assert(
            IMPLEMENTATION_SLOT ==
                bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1)
        );

        require(_logic != address(0), "StakeUniswapV3Proxy: logic is zero");

        _setImplementation(_logic);
        _setCoinageFactory(_coinageFactory);

        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, address(this));
    }

    /// @dev Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external override onlyOwner {
        pauseProxy = _pause;
    }

    /// @dev Set implementation contract
    /// @param impl New implementation contract address
    function upgradeTo(address impl) external override onlyOwner {
        require(impl != address(0), "StakeUniswapV3Proxy: impl is zero");
        require(_implementation() != impl, "same");
        _setImplementation(impl);
        emit Upgraded(impl);
    }

    /// @dev returns the implementation
    function implementation() public view override returns (address) {
        return _implementation();
    }

    function setCoinageFactory(address _newCoinageFactory) external onlyOwner {
        _setCoinageFactory(_newCoinageFactory);
        emit SetCoinageFactory(_newCoinageFactory);
    }

    /// @dev receive ether
    receive() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    fallback() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    function _fallback() internal {
        address _impl = implementation();
        require(
            _impl != address(0) && !pauseProxy,
            "StakeUniswapV3Proxy: impl is zero OR proxy is false"
        );

        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }

    /// @dev set initial storage
    /// @param _addr  [tos, 0, vault,  ,   ]
    /// @param _registry teh registry address
    /// @param _intdata [cap, rewardPerBlock, 0]
    function setInit(
        address[4] memory _addr,
        address _registry,
        uint256[3] memory _intdata
    ) external override onlyOwner {
        require(
            token == address(0),
            "StakeUniswapV3Proxy: already initialized"
        );
        require(_addr[0] != address(0), "StakeUniswapV3Proxy: setInit fail");
        token = _addr[0];
        vault = _addr[2];

        stakeRegistry = _registry;
    }

    function deployCoinage() external override onlyOwner {
        require(
            coinage == address(0),
            "StakeUniswapV3Proxy: alerady set coinage"
        );
        require(
            _coinageFactory() != address(0),
            "StakeUniswapV3Proxy: _coinageFactory is zero"
        );
        coinage = IStakeCoinageFactory(_coinageFactory()).deploy(address(this));

        require(
            coinage != address(0),
            "StakeUniswapV3Proxy: deployed coinage is zero"
        );
    }

    /// @dev set pool information
    /// @param uniswapInfo [NonfungiblePositionManager,UniswapV3Factory,token0,token1]
    function setPool(address[4] memory uniswapInfo)
        external
        override
        onlyOwner
        nonZeroAddress(uniswapInfo[0])
        nonZeroAddress(uniswapInfo[1])
        nonZeroAddress(uniswapInfo[2])
        nonZeroAddress(uniswapInfo[3])
    {
        nonfungiblePositionManager = INonfungiblePositionManager(
            uniswapInfo[0]
        );
        uniswapV3FactoryAddress = uniswapInfo[1];
        poolToken0 = uniswapInfo[2];
        poolToken1 = uniswapInfo[3];
    }
}


// File contracts/factory/StakeUniswapV3Factory.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;



/// @title A factory that creates a stake contract that can function as a DeFi function
contract StakeUniswapV3Factory is AccessRoleCommon, IStakeUniswapV3Factory {
    address public stakeUniswapV3Logic;
    address public coinageFactory;

    /// @dev constructor of StakeCoinageFactory
    /// @param _stakeUniswapV3Logic the logic address used in stakeUniswapV3
    /// @param _coinageFactory the _coinage factory address
    constructor(address _stakeUniswapV3Logic, address _coinageFactory) {
        require(
            _stakeUniswapV3Logic != address(0) && _coinageFactory != address(0),
            "StakeUniswapV3Factory: logic zero"
        );
        stakeUniswapV3Logic = _stakeUniswapV3Logic;
        coinageFactory = _coinageFactory;
    }

    /// @dev Create a stake contract that can operate the staked amount as a DeFi project.
    /// @param _addr array of [tos, 0, vault, 0 ]
    /// @param _registry  registry address
    /// @param _intdata array of [cap, rewardPerBlock, 0]
    /// @param owner  owner address
    /// @return contract address
    function create(
        address[4] calldata _addr,
        address _registry,
        uint256[3] calldata _intdata,
        address owner
    ) external override returns (address) {
        StakeUniswapV3Proxy proxy =
            new StakeUniswapV3Proxy(stakeUniswapV3Logic, coinageFactory);
        require(
            address(proxy) != address(0),
            "StakeUniswapV3Factory: proxy zero"
        );

        proxy.setInit(_addr, _registry, _intdata);
        proxy.deployCoinage();

        proxy.grantRole(ADMIN_ROLE, owner);
        proxy.revokeRole(ADMIN_ROLE, address(this));

        return address(proxy);
    }
}


// File contracts/interfaces/IStakeVaultFactory.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStakeVaultFactory {
    /// @dev Create a vault that hold reward, _cap is allocated reward amount.
    /// @param _phase phase number
    /// @param _addr the array of [token, paytoken, vault, defiAddr]
    /// @param _intInfo array of [_stakeType, _cap, _saleStartBlock, _stakeStartBlock]
    /// @param owner the owner adderess
    /// @return a vault address
    function create(
        uint256 _phase,
        address[4] calldata _addr,
        uint256[4] calldata _intInfo,
        address owner
    ) external returns (address);

    /// @dev Create a vault that hold reward, _cap is allocated reward amount.
    /// @param _phase phase number
    /// @param _addr the array of [tos, _stakefactory]
    /// @param _intInfo array of [_stakeType, _cap, _rewardPerBlock ]
    /// @param _name the name of stake contract
    /// @param owner the owner adderess
    /// @return a vault address
    function create2(
        uint256 _phase,
        address[2] calldata _addr,
        uint256[3] calldata _intInfo,
        string memory _name,
        address owner
    ) external returns (address);

    /// @dev Set stakeVaultLogic address by _phase
    /// @param _phase the stake type
    /// @param _logic the vault logic address
    function setVaultLogicByPhase(uint256 _phase, address _logic) external;
}


// File contracts/interfaces/IStake2VaultProxy.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStake2VaultProxy {
    /// @dev Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external;

    /// @dev Set implementation contract
    /// @param impl New implementation contract address
    function upgradeTo(address impl) external;

    /// @dev view implementation address
    /// @return the logic address
    function implementation() external view returns (address);

    /// @dev set initial storage
    /// @param _tos  TOS token address
    /// @param _stakefactory the factory address to create stakeContract
    /// @param _stakeType  Type of staking contract, 0 TON staking, 1 basic ERC20 staking, 2 UniswapV3  staking
    /// @param _cap  Maximum amount of rewards issued, allocated reward amount.
    /// @param _rewardPerBlock  the reward per block
    /// @param _name  the name of stake contratc
    function initialize(
        address _tos,
        address _stakefactory,
        uint256 _stakeType,
        uint256 _cap,
        uint256 _rewardPerBlock,
        string memory _name
    ) external;
}


// File contracts/stake/Stake2VaultStorage.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

//import "../interfaces/IStake2VaultStorage.sol";

/// @title the storage of StakeVaultStorage
contract Stake2VaultStorage is AccessibleCommon {
    /// @dev reward token : TOS
    address public tos;

    /// @dev name
    string public name;

    /// @dev allocated amount of tos
    uint256 public cap;

    /// @dev mining start time
    uint256 public miningStartTime;

    /// @dev mining end time
    uint256 public miningEndTime;

    /// @dev mining amount per second
    uint256 public miningPerSecond;

    /// @dev Operation type of staking
    uint256 public stakeType;

    /// @dev a stakeContract maintained by the vault
    address public stakeAddress;

    /// @dev the total amount transfered to miner
    uint256 public miningAmountTotal;

    /// @dev Rewards have been allocated,
    ///      but liquidity is lost, and burned amount .
    uint256 public nonMiningAmountTotal;

    /// @dev the total mined amount
    uint256 public totalMinedAmount;

    uint256 private _lock;

    /// @dev flag for pause proxy
    bool public pauseProxy;

    ///@dev for migrate L2
    bool public migratedL2;

    modifier lock() {
        require(_lock == 0, "Stake2VaultStorage: LOCKED");
        _lock = 1;
        _;
        _lock = 0;
    }

    modifier nonZeroAddress(address _addr) {
        require(_addr != address(0), "Stake2VaultStorage: zero address");
        _;
    }
    modifier nonZero(uint256 _value) {
        require(_value > 0, "Stake2VaultStorage: zero value");
        _;
    }
}


// File contracts/stake/Stake2VaultProxy.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;



/// @title Proxy for StakeVault
/// @notice
contract Stake2VaultProxy is Stake2VaultStorage, ProxyBase, IStake2VaultProxy {
    event Upgraded(address indexed implementation);

    /// @dev constructor of StakeVaultProxy
    /// @param impl the logic address of StakeVaultProxy
    constructor(address impl) {
        assert(
            IMPLEMENTATION_SLOT ==
                bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1)
        );

        require(impl != address(0), "Stake2VaultProxy: logic is zero");

        _setImplementation(impl);

        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    /// @notice Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external override onlyOwner {
        pauseProxy = _pause;
    }

    /// @notice Set implementation contract
    /// @param impl New implementation contract address
    function upgradeTo(address impl) external override onlyOwner {
        require(impl != address(0), "Stake2VaultProxy: input is zero");
        require(_implementation() != impl, "Stake2VaultProxy: same");
        _setImplementation(impl);
        emit Upgraded(impl);
    }

    /// @dev returns the implementation
    function implementation() public view override returns (address) {
        return _implementation();
    }

    /// @dev receive ether
    receive() external payable {
        revert("cannot receive Ether");
    }

    /// @dev fallback function , execute on undefined function call
    fallback() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    function _fallback() internal {
        address _impl = _implementation();
        require(
            _impl != address(0) && !pauseProxy,
            "Stake2VaultProxy: impl OR proxy is false"
        );

        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }

    /// @dev set initial storage
    /// @param _tos  TOS token address
    /// @param _stakefactory the factory address to create stakeContract
    /// @param _stakeType  Type of staking contract, 0 TON staking, 1 basic ERC20 staking, 2 UniswapV3  staking
    /// @param _cap  Maximum amount of rewards issued, allocated reward amount.
    /// @param _miningPerSecond  the mining amount per second
    function initialize(
        address _tos,
        address _stakefactory,
        uint256 _stakeType,
        uint256 _cap,
        uint256 _miningPerSecond,
        string memory _name
    ) external override onlyOwner {
        require(tos == address(0), "Stake2VaultProxy: already initialized");

        require(
            _tos != address(0) && _stakefactory != address(0),
            "Stake2VaultProxy: input is zero"
        );
        require(_cap > 0, "Stake1Vault: _cap is zero");

        tos = _tos;
        cap = _cap;
        stakeType = _stakeType;
        miningPerSecond = _miningPerSecond;
        name = _name;
        grantRole(ADMIN_ROLE, _stakefactory);
    }
}


// File contracts/interfaces/IStakeVaultProxy.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStakeVaultProxy {
    /// @dev Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external;

    /// @dev Set implementation contract
    /// @param impl New implementation contract address
    function upgradeTo(address impl) external;

    /// @dev view implementation address
    /// @return the logic address
    function implementation() external view returns (address);

    /// @dev set initial storage
    /// @param _tos  TOS token address
    /// @param _paytoken  Tokens staked by users, can be used as ERC20 tokens.
    //                     (In case of ETH, input address(0))
    /// @param _cap  Maximum amount of rewards issued, allocated reward amount.
    /// @param _saleStartBlock  the sale start block
    /// @param _stakeStartBlock  the staking start block
    /// @param _stakefactory the factory address to create stakeContract
    /// @param _stakeType  Type of staking contract, 0 TON staking, 1 basic ERC20 staking, 2 Defi linked staking
    /// @param _defiAddr Used when an external address is required. default: address(0)
    function initialize(
        address _tos,
        address _paytoken,
        uint256 _cap,
        uint256 _saleStartBlock,
        uint256 _stakeStartBlock,
        address _stakefactory,
        uint256 _stakeType,
        address _defiAddr
    ) external;
}


// File contracts/stake/StakeVaultStorage.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

//import "../interfaces/IStakeVaultStorage.sol";


/// @title the storage of StakeVaultStorage
contract StakeVaultStorage is AccessibleCommon {
    /// @dev reward token : TOS
    address public tos;

    /// @dev paytoken is the token that the user stakes.
    address public paytoken;

    /// @dev allocated amount of tos
    uint256 public cap;

    /// @dev the start block for sale.
    uint256 public saleStartBlock;

    /// @dev the staking start block
    uint256 public stakeStartBlock;

    /// @dev the staking end block.
    uint256 public stakeEndBlock;

    /// @dev the staking real end block.
    uint256 public realEndBlock;

    /// @dev reward amount per block
    uint256 public blockTotalReward;

    /// @dev sale closed flag
    bool public saleClosed;

    /// @dev Operation type of staking amount
    uint256 public stakeType;

    /// @dev External contract address used when operating the staking amount
    address public defiAddr;

    /// @dev a list of stakeContracts maintained by the vault
    address[] public stakeAddresses;

    /// @dev the information of the stake contract
    mapping(address => LibTokenStake1.StakeInfo) public stakeInfos;

    /// @dev the end blocks of the stake contracts, which must be in ascending order
    uint256[] public orderedEndBlocks;

    /// @dev the total staked amount stored at orderedEndBlock’s end block time
    mapping(uint256 => uint256) public stakeEndBlockTotal;

    uint256 private _lock;

    /// @dev flag for pause proxy
    bool public pauseProxy;

    ///@dev for migrate L2
    bool public migratedL2;

    modifier lock() {
        require(_lock == 0, "Stake1Vault: LOCKED");
        _lock = 1;
        _;
        _lock = 0;
    }
}


// File contracts/stake/StakeVaultProxy.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;



/// @title Proxy for StakeVault
/// @notice
contract StakeVaultProxy is StakeVaultStorage, ProxyBase, IStakeVaultProxy {
    event Upgraded(address indexed implementation);

    /// @dev constructor of StakeVaultProxy
    /// @param impl the logic address of StakeVaultProxy
    constructor(address impl) {
        assert(
            IMPLEMENTATION_SLOT ==
                bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1)
        );

        require(impl != address(0), "Stake1Proxy: logic is zero");

        _setImplementation(impl);

        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, address(this));
    }

    /// @notice Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external override onlyOwner {
        pauseProxy = _pause;
    }

    /// @notice Set implementation contract
    /// @param impl New implementation contract address
    function upgradeTo(address impl) external override onlyOwner {
        require(impl != address(0), "StakeVaultProxy: input is zero");
        require(_implementation() != impl, "StakeVaultProxy: same");
        _setImplementation(impl);
        emit Upgraded(impl);
    }

    /// @dev returns the implementation
    function implementation() public view override returns (address) {
        return _implementation();
    }

    /// @dev receive ether
    receive() external payable {
        revert("cannot receive Ether");
    }

    /// @dev fallback function , execute on undefined function call
    fallback() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    function _fallback() internal {
        address _impl = _implementation();
        require(
            _impl != address(0) && !pauseProxy,
            "StakeVaultProxy: impl OR proxy is false"
        );

        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }

    /// @dev set initial storage
    /// @param _tos  TOS token address
    /// @param _paytoken  Tokens staked by users, can be used as ERC20 tokens.
    //                     (In case of ETH, input address(0))
    /// @param _cap  Maximum amount of rewards issued, allocated reward amount.
    /// @param _saleStartBlock  the sale start block
    /// @param _stakeStartBlock  the staking start block
    /// @param _stakefactory the factory address to create stakeContract
    /// @param _stakeType  Type of staking contract, 0 TON staking, 1 basic ERC20 staking, 2 Defi linked staking
    /// @param _defiAddr Used when an external address is required. default: address(0)
    function initialize(
        address _tos,
        address _paytoken,
        uint256 _cap,
        uint256 _saleStartBlock,
        uint256 _stakeStartBlock,
        address _stakefactory,
        uint256 _stakeType,
        address _defiAddr
    ) external override onlyOwner {
        require(tos == address(0), "StakeVaultProxy: already initialized");

        require(
            _tos != address(0) && _stakefactory != address(0),
            "StakeVaultProxy: input is zero"
        );
        require(_cap > 0, "Stake1Vault: _cap is zero");
        require(
            _saleStartBlock < _stakeStartBlock && _stakeStartBlock > 0,
            "StakeVaultProxy: startBlock is unavailable"
        );

        tos = _tos;
        cap = _cap;
        paytoken = _paytoken;
        saleStartBlock = _saleStartBlock;
        stakeStartBlock = _stakeStartBlock;
        stakeType = _stakeType;
        defiAddr = _defiAddr;

        grantRole(ADMIN_ROLE, _stakefactory);
    }
}


// File contracts/factory/StakeVaultFactory.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;




//import "hardhat/console.sol";

/// @title A factory that creates a vault that hold reward
contract StakeVaultFactory is AccessibleCommon, IStakeVaultFactory {
    mapping(uint256 => address) public vaultLogics;

    modifier nonZero(address _addr) {
        require(_addr != address(0), "StakeVaultFactory: zero");
        _;
    }

    /// @dev constructor of StakeVaultFactory
    /// @param _stakeVaultLogic the logic address used in StakeVault
    constructor(address _stakeVaultLogic) {
        require(
            _stakeVaultLogic != address(0),
            "StakeVaultFactory: logic zero"
        );
        vaultLogics[1] = _stakeVaultLogic;

        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    /// @dev Set stakeVaultLogic address by _phase
    /// @param _phase the stake type
    /// @param _logic the vault logic address
    function setVaultLogicByPhase(uint256 _phase, address _logic)
        external
        override
        onlyOwner
        nonZero(_logic)
    {
        vaultLogics[_phase] = _logic;
    }

    /// @dev Create a vault that hold reward, _cap is allocated reward amount.
    /// @param _phase phase number
    /// @param _addr the array of [token, paytoken, _stakefactory, defiAddr]
    /// @param _intInfo array of [_stakeType, _cap, _saleStartBlock, _stakeStartBlock]
    /// @param owner the owner adderess
    /// @return a vault address
    function create(
        uint256 _phase,
        address[4] calldata _addr,
        uint256[4] calldata _intInfo,
        address owner
    ) external override returns (address) {
        require(
            vaultLogics[_phase] != address(0),
            "StakeVaultFactory: zero vault logic "
        );
        address _tos = _addr[0];
        address _paytoken = _addr[1];
        address _stakefactory = _addr[2];
        address _defiAddr = _addr[3];
        uint256 _stakeType = _intInfo[0];
        uint256 _cap = _intInfo[1];
        uint256 _saleStartBlock = _intInfo[2];
        uint256 _stakeStartBlock = _intInfo[3];

        StakeVaultProxy proxy = new StakeVaultProxy(vaultLogics[_phase]);
        require(address(proxy) != address(0), "StakeVaultFactory: proxy zero");

        proxy.initialize(
            _tos,
            _paytoken,
            _cap,
            _saleStartBlock,
            _stakeStartBlock,
            _stakefactory,
            _stakeType,
            _defiAddr
        );

        proxy.grantRole(ADMIN_ROLE, owner);
        proxy.revokeRole(ADMIN_ROLE, address(this));

        return address(proxy);
    }

    /// @dev Create a vault that hold reward, _cap is allocated reward amount.
    /// @param _phase phase number
    /// @param _addr the array of [tos, _stakefactory]
    /// @param _intInfo array of [_stakeType, _cap, _rewardPerBlock ]
    /// @param owner the owner adderess
    /// @return a vault address
    function create2(
        uint256 _phase,
        address[2] calldata _addr,
        uint256[3] calldata _intInfo,
        string memory _name,
        address owner
    ) external override returns (address) {
        require(
            vaultLogics[_phase] != address(0),
            "StakeVaultFactory: zero vault2 logic "
        );
        address _tos = _addr[0];
        address _stakefactory = _addr[1];
        uint256 _stakeType = _intInfo[0];
        uint256 _cap = _intInfo[1];
        uint256 _rewardPerBlock = _intInfo[2];

        //console.log("create2 %s", vaultLogics[_phase] );

        Stake2VaultProxy proxy = new Stake2VaultProxy(vaultLogics[_phase]);
        require(
            address(proxy) != address(0),
            "StakeVaultFactory: Stake2VaultProxy zero"
        );

        proxy.initialize(
            _tos,
            _stakefactory,
            _stakeType,
            _cap,
            _rewardPerBlock,
            _name
        );

        proxy.grantRole(ADMIN_ROLE, owner);
        proxy.revokeRole(ADMIN_ROLE, address(this));

        return address(proxy);
    }
}


// File contracts/interfaces/ILockTOSv2Action0.sol

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;
pragma abicoder v2;

interface ILockTOSv2Action0 {

    /// @dev Returns addresses of all holders of LockTOS
    function allHolders() external returns (address[] memory);

    /// @dev Returns addresses of active holders of LockTOS
    function activeHolders() external returns (address[] memory);

    /// @dev Returns all withdrawable locks
    function withdrawableLocksOf(address user) external view returns (uint256[] memory);

    /// @dev Returns all locks of `_addr`
    function locksOf(address _addr) external view returns (uint256[] memory);

    /// @dev Returns all locks of `_addr`
    function activeLocksOf(address _addr) external view returns (uint256[] memory);

    /// @dev Total locked amount of `_addr`
    function totalLockedAmountOf(address _addr) external view returns (uint256);

    /// @dev     jhswuqhdiuwjhdoiehdoijijf   bhabcgfzvg tqafstqfzys amount of `_addr`
    function withdrawableAmountOf(address _addr) external view returns (uint256);

    /// @dev Returns all locks of `_addr`
    function locksInfo(uint256 _lockId)
        external
        view
        returns (
            uint256,
            uint256,
            uint256
        );

    /// @dev Returns all history of `_addr`
    function pointHistoryOf(uint256 _lockId)
        external
        view
        returns (LibLockTOS.Point[] memory);

    /// @dev Total vote weight
    function totalSupply() external view returns (uint256);

    /// @dev Total vote weight at `_timestamp`
    function totalSupplyAt(uint256 _timestamp) external view returns (uint256);

    /// @dev Vote weight of lock at `_timestamp`
    function balanceOfLockAt(uint256 _lockId, uint256 _timestamp)
        external
        view
        returns (uint256);

    /// @dev Vote weight of lock
    function balanceOfLock(uint256 _lockId) external view returns (uint256);

    /// @dev Vote weight of a user at `_timestamp`
    function balanceOfAt(address _addr, uint256 _timestamp)
        external
        view
        returns (uint256 balance);

    /// @dev Vote weight of a iser
    function balanceOf(address _addr) external view returns (uint256 balance);

    /// @dev needCheckpoint
    function needCheckpoint() external view returns (bool need);

    /// @dev Global checkpoint
    function globalCheckpoint() external;


    ///=== onlyStaker


    /// @dev Increase amount
    function increaseAmountByStaker(address user, uint256 _lockId, uint256 _value) external;


    /// @dev Deposits value for '_addr'
    function depositFor(
        address _addr,
        uint256 _lockId,
        uint256 _value
    ) external;

    /// @dev Create lock
    function createLockByStaker(address user, uint256 _value, uint256 _unlockTime)
        external
        returns (uint256 lockId);

    /// @dev Increase UnlockTime
    function increaseUnlockTimeByStaker(address user, uint256 _lockId, uint256 unlockTime) external;


    /// @dev Increase amount and UnlockTime
    function increaseAmountUnlockTimeByStaker(address user, uint256 _lockId, uint256 _value, uint256 _unlockWeeks) external;

    /// @dev Withdraw all TOS
    function withdrawAllByStaker(address user) external;

    /// @dev Withdraw TOS
    function withdrawByStaker(address user, uint256 _lockId) external;


    ///=== onlyOwner

    /// @dev transfer Tos To Treasury
    function transferTosToTreasury(address _treasury) external;

    /// @dev set MaxTime
    function setMaxTime(uint256 _maxTime) external;

    /// @dev set Staker
    function setStaker(address _staker) external;
}


// File contracts/interfaces/IStake1Vault.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;
pragma abicoder v2;

interface IStake1Vault {
    /// @dev Sets TOS address
    /// @param _tos  TOS address
    function setTOS(address _tos) external;

    /// @dev Change cap of the vault
    /// @param _cap  allocated reward amount
    function changeCap(uint256 _cap) external;

    /// @dev Set Defi Address
    /// @param _defiAddr DeFi related address
    function setDefiAddr(address _defiAddr) external;

    /// @dev If the vault has more money than the reward to give, the owner can withdraw the remaining amount.
    /// @param _amount the amount of withdrawal
    function withdrawReward(uint256 _amount) external;

    /// @dev  Add stake contract
    /// @param _name stakeContract's name
    /// @param stakeContract stakeContract's address
    /// @param periodBlocks the period that give rewards of stakeContract
    function addSubVaultOfStake(
        string memory _name,
        address stakeContract,
        uint256 periodBlocks
    ) external;

    /// @dev  Close the sale that can stake by user
    function closeSale() external;

    /// @dev claim function.
    /// @dev sender is a staking contract.
    /// @dev A function that pays the amount(_amount) to _to by the staking contract.
    /// @dev A function that _to claim the amount(_amount) from the staking contract and gets the TOS in the vault.
    /// @param _to a user that received reward
    /// @param _amount the receiving amount
    /// @return true
    function claim(address _to, uint256 _amount) external returns (bool);

    /// @dev Whether user(to) can receive a reward amount(_amount)
    /// @param _to  a staking contract.
    /// @param _amount the total reward amount of stakeContract
    /// @return true
    function canClaim(address _to, uint256 _amount)
        external
        view
        returns (bool);

    /// @dev Give the infomation of this vault
    /// @return paytoken, cap, saleStartBlock, stakeStartBlock, stakeEndBlock, blockTotalReward, saleClosed
    function infos()
        external
        view
        returns (
            address[2] memory,
            uint256,
            uint256,
            uint256[3] memory,
            uint256,
            bool
        );

    /// @dev Returns Give the TOS balance stored in the vault
    /// @return the balance of TOS in this vault.
    function balanceTOSAvailableAmount() external view returns (uint256);

    /// @dev Give Total reward amount of stakeContract(_account)
    /// @return Total reward amount of stakeContract(_account)
    function totalRewardAmount(address _account)
        external
        view
        returns (uint256);

    /// @dev Give all stakeContracts's addresses in this vault
    /// @return all stakeContracts's addresses
    function stakeAddressesAll() external view returns (address[] memory);

    /// @dev Give the ordered end blocks of stakeContracts in this vault
    /// @return the ordered end blocks
    function orderedEndBlocksAll() external view returns (uint256[] memory);
}


// File contracts/interfaces/IStakeTON.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;
pragma abicoder v2;

interface IStakeTON {
    /// @dev Stake amount
    /// @param amount  the amount of staked
    //function stake(uint256 amount) external payable;

    /// @dev Claim for reward
    function claim() external;

    /// @dev withdraw
    function withdraw() external;

    /// @dev Returns the amount that can be rewarded
    /// @param account  the account that claimed reward
    /// @param specificBlock the block that claimed reward
    /// @return reward the reward amount that can be taken
    function canRewardAmount(address account, uint256 specificBlock)
        external
        view
        returns (uint256);
}


// File contracts/interfaces/IProxyAction.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;


/// @title IProxyAction
interface IProxyAction {

    /// @dev set the implementation address and status of the proxy[index]
    /// @param newImplementation Address of the new implementation.
    /// @param _index index
    /// @param _alive _alive
    function setImplementation2(
        address newImplementation,
        uint256 _index,
        bool _alive
    ) external;


    /// @dev set alive status of implementation
    /// @param newImplementation Address of the new implementation.
    /// @param _alive alive status
    function setAliveImplementation2(address newImplementation, bool _alive)
        external;


    /// @dev set selectors of Implementation
    /// @param _selectors being added selectors
    /// @param _imp implementation address
    function setSelectorImplementations2(
        bytes4[] calldata _selectors,
        address _imp
    ) external  ;



    /// onlyOwner

    /// @notice Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external ;


    /// anybody

    /// @dev view implementation address of selector of function
    /// @param _selector selector of function
    /// @return impl address of the implementation
    function getSelectorImplementation2(bytes4 _selector)
        external
        view
        returns (address impl);


    /// @dev view implementation address of the proxy[index]
    /// @param _index index of proxy
    /// @return address of the implementation
    function implementation2(uint256 _index) external view returns (address) ;
}


// File contracts/interfaces/IProxyEvent.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;


/// @title IProxyEvent
interface IProxyEvent {

    event Upgraded(address indexed implementation);

    event SetAliveImplementation(address indexed impl, bool alive);
    event SetSelectorImplementation(bytes4 indexed selector, address indexed impl);


}


// File contracts/L2/BaseStorage.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

contract BaseStorage  {
    bool public pauseProxy;

    mapping(uint256 => address) public proxyImplementation;
    mapping(address => bool) public aliveImplementation;
    mapping(bytes4 => address) public selectorImplementation;
}


// File contracts/L2/BaseProxy.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;



contract BaseProxy is BaseStorage, AccessibleCommon, IProxyEvent, IProxyAction
{
    constructor () {
        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    /// @inheritdoc IProxyAction
    function setProxyPause(bool _pause) external override onlyOwner {
        pauseProxy = _pause;
    }

    /// @dev returns the implementation
    function implementation() external view returns (address) {
        return _implementation2(0);
    }

    /// @notice Set implementation contract
    /// @param impl New implementation contract address
    function upgradeTo(address impl) external onlyOwner {
        require(impl != address(0), "input is zero");
        require(
            _implementation2(0) != impl,
            "same addr"
        );
        _setImplementation2(impl, 0, true);
        emit Upgraded(impl);
    }

    /// @inheritdoc IProxyAction
    function implementation2(uint256 _index) external override view returns (address) {
        return _implementation2(_index);
    }

    /// @inheritdoc IProxyAction
    function setImplementation2(
        address newImplementation,
        uint256 _index,
        bool _alive
    ) external override onlyOwner {
        _setImplementation2(newImplementation, _index, _alive);
    }

    /// @inheritdoc IProxyAction
    function setAliveImplementation2(address newImplementation, bool _alive)
        public override
        onlyOwner
    {
        _setAliveImplementation2(newImplementation, _alive);
    }

    /// @inheritdoc IProxyAction
    function setSelectorImplementations2(
        bytes4[] calldata _selectors,
        address _imp
    ) public override onlyOwner {
        require(
            _selectors.length > 0,
            "Proxy: _selectors's size is zero"
        );
        require(aliveImplementation[_imp], "Proxy: _imp is not alive");

        for (uint256 i = 0; i < _selectors.length; i++) {
            require(
                selectorImplementation[_selectors[i]] != _imp,
                "LiquidityVaultProxy: same imp"
            );
            selectorImplementation[_selectors[i]] = _imp;
            emit SetSelectorImplementation(_selectors[i], _imp);
        }
    }

    /// @dev set the implementation address and status of the proxy[index]
    /// @param newImplementation Address of the new implementation.
    /// @param _index index of proxy
    /// @param _alive alive status
    function _setImplementation2(
        address newImplementation,
        uint256 _index,
        bool _alive
    ) internal {
        require(
            Address.isContract(newImplementation),
            "Proxy: not contract address"
        );
        if (_alive) proxyImplementation[_index] = newImplementation;
        _setAliveImplementation2(newImplementation, _alive);
    }

    /// @dev set alive status of implementation
    /// @param newImplementation Address of the new implementation.
    /// @param _alive alive status
    function _setAliveImplementation2(address newImplementation, bool _alive)
        internal
    {
        aliveImplementation[newImplementation] = _alive;
        emit SetAliveImplementation(newImplementation, _alive);
    }

    /// @dev view implementation address of the proxy[index]
    /// @param _index index of proxy
    /// @return impl address of the implementation
    function _implementation2(uint256 _index)
        internal
        view
        returns (address impl)
    {
        return proxyImplementation[_index];
    }

    /// @inheritdoc IProxyAction
    function getSelectorImplementation2(bytes4 _selector)
        public override
        view
        returns (address impl)
    {
        if (selectorImplementation[_selector] == address(0))
            return proxyImplementation[0];
        else if (aliveImplementation[selectorImplementation[_selector]]){
            return selectorImplementation[_selector];
        }
        else return proxyImplementation[0];
    }


    /// @dev receive ether
    receive() external payable {
        revert("cannot receive Ether");
    }

    /// @dev fallback function , execute on undefined function call
    fallback() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    function _fallback() internal {
        address _impl = getSelectorImplementation2(msg.sig);

        require(
            _impl != address(0) && !pauseProxy,
            "Proxy: impl OR proxy is false"
        );

        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }

}


// File contracts/interfaces/ILockTOSL2Proxy.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface ILockTOSL2Proxy {
    /// @dev initialize
    function initialize(
        address _tos,
        uint256 _epochUnit,
        uint256 _maxTime
    ) external;
}


// File contracts/L2/LockTOSStorage.sol

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

contract LockTOSStorage {
    /// @dev registry
    address public stakeRegistry;
    bool public migratedL2;

    uint256 public epochUnit;
    uint256 public maxTime;

    uint256 public constant MULTIPLIER = 1e18;

    address public tos;
    uint256 public lockIdCounter;
    uint256 public cumulativeEpochUnit;
    uint256 public cumulativeTOSAmount;

    uint256 internal free = 1;

    address[] public uniqueUsers;
    LibLockTOS.Point[] public pointHistory;
    mapping(uint256 => LibLockTOS.Point[]) public lockPointHistory;
    mapping(address => mapping(uint256 => LibLockTOS.LockedBalance))
        public lockedBalances;

    mapping(uint256 => LibLockTOS.LockedBalance) public allLocks;
    mapping(address => uint256[]) public userLocks;
    mapping(uint256 => int256) public slopeChanges;
    mapping(uint256 => bool) public inUse;

    bool public lock_;
    address public staker;


    modifier lock() {
        require(lock_ == false, "LockTOSv2Proxy: LOCKED");
        lock_ = true;
        _;
        lock_ = false;
    }


    modifier onlyStaker {
        require(msg.sender == staker, "caller is not staker");
        _;
    }
}


// File contracts/L2/LockTOSL2Proxy.sol

pragma solidity ^0.7.6;



/// @title The proxy of TOS Plaform
/// @notice Admin can createVault, createStakeContract.
/// User can excute the tokamak staking function of each contract through this logic.
contract LockTOSL2Proxy is
    LockTOSStorage,
    BaseProxy,
    ILockTOSL2Proxy
{
    /// @dev Initialize
    function initialize(
        address _tos,
        uint256 _epochUnit,
        uint256 _maxTime
    ) external override onlyOwner {
        require(tos == address(0), "Already initialized");
        lockIdCounter = 0;
        cumulativeEpochUnit = 0;
        cumulativeTOSAmount = 0;

        tos = _tos;
        epochUnit = _epochUnit;
        maxTime = _maxTime;
    }
}


// File @openzeppelin/contracts/math/SignedSafeMath.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @title SignedSafeMath
 * @dev Signed math operations with safety checks that revert on error.
 */
library SignedSafeMath {
    int256 constant private _INT256_MIN = -2**255;

    /**
     * @dev Returns the multiplication of two signed integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(int256 a, int256 b) internal pure returns (int256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        require(!(a == -1 && b == _INT256_MIN), "SignedSafeMath: multiplication overflow");

        int256 c = a * b;
        require(c / a == b, "SignedSafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two signed integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(int256 a, int256 b) internal pure returns (int256) {
        require(b != 0, "SignedSafeMath: division by zero");
        require(!(b == -1 && a == _INT256_MIN), "SignedSafeMath: division overflow");

        int256 c = a / b;

        return c;
    }

    /**
     * @dev Returns the subtraction of two signed integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a - b;
        require((b >= 0 && c <= a) || (b < 0 && c > a), "SignedSafeMath: subtraction overflow");

        return c;
    }

    /**
     * @dev Returns the addition of two signed integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a + b;
        require((b >= 0 && c >= a) || (b < 0 && c < a), "SignedSafeMath: addition overflow");

        return c;
    }
}


// File @openzeppelin/contracts/utils/SafeCast.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;


/**
 * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow
 * checks.
 *
 * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can
 * easily result in undesired exploitation or bugs, since developers usually
 * assume that overflows raise errors. `SafeCast` restores this intuition by
 * reverting the transaction when such an operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 *
 * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing
 * all math on `uint256` and `int256` and then downcasting.
 */
library SafeCast {

    /**
     * @dev Returns the downcasted uint128 from uint256, reverting on
     * overflow (when the input is greater than largest uint128).
     *
     * Counterpart to Solidity's `uint128` operator.
     *
     * Requirements:
     *
     * - input must fit into 128 bits
     */
    function toUint128(uint256 value) internal pure returns (uint128) {
        require(value < 2**128, "SafeCast: value doesn\'t fit in 128 bits");
        return uint128(value);
    }

    /**
     * @dev Returns the downcasted uint64 from uint256, reverting on
     * overflow (when the input is greater than largest uint64).
     *
     * Counterpart to Solidity's `uint64` operator.
     *
     * Requirements:
     *
     * - input must fit into 64 bits
     */
    function toUint64(uint256 value) internal pure returns (uint64) {
        require(value < 2**64, "SafeCast: value doesn\'t fit in 64 bits");
        return uint64(value);
    }

    /**
     * @dev Returns the downcasted uint32 from uint256, reverting on
     * overflow (when the input is greater than largest uint32).
     *
     * Counterpart to Solidity's `uint32` operator.
     *
     * Requirements:
     *
     * - input must fit into 32 bits
     */
    function toUint32(uint256 value) internal pure returns (uint32) {
        require(value < 2**32, "SafeCast: value doesn\'t fit in 32 bits");
        return uint32(value);
    }

    /**
     * @dev Returns the downcasted uint16 from uint256, reverting on
     * overflow (when the input is greater than largest uint16).
     *
     * Counterpart to Solidity's `uint16` operator.
     *
     * Requirements:
     *
     * - input must fit into 16 bits
     */
    function toUint16(uint256 value) internal pure returns (uint16) {
        require(value < 2**16, "SafeCast: value doesn\'t fit in 16 bits");
        return uint16(value);
    }

    /**
     * @dev Returns the downcasted uint8 from uint256, reverting on
     * overflow (when the input is greater than largest uint8).
     *
     * Counterpart to Solidity's `uint8` operator.
     *
     * Requirements:
     *
     * - input must fit into 8 bits.
     */
    function toUint8(uint256 value) internal pure returns (uint8) {
        require(value < 2**8, "SafeCast: value doesn\'t fit in 8 bits");
        return uint8(value);
    }

    /**
     * @dev Converts a signed int256 into an unsigned uint256.
     *
     * Requirements:
     *
     * - input must be greater than or equal to 0.
     */
    function toUint256(int256 value) internal pure returns (uint256) {
        require(value >= 0, "SafeCast: value must be positive");
        return uint256(value);
    }

    /**
     * @dev Returns the downcasted int128 from int256, reverting on
     * overflow (when the input is less than smallest int128 or
     * greater than largest int128).
     *
     * Counterpart to Solidity's `int128` operator.
     *
     * Requirements:
     *
     * - input must fit into 128 bits
     *
     * _Available since v3.1._
     */
    function toInt128(int256 value) internal pure returns (int128) {
        require(value >= -2**127 && value < 2**127, "SafeCast: value doesn\'t fit in 128 bits");
        return int128(value);
    }

    /**
     * @dev Returns the downcasted int64 from int256, reverting on
     * overflow (when the input is less than smallest int64 or
     * greater than largest int64).
     *
     * Counterpart to Solidity's `int64` operator.
     *
     * Requirements:
     *
     * - input must fit into 64 bits
     *
     * _Available since v3.1._
     */
    function toInt64(int256 value) internal pure returns (int64) {
        require(value >= -2**63 && value < 2**63, "SafeCast: value doesn\'t fit in 64 bits");
        return int64(value);
    }

    /**
     * @dev Returns the downcasted int32 from int256, reverting on
     * overflow (when the input is less than smallest int32 or
     * greater than largest int32).
     *
     * Counterpart to Solidity's `int32` operator.
     *
     * Requirements:
     *
     * - input must fit into 32 bits
     *
     * _Available since v3.1._
     */
    function toInt32(int256 value) internal pure returns (int32) {
        require(value >= -2**31 && value < 2**31, "SafeCast: value doesn\'t fit in 32 bits");
        return int32(value);
    }

    /**
     * @dev Returns the downcasted int16 from int256, reverting on
     * overflow (when the input is less than smallest int16 or
     * greater than largest int16).
     *
     * Counterpart to Solidity's `int16` operator.
     *
     * Requirements:
     *
     * - input must fit into 16 bits
     *
     * _Available since v3.1._
     */
    function toInt16(int256 value) internal pure returns (int16) {
        require(value >= -2**15 && value < 2**15, "SafeCast: value doesn\'t fit in 16 bits");
        return int16(value);
    }

    /**
     * @dev Returns the downcasted int8 from int256, reverting on
     * overflow (when the input is less than smallest int8 or
     * greater than largest int8).
     *
     * Counterpart to Solidity's `int8` operator.
     *
     * Requirements:
     *
     * - input must fit into 8 bits.
     *
     * _Available since v3.1._
     */
    function toInt8(int256 value) internal pure returns (int8) {
        require(value >= -2**7 && value < 2**7, "SafeCast: value doesn\'t fit in 8 bits");
        return int8(value);
    }

    /**
     * @dev Converts an unsigned uint256 into a signed int256.
     *
     * Requirements:
     *
     * - input must be less than or equal to maxInt256.
     */
    function toInt256(uint256 value) internal pure returns (int256) {
        require(value < 2**255, "SafeCast: value doesn't fit in an int256");
        return int256(value);
    }
}


// File contracts/interfaces/ITOS.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface ITOS {
    /// @dev Issue a token.
    /// @param to  who takes the issue
    /// @param amount the amount to issue
    function mint(address to, uint256 amount) external returns (bool);

    // @dev burn a token.
    /// @param from Whose tokens are burned
    /// @param amount the amount to burn
    function burn(address from, uint256 amount) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function nonces(address owner) external view returns (uint256);

    /// @dev Authorizes the owner's token to be used by the spender as much as the value.
    /// @dev The signature must have the owner's signature.
    /// @param owner the token's owner
    /// @param spender the account that spend owner's token
    /// @param value the amount to be approve to spend
    /// @param deadline the deadline that valid the owner's signature
    /// @param v the owner's signature - v
    /// @param r the owner's signature - r
    /// @param s the owner's signature - s
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /// @dev verify the signature
    /// @param owner the token's owner
    /// @param spender the account that spend owner's token
    /// @param value the amount to be approve to spend
    /// @param deadline the deadline that valid the owner's signature
    /// @param _nounce the _nounce
    /// @param sigR the owner's signature - r
    /// @param sigS the owner's signature - s
    /// @param sigV the owner's signature - v
    function verify(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint256 _nounce,
        bytes32 sigR,
        bytes32 sigS,
        uint8 sigV
    ) external view returns (bool);

    /// @dev the hash of Permit
    /// @param owner the token's owner
    /// @param spender the account that spend owner's token
    /// @param value the amount to be approve to spend
    /// @param deadline the deadline that valid the owner's signature
    /// @param _nounce the _nounce
    function hashPermit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint256 _nounce
    ) external view returns (bytes32);
}


// File contracts/L2/LockTOSv2L2Logic.sol

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;
pragma abicoder v2;











interface MyTreasury {
    function isTreasury() external view returns (bool);
}

contract LockTOSv2L2Logic is
    LockTOSStorage,
    BaseStorage,
    AccessibleCommon,
    ILockTOSv2Action0
{
    using SafeMath for uint256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    event LockCreated(
        address account,
        uint256 lockId,
        uint256 value,
        uint256 unlockTime
    );
    event LockAmountIncreased(address account, uint256 lockId, uint256 value);
    event LockUnlockTimeIncreased(
        address account,
        uint256 lockId,
        uint256 unlockTime
    );
    event LockDeposited(address account, uint256 lockId, uint256 value);
    event LockWithdrawn(address account, uint256 lockId, uint256 value);


    modifier ifFree {
        require(free == 1, "LockId is already in use");
        free = 0;
        _;
        free = 1;
    }

    /// @inheritdoc ILockTOSv2Action0
    function needCheckpoint() external view override returns (bool need) {
        uint256 len = pointHistory.length;
        if (len == 0) {
            return true;
        }
        need = (block.timestamp - pointHistory[len - 1].timestamp) > epochUnit; // if the last record was within a week
    }

    /// @inheritdoc ILockTOSv2Action0
    function setMaxTime(uint256 _maxTime) external override onlyOwner {
        maxTime = _maxTime;
    }

    /// @inheritdoc ILockTOSv2Action0
    function transferTosToTreasury(address _treasury) external  override onlyOwner {
        require(_treasury != address(0), "zero address");
        require(MyTreasury(_treasury).isTreasury(), "not treasury");

        IERC20(tos).transfer(_treasury, IERC20(tos).balanceOf(address(this)));
    }

    /// @inheritdoc ILockTOSv2Action0
    function setStaker(address _staker) external  override onlyOwner {
        require(_staker != address(0), "zero address");
        require(staker != _staker, "same address");
        staker = _staker;
    }

    /// @inheritdoc ILockTOSv2Action0
    function allHolders() external view override returns (address[] memory) {
        return uniqueUsers;
    }

    /// @inheritdoc ILockTOSv2Action0
    function activeHolders() external view override returns (address[] memory) {
        bool[] memory activeCheck = new bool[](uniqueUsers.length);
        uint256 activeSize = 0;
        for (uint256 i = 0; i < uniqueUsers.length; ++i) {
            uint256[] memory activeLocks = activeLocksOf(uniqueUsers[i]);
            if (activeLocks.length > 0) {
                activeSize++;
                activeCheck[i] = true;
            }
        }

        address[] memory activeUsers = new address[](activeSize);
        uint256 j = 0;
        for (uint256 i = 0; i < uniqueUsers.length; ++i) {
            if (activeCheck[i]) {
                activeUsers[j++] = uniqueUsers[i];
            }
        }
        return activeUsers;
    }

    /// @inheritdoc ILockTOSv2Action0
    function increaseAmountByStaker(address user, uint256 _lockId, uint256 _value) external override onlyStaker {
        depositFor(user, _lockId, _value);
    }

    function increaseAmountOfIds(
        address[] memory users,
        uint256[] memory _lockIds,
        uint256[] memory _values,
        uint256 curTime
    )
        external onlyOwner
    {
        require(
            users.length > 0
            && users.length ==  _lockIds.length
            && users.length ==  _values.length ,
            "wrong length"
        );

        uint256 len = users.length;
        //console.log("increaseAmountOfIds len %s", len);

        for (uint256 i = 0; i < len; i++){
            address _account = users[i];
            uint256 _id = _lockIds[i];
            uint256 _value = _values[i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_account][_id];
            if (lock.withdrawn == false  && _value > 0) {
                //console.log("increaseAmountOfIds _id %s , _value %s", _id, _value);

                cumulativeTOSAmount.add(_value);

                // ==========================

                LibLockTOS.LockedBalance memory lockedOld = lock;
                LibLockTOS.LockedBalance memory lockedNew =
                    LibLockTOS.LockedBalance({
                        amount: lockedOld.amount,
                        start: lockedOld.start,
                        end: lockedOld.end,
                        withdrawn: false
                    });

                // Make new lock
                lockedNew.amount = lockedNew.amount.add(_value);

                // Checkpoint
                _checkpointForSync(lockedNew, lockedOld, curTime);

                // Save new lock
                lockedBalances[_account][_id] = lockedNew;
                allLocks[_id] = lockedNew;
                //console.log("Save new lock _id %s ", _id);

                // Save user point,
                int256 userSlope = lockedNew.amount.mul(MULTIPLIER).div(maxTime).toInt256();
                int256 userBias = userSlope.mul(lockedNew.end.sub(curTime).toInt256());
                LibLockTOS.Point memory userPoint =
                    LibLockTOS.Point({
                        timestamp: curTime,
                        slope: userSlope,
                        bias: userBias
                    });
                lockPointHistory[_id].push(userPoint);
                // ==========================
                // emit LockDeposited(_account, _id, _value);
            }
        }

    }

    /// @inheritdoc ILockTOSv2Action0
    function increaseUnlockTimeByStaker(address user, uint256 _lockId, uint256 _unlockWeeks)
        external override
        onlyStaker
    {
        require(_unlockWeeks > 0, "Unlock period less than a week");
        cumulativeEpochUnit = cumulativeEpochUnit.add(_unlockWeeks);

        LibLockTOS.LockedBalance memory lock =
            lockedBalances[user][_lockId];
        uint256 unlockTime = lock.end.add(_unlockWeeks.mul(epochUnit));
        unlockTime = unlockTime.div(epochUnit).mul(epochUnit);
        require(
            unlockTime - block.timestamp < maxTime,
            "Max unlock time is 3 years"
        );
        require(lock.end > block.timestamp, "Lock time already finished");
        require(lock.end < unlockTime, "New lock time must be greater");
        require(lock.amount > 0, "No existing locked TOS");
        _deposit(user, _lockId, 0, unlockTime);

        emit LockUnlockTimeIncreased(user, _lockId, unlockTime);
    }

    /// @inheritdoc ILockTOSv2Action0
    function increaseAmountUnlockTimeByStaker(address user, uint256 _lockId, uint256 _value, uint256 _unlockWeeks)
        external override onlyStaker
    {
        // console.log("increaseAmountUnlockTimeByStaker in ");
        require(_value > 0, "Value locked should be non-zero");
        require(_unlockWeeks > 0, "Unlock period less than a week");

        LibLockTOS.LockedBalance memory lock = lockedBalances[user][_lockId];
        require(lock.withdrawn == false, "Lock is withdrawn");
        require(lock.start > 0, "Lock does not exist");
        require(lock.end > block.timestamp, "Lock time is finished");

        uint256 unlockTime = lock.end.add(_unlockWeeks.mul(epochUnit));
        unlockTime = unlockTime.div(epochUnit).mul(epochUnit);
        require(
            unlockTime - block.timestamp < maxTime,
            "Max unlock time is 3 years"
        );
        require(lock.end < unlockTime, "New lock time must be greater");
        require(lock.amount > 0, "No existing locked TOS");

        cumulativeTOSAmount = cumulativeTOSAmount.add(_value);
        cumulativeEpochUnit = cumulativeEpochUnit.add(_unlockWeeks);

        _deposit(user, _lockId, _value, unlockTime);

        emit LockDeposited(user, _lockId, _value);
        emit LockUnlockTimeIncreased(user, _lockId, unlockTime);
    }



    /// @inheritdoc ILockTOSv2Action0
    function withdrawAllByStaker(address user) external override ifFree onlyStaker{
        uint256[] storage locks = userLocks[user];
        if (locks.length == 0) {
            return;
        }

        for (uint256 i = 0; i < locks.length; i++) {
            LibLockTOS.LockedBalance memory lock = allLocks[locks[i]];
            if (
                lock.withdrawn == false &&
                locks[i] > 0 &&
                lock.amount > 0 &&
                lock.start > 0 &&
                lock.end > 0 &&
                lock.end < block.timestamp
            ) {
                _withdraw(user, locks[i]);
            }
        }
    }

    /// @inheritdoc ILockTOSv2Action0
    function globalCheckpoint() external  override {
        _recordHistoryPoints();
    }

    /// @inheritdoc ILockTOSv2Action0
    function withdrawByStaker(address user, uint256 _lockId) public override ifFree onlyStaker {
        require(_lockId > 0, "_lockId is zero");
        _withdraw(user, _lockId);
    }

    function _withdraw(address user, uint256 _lockId) internal {
        LibLockTOS.LockedBalance memory lockedOld =
            lockedBalances[user][_lockId];
        require(lockedOld.withdrawn == false, "Already withdrawn");
        require(lockedOld.start > 0, "Lock does not exist");
        require(lockedOld.end < block.timestamp, "Lock time not finished");
        require(lockedOld.amount > 0, "No amount to withdraw");

        LibLockTOS.LockedBalance memory lockedNew =
            LibLockTOS.LockedBalance({
                amount: 0,
                start: 0,
                end: 0,
                withdrawn: true
            });

        // Checkpoint
        _checkpoint(lockedNew, lockedOld);

        // Transfer TOS back
        uint256 amount = lockedOld.amount;
        lockedBalances[user][_lockId] = lockedNew;
        allLocks[_lockId] = lockedNew;

        // IERC20(tos).transfer(user, amount);
        emit LockWithdrawn(user, _lockId, amount);
    }

    /// @inheritdoc ILockTOSv2Action0
    function createLockByStaker(address user, uint256 _value, uint256 _unlockWeeks)
        public override
        onlyStaker
        returns (uint256 lockId)
    {
        require(_value > 0, "Value locked should be non-zero");
        require(_unlockWeeks > 0, "Unlock period less than a week");

        cumulativeEpochUnit = cumulativeEpochUnit.add(_unlockWeeks);
        cumulativeTOSAmount = cumulativeTOSAmount.add(_value);
        uint256 unlockTime = block.timestamp.add(_unlockWeeks.mul(epochUnit));
        unlockTime = unlockTime.div(epochUnit).mul(epochUnit);
        require(
            unlockTime - block.timestamp <= maxTime,
            "Max unlock time is 3 years"
        );

        if (userLocks[user].length == 0) { // check if user for the first time
            uniqueUsers.push(user);
        }

        lockIdCounter = lockIdCounter.add(1);
        lockId = lockIdCounter;

        _deposit(user, lockId, _value, unlockTime);
        userLocks[user].push(lockId);

        emit LockCreated(user, lockId, _value, unlockTime);
    }

    /// @inheritdoc ILockTOSv2Action0
    function depositFor(
        address _addr,
        uint256 _lockId,
        uint256 _value
    ) public override onlyStaker {
        require(_value > 0, "Value locked should be non-zero");
        LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][_lockId];
        require(lock.withdrawn == false, "Lock is withdrawn");
        require(lock.start > 0, "Lock does not exist");
        require(lock.end > block.timestamp, "Lock time is finished");

        cumulativeTOSAmount = cumulativeTOSAmount.add(_value);
        _deposit(_addr, _lockId, _value, 0);
        emit LockDeposited(_addr, _lockId, _value);
    }

    /// @inheritdoc ILockTOSv2Action0
    function totalSupplyAt(uint256 _timestamp)
        public
        view override
        returns (uint256)
    {
        if (pointHistory.length == 0) {
            return 0;
        }

        (bool success, LibLockTOS.Point memory point) =
            _findClosestPoint(pointHistory, _timestamp);
        if (!success) {
            return 0;
        }

        point = _fillRecordGaps(point, _timestamp);
        int256 currentBias =
            point.slope * (_timestamp.sub(point.timestamp).toInt256());
        return
            uint256(point.bias > currentBias ? point.bias - currentBias : 0)
                .div(MULTIPLIER);
    }

    /// @inheritdoc ILockTOSv2Action0
    function totalLockedAmountOf(address _addr) external view override returns (uint256) {
        uint256 len = userLocks[_addr].length;
        uint256 stakedAmount = 0;
        for (uint256 i = 0; i < len; ++i) {
            uint256 lockId = userLocks[_addr][i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];
            stakedAmount = stakedAmount.add(lock.amount);
        }
        return stakedAmount;
    }

    /// @inheritdoc ILockTOSv2Action0
    function withdrawableAmountOf(address _addr) external view override returns (uint256) {
        uint256 len = userLocks[_addr].length;
        uint256 amount = 0;
        for(uint i = 0; i < len; i++){
            uint256 lockId = userLocks[_addr][i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];
            if(lock.end <= block.timestamp && lock.amount > 0 && lock.withdrawn == false) {
                amount = amount.add(lock.amount);
            }
        }
        return amount;
    }

    /// @inheritdoc ILockTOSv2Action0
    function totalSupply() external view override returns (uint256) {
        if (pointHistory.length == 0) {
            return 0;
        }

        LibLockTOS.Point memory point = _fillRecordGaps(
            pointHistory[pointHistory.length - 1],
            block.timestamp
        );

        int256 currentBias =
            point.slope.mul(block.timestamp.sub(point.timestamp).toInt256());
        return
            uint256(point.bias > currentBias ? point.bias.sub(currentBias) : 0)
                .div(MULTIPLIER);
    }

    /// @inheritdoc ILockTOSv2Action0
    function balanceOfLockAt(uint256 _lockId, uint256 _timestamp)
        public override
        view
        returns (uint256)
    {
        (bool success, LibLockTOS.Point memory point) =
            _findClosestPoint(lockPointHistory[_lockId], _timestamp);
        if (!success) {
            return 0;
        }
        int256 currentBias =
            point.slope.mul(_timestamp.sub(point.timestamp).toInt256());
        return
            uint256(point.bias > currentBias ? point.bias.sub(currentBias) : 0)
                .div(MULTIPLIER);
    }

    /// @inheritdoc ILockTOSv2Action0
    function balanceOfLock(uint256 _lockId)
        public override
        view
        returns (uint256)
    {
        uint256 len = lockPointHistory[_lockId].length;
        if (len == 0) {
            return 0;
        }

        LibLockTOS.Point memory point = lockPointHistory[_lockId][len - 1];
        int256 currentBias =
            point.slope.mul(block.timestamp.sub(point.timestamp).toInt256());
        return
            uint256(point.bias > currentBias ? point.bias.sub(currentBias) : 0)
                .div(MULTIPLIER);
    }

    /// @inheritdoc ILockTOSv2Action0
    function balanceOfAt(address _addr, uint256 _timestamp)
        public override
        view
        returns (uint256 balance)
    {
        uint256[] memory locks = userLocks[_addr];
        if (locks.length == 0) return 0;
        for (uint256 i = 0; i < locks.length; ++i) {
            balance = balance.add(balanceOfLockAt(locks[i], _timestamp));
        }
    }

    /// @inheritdoc ILockTOSv2Action0
    function balanceOf(address _addr)
        public override
        view
        returns (uint256 balance)
    {
        uint256[] memory locks = userLocks[_addr];
        if (locks.length == 0) return 0;
        for (uint256 i = 0; i < locks.length; ++i) {
            balance = balance.add(balanceOfLock(locks[i]));
        }
    }

    /// @inheritdoc ILockTOSv2Action0
    function locksInfo(uint256 _lockId)
        public override
        view
        returns (
            uint256 start,
            uint256 end,
            uint256 amount
        )
    {
        return (
            allLocks[_lockId].start,
            allLocks[_lockId].end,
            allLocks[_lockId].amount
        );
    }

    /// @inheritdoc ILockTOSv2Action0
    function locksOf(address _addr)
        public override
        view
        returns (uint256[] memory)
    {
        return userLocks[_addr];
    }

    /// @inheritdoc ILockTOSv2Action0
    function withdrawableLocksOf(address _addr)  external view override onlyStaker returns (uint256[] memory) {
        uint256 len = userLocks[_addr].length;
        uint256 size = 0;
        for(uint i = 0; i < len; i++){
            uint256 lockId = userLocks[_addr][i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];
            if(lock.end <= block.timestamp && lock.amount > 0 && lock.withdrawn == false) {
                size++;
            }
        }

        uint256[] memory withdrawable = new uint256[](size);
        size = 0;
        for(uint i = 0; i < len; i++) {
            uint256 lockId = userLocks[_addr][i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];
            if(lock.end <= block.timestamp && lock.amount > 0 && lock.withdrawn == false) {
                withdrawable[size++] = lockId;
            }
        }
        return withdrawable;
    }

    /// @inheritdoc ILockTOSv2Action0
    function activeLocksOf(address _addr)
        public
        view override
        returns (uint256[] memory)
    {
        uint256 len = userLocks[_addr].length;
        uint256 _size = 0;
        for(uint i = 0; i < len; i++){
            uint256 lockId = userLocks[_addr][i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];
            if(lock.end > block.timestamp) {
                _size++;
            }
        }

        uint256[] memory activeLocks = new uint256[](_size);
        _size = 0;
        for(uint i = 0; i < len; i++) {
            uint256 lockId = userLocks[_addr][i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];
            if(lock.end > block.timestamp) {
                activeLocks[_size++] = lockId;
            }
        }
        return activeLocks;
    }

    /// @inheritdoc ILockTOSv2Action0
    function pointHistoryOf(uint256 _lockId)
        public
        view override
        returns (LibLockTOS.Point[] memory)
    {
        return lockPointHistory[_lockId];
    }


    function _findClosestPoint(
        LibLockTOS.Point[] storage _history,
        uint256 _timestamp
    ) internal view returns (bool success, LibLockTOS.Point memory point) {
        if (_history.length == 0) {
            return (false, point);
        }

        uint256 left = 0;
        uint256 right = _history.length;
        while (left + 1 < right) {
            uint256 mid = left.add(right).div(2);
            if (_history[mid].timestamp <= _timestamp) {
                left = mid;
            } else {
                right = mid;
            }
        }

        if (_history[left].timestamp <= _timestamp) {
            return (true, _history[left]);
        }
        return (false, point);
    }


    function _deposit(
        address _addr,
        uint256 _lockId,
        uint256 _value,
        uint256 _unlockTime
    ) internal ifFree {
        LibLockTOS.LockedBalance memory lockedOld =
            lockedBalances[_addr][_lockId];
        LibLockTOS.LockedBalance memory lockedNew =
            LibLockTOS.LockedBalance({
                amount: lockedOld.amount,
                start: lockedOld.start,
                end: lockedOld.end,
                withdrawn: false
            });

        // Make new lock
        lockedNew.amount = lockedNew.amount.add(_value);
        if (_unlockTime > 0) {
            lockedNew.end = _unlockTime;
        }
        if (lockedNew.start == 0) {
            lockedNew.start = block.timestamp;
        }

        // Checkpoint
        _checkpoint(lockedNew, lockedOld);

        // Save new lock
        lockedBalances[_addr][_lockId] = lockedNew;
        allLocks[_lockId] = lockedNew;

        // Save user point,
        int256 userSlope =
            lockedNew.amount.mul(MULTIPLIER).div(maxTime).toInt256();
        int256 userBias =
            userSlope.mul(lockedNew.end.sub(block.timestamp).toInt256());
        LibLockTOS.Point memory userPoint =
            LibLockTOS.Point({
                timestamp: block.timestamp,
                slope: userSlope,
                bias: userBias
            });
        lockPointHistory[_lockId].push(userPoint);

        // Transfer TOS
        // require(
        //     IERC20(tos).transferFrom(_addr, address(this), _value),
        //     "LockTOS: fail transferFrom"
        // );
    }

    function _checkpointForSync(
        LibLockTOS.LockedBalance memory lockedNew,
        LibLockTOS.LockedBalance memory lockedOld,
        uint256 curTime
    ) internal {
        uint256 timestamp = curTime;
        LibLockTOS.SlopeChange memory changeNew =
            LibLockTOS.SlopeChange({slope: 0, bias: 0, changeTime: 0});
        LibLockTOS.SlopeChange memory changeOld =
            LibLockTOS.SlopeChange({slope: 0, bias: 0, changeTime: 0});

        // Initialize slope changes
        if (lockedNew.end > timestamp && lockedNew.amount > 0) {
            changeNew.slope = lockedNew
                .amount
                .mul(MULTIPLIER)
                .div(maxTime)
                .toInt256();
            changeNew.bias = changeNew.slope
                .mul(lockedNew.end.sub(timestamp).toInt256());
            changeNew.changeTime = lockedNew.end;
        }
        if (lockedOld.end > timestamp && lockedOld.amount > 0) {
            changeOld.slope = lockedOld
                .amount
                .mul(MULTIPLIER)
                .div(maxTime)
                .toInt256();
            changeOld.bias = changeOld.slope
                .mul(lockedOld.end.sub(timestamp).toInt256());
            changeOld.changeTime = lockedOld.end;
        }

        // Record history gaps
        LibLockTOS.Point memory currentWeekPoint = _recordHistoryPoints();
        currentWeekPoint.bias = currentWeekPoint.bias.add(
            changeNew.bias.sub(changeOld.bias)
        );
        currentWeekPoint.slope = currentWeekPoint.slope.add(
            changeNew.slope.sub(changeOld.slope)
        );
        currentWeekPoint.bias = currentWeekPoint.bias > 0
            ? currentWeekPoint.bias
            : 0;
        currentWeekPoint.slope = currentWeekPoint.slope > 0
            ? currentWeekPoint.slope
            : 0;
        pointHistory[pointHistory.length - 1] = currentWeekPoint;

        // Update slope changes
        _updateSlopeChangesForSync(changeNew, changeOld, curTime);
    }

    function _updateSlopeChangesForSync(
        LibLockTOS.SlopeChange memory changeNew,
        LibLockTOS.SlopeChange memory changeOld,
        uint256 curTIme
    ) internal {
        int256 deltaSlopeNew = slopeChanges[changeNew.changeTime];
        int256 deltaSlopeOld = slopeChanges[changeOld.changeTime];
        if (changeOld.changeTime > curTIme) {
            deltaSlopeOld = deltaSlopeOld.add(changeOld.slope);
            if (changeOld.changeTime == changeNew.changeTime) {
                deltaSlopeOld = deltaSlopeOld.sub(changeNew.slope);
            }
            slopeChanges[changeOld.changeTime] = deltaSlopeOld;
        }
        if (
            changeNew.changeTime > curTIme &&
            changeNew.changeTime > changeOld.changeTime
        ) {
            deltaSlopeNew = deltaSlopeNew.sub(changeNew.slope);
            slopeChanges[changeNew.changeTime] = deltaSlopeNew;
        }
    }

    function _checkpoint(
        LibLockTOS.LockedBalance memory lockedNew,
        LibLockTOS.LockedBalance memory lockedOld
    ) internal {
        uint256 timestamp = block.timestamp;
        LibLockTOS.SlopeChange memory changeNew =
            LibLockTOS.SlopeChange({slope: 0, bias: 0, changeTime: 0});
        LibLockTOS.SlopeChange memory changeOld =
            LibLockTOS.SlopeChange({slope: 0, bias: 0, changeTime: 0});

        // Initialize slope changes
        if (lockedNew.end > timestamp && lockedNew.amount > 0) {
            changeNew.slope = lockedNew
                .amount
                .mul(MULTIPLIER)
                .div(maxTime)
                .toInt256();
            changeNew.bias = changeNew.slope
                .mul(lockedNew.end.sub(timestamp).toInt256());
            changeNew.changeTime = lockedNew.end;
        }
        if (lockedOld.end > timestamp && lockedOld.amount > 0) {
            changeOld.slope = lockedOld
                .amount
                .mul(MULTIPLIER)
                .div(maxTime)
                .toInt256();
            changeOld.bias = changeOld.slope
                .mul(lockedOld.end.sub(timestamp).toInt256());
            changeOld.changeTime = lockedOld.end;
        }

        // Record history gaps
        LibLockTOS.Point memory currentWeekPoint = _recordHistoryPoints();
        currentWeekPoint.bias = currentWeekPoint.bias.add(
            changeNew.bias.sub(changeOld.bias)
        );
        currentWeekPoint.slope = currentWeekPoint.slope.add(
            changeNew.slope.sub(changeOld.slope)
        );
        currentWeekPoint.bias = currentWeekPoint.bias > 0
            ? currentWeekPoint.bias
            : 0;
        currentWeekPoint.slope = currentWeekPoint.slope > 0
            ? currentWeekPoint.slope
            : 0;
        pointHistory[pointHistory.length - 1] = currentWeekPoint;

        // Update slope changes
        _updateSlopeChanges(changeNew, changeOld);
    }


    function _recordHistoryPoints()
        internal
        returns (LibLockTOS.Point memory lastWeek)
    {
        uint256 timestamp = block.timestamp;
        if (pointHistory.length > 0) {
            lastWeek = pointHistory[pointHistory.length - 1];
        } else {
            lastWeek = LibLockTOS.Point({
                bias: 0,
                slope: 0,
                timestamp: timestamp
            });
        }

        // Iterate through all past unrecoreded weeks and record
        uint256 pointTimestampIterator =
            lastWeek.timestamp.div(epochUnit).mul(epochUnit);
        while (pointTimestampIterator != timestamp) {
            pointTimestampIterator = Math.min(
                pointTimestampIterator.add(epochUnit),
                timestamp
            );
            int256 deltaSlope = slopeChanges[pointTimestampIterator];
            int256 deltaTime =
                Math.min(pointTimestampIterator.sub(lastWeek.timestamp), epochUnit).toInt256();
            lastWeek.bias = lastWeek.bias.sub(lastWeek.slope.mul(deltaTime));
            lastWeek.slope = lastWeek.slope.add(deltaSlope);
            lastWeek.bias = lastWeek.bias > 0 ? lastWeek.bias : 0;
            lastWeek.slope = lastWeek.slope > 0 ? lastWeek.slope : 0;
            lastWeek.timestamp = pointTimestampIterator;
            pointHistory.push(lastWeek);
        }
        return lastWeek;
    }


    function _fillRecordGaps(LibLockTOS.Point memory week, uint256 timestamp)
        internal
        view
        returns (LibLockTOS.Point memory)
    {
        // Iterate through all past unrecoreded weeks
        uint256 pointTimestampIterator =
            week.timestamp.div(epochUnit).mul(epochUnit);
        while (pointTimestampIterator != timestamp) {
            pointTimestampIterator = Math.min(
                pointTimestampIterator.add(epochUnit),
                timestamp
            );
            int256 deltaSlope = slopeChanges[pointTimestampIterator];
            int256 deltaTime =
                Math.min(pointTimestampIterator.sub(week.timestamp), epochUnit).toInt256();
            week.bias = week.bias.sub(week.slope.mul(deltaTime));
            week.slope = week.slope.add(deltaSlope);
            week.bias = week.bias > 0 ? week.bias : 0;
            week.slope = week.slope > 0 ? week.slope : 0;
            week.timestamp = pointTimestampIterator;
        }
        return week;
    }


    function _updateSlopeChanges(
        LibLockTOS.SlopeChange memory changeNew,
        LibLockTOS.SlopeChange memory changeOld
    ) internal {
        int256 deltaSlopeNew = slopeChanges[changeNew.changeTime];
        int256 deltaSlopeOld = slopeChanges[changeOld.changeTime];
        if (changeOld.changeTime > block.timestamp) {
            deltaSlopeOld = deltaSlopeOld.add(changeOld.slope);
            if (changeOld.changeTime == changeNew.changeTime) {
                deltaSlopeOld = deltaSlopeOld.sub(changeNew.slope);
            }
            slopeChanges[changeOld.changeTime] = deltaSlopeOld;
        }
        if (
            changeNew.changeTime > block.timestamp &&
            changeNew.changeTime > changeOld.changeTime
        ) {
            deltaSlopeNew = deltaSlopeNew.sub(changeNew.slope);
            slopeChanges[changeNew.changeTime] = deltaSlopeNew;
        }
    }

    function getCurrentTime() external view returns (uint256) {
        return block.timestamp;
    }

    function currentStakedTotalTOS() external view returns (uint256) {
        return IERC20(tos).balanceOf(address(this));
    }

    function version2() external pure returns (bool) {
        return true;
    }

}


// File contracts/sale/ERC165A.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;


contract ERC165A  {

     /*
     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd
     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231
     *     bytes4(keccak256('transfer(address,uint256)')) == 0xa9059cbb
     *     bytes4(keccak256('allowance(address,address)')) == 0xdd62ed3e
     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3
     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd
     *     bytes4(keccak256("safeTransfer(address,uint256)")) == 0x423f6cef
     *     bytes4(keccak256("safeTransfer(address,uint256,bytes)")) == 0xeb795549
     *     bytes4(keccak256("safeTransferFrom(address,address,uint256)")) == 0x42842e0e
     *     bytes4(keccak256("safeTransferFrom(address,address,uint256,bytes)")) == 0xb88d4fde
     *
     *     => 0x18160ddd ^ 0x70a08231 ^ 0xa9059cbb ^ 0xdd62ed3e ^ 0x095ea7b3 ^ 0x23b872dd ^ 0x423f6cef ^ 0xeb795549 ^ 0x42842e0e ^ 0xb88d4fde == 0x65787371
     */
    bytes4 public constant _INTERFACE_ID_ERC20 = 0x65787371;
    /*
     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7
     */
    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;

    mapping(bytes4 => bool) public _supportedInterfaces;

    constructor() {
        _registerInterface(_INTERFACE_ID_ERC20);
        _registerInterface(_INTERFACE_ID_ERC165);
    }


    function _registerInterface(bytes4 interfaceId) internal virtual {
        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");
        _supportedInterfaces[interfaceId] = true;
    }


}


// File contracts/sale/ERC20/Context.sol

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}


// File contracts/sale/ERC20/access/Ownable.sol

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}


// File contracts/sale/ERC20/IERC20.sol

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}


// File contracts/sale/ERC20/math/SafeMath.sol

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}


// File contracts/sale/ERC20/ERC20.sol

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;



/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    /**
     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with
     * a default value of 18.
     *
     * To select a different value for {decimals}, use {_setupDecimals}.
     *
     * All three of these values are immutable: they can only be set once during
     * construction.
     */
    constructor (string memory name_, string memory symbol_) public {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is
     * called.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
        return _decimals;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Sets {decimals} to a value other than the default one of 18.
     *
     * WARNING: This function should only be called from the constructor. Most
     * applications that interact with token contracts will not expect
     * {decimals} to ever change, and may work incorrectly if it does.
     */
    function _setupDecimals(uint8 decimals_) internal {
        _decimals = decimals_;
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}


// File contracts/sale/ERC20/IERC20Snapshot.sol

// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0 <0.8.0;

interface IERC20Snapshot {
    function balanceOfAt(address account, uint256 snapshotId) external view returns (uint256);
}


// File contracts/sale/ERC20/math/Math.sol

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library Math {
    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow, so we distribute
        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
    }
}


// File contracts/sale/ERC20/utils/Arrays.sol

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Collection of functions related to array types.
 */
library Arrays {
   /**
     * @dev Searches a sorted `array` and returns the first index that contains
     * a value greater or equal to `element`. If no such index exists (i.e. all
     * values in the array are strictly less than `element`), the array length is
     * returned. Time complexity O(log n).
     *
     * `array` is expected to be sorted in ascending order, and to contain no
     * repeated elements.
     */
    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {
        if (array.length == 0) {
            return 0;
        }

        uint256 low = 0;
        uint256 high = array.length;

        while (low < high) {
            uint256 mid = Math.average(low, high);

            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
            // because Math.average rounds down (it does integer division with truncation).
            if (array[mid] > element) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.
        if (low > 0 && array[low - 1] == element) {
            return low - 1;
        } else {
            return low;
        }
    }
}


// File contracts/sale/ERC20/utils/Counters.sol

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @title Counters
 * @author Matt Condon (@shrugs)
 * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number
 * of elements in a mapping, issuing ERC721 ids, or counting request ids.
 *
 * Include with `using Counters for Counters.Counter;`
 * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}
 * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never
 * directly accessed.
 */
library Counters {
    using SafeMath for uint256;

    struct Counter {
        // This variable should never be directly accessed by users of the library: interactions must be restricted to
        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
        // this feature: see https://github.com/ethereum/solidity/issues/4637
        uint256 _value; // default: 0
    }

    function current(Counter storage counter) internal view returns (uint256) {
        return counter._value;
    }

    function increment(Counter storage counter) internal {
        // The {SafeMath} overflow check can be skipped here, see the comment at the top
        counter._value += 1;
    }

    function decrement(Counter storage counter) internal {
        counter._value = counter._value.sub(1);
    }
}


// File contracts/sale/ERC20/ERC20Snapshot.sol

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;





/**
 * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and
 * total supply at the time are recorded for later access.
 *
 * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.
 * In naive implementations it's possible to perform a "double spend" attack by reusing the same balance from different
 * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be
 * used to create an efficient ERC20 forking mechanism.
 *
 * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a
 * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot
 * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id
 * and the account address.
 *
 * ==== Gas Costs
 *
 * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log
 * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much
 * smaller since identical balances in subsequent snapshots are stored as a single entry.
 *
 * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is
 * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent
 * transfers will have normal cost until the next snapshot, and so on.
 */
abstract contract ERC20Snapshot is ERC20 {
    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:
    // https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol

    using SafeMath for uint256;
    using Arrays for uint256[];
    using Counters for Counters.Counter;

    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a
    // Snapshot struct, but that would impede usage of functions that work on an array.
    struct Snapshots {
        uint256[] ids;
        uint256[] values;
    }

    mapping (address => Snapshots) private _accountBalanceSnapshots;
    Snapshots private _totalSupplySnapshots;

    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.
    Counters.Counter private _currentSnapshotId;

    /**
     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.
     */
    event Snapshot(uint256 id);

    /**
     * @dev Creates a new snapshot and returns its snapshot id.
     *
     * Emits a {Snapshot} event that contains the same id.
     *
     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a
     * set of accounts, for example using {AccessControl}, or it may be open to the public.
     *
     * [WARNING]
     * ====
     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,
     * you must consider that it can potentially be used by attackers in two ways.
     *
     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow
     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target
     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs
     * section above.
     *
     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.
     * ====
     */
    function _snapshot() internal virtual returns (uint256) {
        _currentSnapshotId.increment();

        uint256 currentId = _currentSnapshotId.current();
        emit Snapshot(currentId);
        return currentId;
    }

    /**
     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.
     */
    function balanceOfAt(address account, uint256 snapshotId) public view returns (uint256) {
        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);

        return snapshotted ? value : balanceOf(account);
    }

    /**
     * @dev Retrieves the total supply at the time `snapshotId` was created.
     */
    function totalSupplyAt(uint256 snapshotId) public view returns(uint256) {
        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);

        return snapshotted ? value : totalSupply();
    }


    // Update balance and/or total supply snapshots before the values are modified. This is implemented
    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {
      super._beforeTokenTransfer(from, to, amount);

      if (from == address(0)) {
        // mint
        _updateAccountSnapshot(to);
        _updateTotalSupplySnapshot();
      } else if (to == address(0)) {
        // burn
        _updateAccountSnapshot(from);
        _updateTotalSupplySnapshot();
      } else {
        // transfer
        _updateAccountSnapshot(from);
        _updateAccountSnapshot(to);
      }
    }

    function _valueAt(uint256 snapshotId, Snapshots storage snapshots)
        private view returns (bool, uint256)
    {
        require(snapshotId > 0, "ERC20Snapshot: id is 0");
        // solhint-disable-next-line max-line-length
        require(snapshotId <= _currentSnapshotId.current(), "ERC20Snapshot: nonexistent id");

        // When a valid snapshot is queried, there are three possibilities:
        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never
        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds
        //  to this id is the current one.
        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the
        //  requested id, and its value is the one to return.
        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be
        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is
        //  larger than the requested one.
        //
        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if
        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does
        // exactly this.

        uint256 index = snapshots.ids.findUpperBound(snapshotId);

        if (index == snapshots.ids.length) {
            return (false, 0);
        } else {
            return (true, snapshots.values[index]);
        }
    }

    function _updateAccountSnapshot(address account) private {
        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));
    }

    function _updateTotalSupplySnapshot() private {
        _updateSnapshot(_totalSupplySnapshots, totalSupply());
    }

    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {
        uint256 currentId = _currentSnapshotId.current();
        if (_lastSnapshotId(snapshots.ids) < currentId) {
            snapshots.ids.push(currentId);
            snapshots.values.push(currentValue);
        }
    }

    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {
        if (ids.length == 0) {
            return 0;
        } else {
            return ids[ids.length - 1];
        }
    }
}


// File contracts/sale/mock/ERC20Mock.sol

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;


/**
 * @title ERC20Mock
 * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.
 * Note they can later distribute these tokens as they wish using `transfer` and other
 * `ERC20` functions.
 */

contract ERC20Mock is ERC20, ERC20Burnable {
    uint256 public constant INITIAL_SUPPLY = 1000000000 * (10**18);
    /**
     * @dev Constructor that gives msg.sender all of existing tokens.
     */
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(_msgSender(), INITIAL_SUPPLY);
    }
}


// File contracts/sale/mock/ERC20SnapshotMock.sol

// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0 <0.8.0;


contract ERC20SnapshotMock is ERC20, ERC20Snapshot {
    uint256 public constant INITIAL_SUPPLY = 10000 * (10**18);

    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(_msgSender(), INITIAL_SUPPLY);
    }   

    function snapshot() public returns (uint256) {
        uint256 snapId = _snapshot();
        return snapId;
    }

    // The following functions are overrides required by Solidity.
    function _beforeTokenTransfer(address from, address to, uint256 amount)
        internal
        override(ERC20, ERC20Snapshot)
    {
        super._beforeTokenTransfer(from, to, amount);
    }
}


// File contracts/sale/OnApprove2.sol

//SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

abstract contract OnApprove2 is ERC165 {
  constructor() {
    bytes4 OnApproveSelector= bytes4(keccak256("onApprove(address,address,uint256,bytes)"));

    _registerInterface(OnApproveSelector);
    // _registerInterface(OnApprove(this).onApprove.selector);
  }

  // function onApprove(address owner, address spender, uint256 amount, bytes calldata data) external returns (bool);
}


// File @openzeppelin/contracts/utils/ReentrancyGuard.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor () internal {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}


// File contracts/interfaces/IPrivateSale.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IPrivateSale {
    /// @dev calculator the SaleAmount(input TON how many get the anotherToken)
    /// @param _amount input the TON amount
    function calculSaleToken(uint256 _amount) external view returns (uint256);

    /// @dev calculator the getAmount(want to get _amount how many input the TON?)
    /// @param _amount input the anotherTokenAmount
    function calculGetToken(uint256 _amount) external view returns (uint256);
    
    
    /// @dev address setting
    /// @param _saleToken saleTokenAddress (contract have token)
    /// @param _getToken getTokenAddress (TON)
    /// @param _ownerToken get TON transfer to wallet
    function addressSetting(
        address _saleToken,
        address _getToken,
        address _ownerToken
    ) external;

    function changeWTONAddress(address _wton) external;

    function changeTokenAddress(address _saleToken, address _getToken) external;

    function changeGetAddress(address _address) external;

    function setAllsetting(
        uint256[2] calldata _saleTime,
        uint256[2] calldata _tokenPrice,
        uint16 _claimCounts,
        uint256[] calldata _claimTimes,
        uint32[] calldata _claimPercents
    ) external;

    function settingSaleTime(uint256 _startTime,uint256 _endTime) external;

    function setTokenPrice(uint256 _saleTokenPrice, uint256 _getTokenPrice) external;

    function setClaimArray(
        uint16 _claimCounts,
        uint256[] calldata _claimTimes,
        uint32[] calldata _claimPercents
    ) external;

    function addWhiteList(address _account,uint256 _amount) external;

    function addWhiteListArray(address[] calldata _account, uint256[] calldata _amount) external;

    function delWhiteList(address _account, uint256 _amount) external;

    function directBuy(
        address _claimAddress,
        uint256 _amount
    ) external;

    function claim() external;

    function decodeApproveData(
        bytes memory data
    ) external pure returns (uint256 approveData);

    function decodeAddressData(
        bytes memory data
    ) external pure returns (address claimAddress_);

    function encodeAddressData(
        address _claimAddress
    ) external pure returns (bytes memory data);

    function _toWAD(uint256 v) external pure returns (uint256);

}


// File contracts/sale/PrivateSaleStorage.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

/// @title The storage of StakeProxy
contract PrivateSaleStorage {

    struct UserInfoAmount {
        uint256 inputamount;
        uint256 totaloutputamount;
        uint256 getAmount;
        address inputAddress;
    }

    struct WhiteList {
        uint256 amount;
    }
    
    address public getTokenOwner;       //받은 ton을 받을 주소
    uint256 public totalGetAmount;      //총 TON받은양
    uint256 public totalSaleAmount;     //총 판매토큰

    uint256 public saleStartTime;           //sale시작 시간
    uint256 public saleEndTime;             //sale끝 시간

    uint256 public saleTokenPrice;  //판매토큰가격
    uint256 public getTokenPrice;   //받는토큰가격(TON)

    IERC20 public saleToken;        //판매할 token주소
    IERC20 public getToken;         //TON 주소

    address public wton;             //WTON 주소

    uint256 public totalAllocatedAmount;
    uint16 public totalClaimCounts;

    uint256[] public claimTimes;
    uint256[] public claimPercents; 

    mapping (address => UserInfoAmount) public usersAmount;
    mapping (address => WhiteList) public usersWhite;

    /// @dev flag for pause proxy
    bool public pauseProxy;

    bool public pauseSetting;

    /// @dev implementation of proxy index
    mapping(uint256 => address) public proxyImplementation;
    mapping(address => bool) public aliveImplementation;
    mapping(bytes4 => address) public selectorImplementation;
}


// File contracts/sale/PrivateSale.sol

// SPDX-License-Identifier: MIT

pragma solidity ^0.7.6;








contract PrivateSale is 
    PrivateSaleStorage, 
    ProxyAccessCommon, 
    ReentrancyGuard, 
    OnApprove, 
    IPrivateSale 
{
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    event Buyinfo(
        address user,
        uint256 inputAmount,
        uint256 totalOutPutamount,
        uint256 inputTime
    );

    event Claiminfo(
        address user,
        uint256 claimAmount
    );

    event Withdrawinfo(
        address user,
        uint256 withdrawAmount
    );

    event AddList(
        address account,
        uint256 amount
    );

    event DelList(
        address account,
        uint256 amount
    );

    modifier settingCheck() {
        require(!pauseSetting || isProxyAdmin(msg.sender), "setting is Pause");
        _;
    }

    /* ========== onlyPolicyOwner ========== */
    /// @dev Set pause state
    /// @param _pause true:pause or false:resume
    function setSettingPause(bool _pause) external onlyProxyOwner {
        pauseSetting = _pause;
    }

    /* ========== onlyOwner ========== */

    /// @dev address setting
    /// @param _saleToken saleTokenAddress (contract have token)
    /// @param _getToken getTokenAddress (TON)
    /// @param _ownerToken get TON transfer to wallet
    function addressSetting(
        address _saleToken,
        address _getToken,
        address _ownerToken
    ) 
        external 
        override 
        onlyOwner 
        settingCheck
    {
        changeTokenAddress(_saleToken,_getToken);
        changeGetAddress(_ownerToken);
    }

    function changeWTONAddress(address _wton) 
        external 
        override 
        onlyOwner
        settingCheck 
    {
        wton = _wton;
    }

    function changeTokenAddress(address _saleToken, address _getToken) 
        public 
        override 
        onlyOwner
        settingCheck 
    {
        saleToken = IERC20(_saleToken);
        getToken = IERC20(_getToken);
    }

    function changeGetAddress(address _address) 
        public 
        override 
        onlyOwner 
        settingCheck
    {
        getTokenOwner = _address;
    }

    /**
     * @notice AllsettingFunction
     * @param  _saleTime _saleTime[0] = SalestartTime, _saleTime[1] = SaleEndTime
     * @param  _tokenPrice _tokenPrice[0] = saleTokenPrice, _tokenPrice[1] = TONTokenPrice
     * @param  _claimCounts claimTotalCounts
     * @param  _claimTimes _claimTimeArray
     * @param  _claimPercents claimPercents
     */
    function setAllsetting(
        uint256[2] calldata _saleTime,
        uint256[2] calldata _tokenPrice,
        uint16 _claimCounts,
        uint256[] calldata _claimTimes,
        uint32[] calldata _claimPercents
    ) 
        external
        override 
        onlyOwner
        settingCheck 
    {
        settingSaleTime(
            _saleTime[0],
            _saleTime[1]
        );
        setTokenPrice(
            _tokenPrice[0],
            _tokenPrice[1]
        );
        setClaimArray(
            _claimCounts,
            _claimTimes,
            _claimPercents
        );
    }

    function settingSaleTime(
        uint256 _startTime,
        uint256 _endTime
    )
        public 
        override 
        onlyOwner 
        settingCheck
    {
        saleStartTime = _startTime;
        saleEndTime = _endTime;
    }

    function setTokenPrice(uint256 _saleTokenPrice, uint256 _getTokenPrice)
        public
        override
        onlyOwner
        settingCheck
    {
        saleTokenPrice = _saleTokenPrice;
        getTokenPrice = _getTokenPrice;
    }

    function setClaimArray(
        uint16 _claimCounts,
        uint256[] calldata _claimTimes,
        uint32[] calldata _claimPercents
    ) 
        public
        override
        onlyOwner
        settingCheck 
    {
        if(totalClaimCounts != 0) {
            delete claimTimes;
            delete claimPercents;
        }

        totalClaimCounts = _claimCounts;
        uint256 i = 0;
        uint32 y = 0;
        for (i = 0; i < _claimCounts; i++) {
            claimTimes.push(_claimTimes[i]);
            if (i != 0){
                require(claimTimes[i-1] < claimTimes[i], "PublicSale: claimtime err");
            }
            claimPercents.push(_claimPercents[i]);
            y = y + _claimPercents[i];
        }

        require(y == 10000, "claimPercents err");
    }

    function addWhiteList(address _account,uint256 _amount) external override onlyOwner {
        WhiteList storage userwhite = usersWhite[_account];
        userwhite.amount = userwhite.amount.add(_amount);

        emit AddList(_account, _amount);
    }

    function addWhiteListArray(address[] calldata _account, uint256[] calldata _amount) external override onlyOwner {
        for(uint i = 0; i < _account.length; i++) {
            WhiteList storage userwhite = usersWhite[_account[i]];
            userwhite.amount = userwhite.amount.add(_amount[i]);

            emit AddList(_account[i], _amount[i]);
        }
    }

    function delWhiteList(address _account, uint256 _amount) external override onlyOwner {
        WhiteList storage userwhite = usersWhite[_account];
        userwhite.amount = userwhite.amount.sub(_amount);

        emit DelList(_account, _amount);
    }

    /* ========== VIEW ========== */

    /// @dev calculator the SaleAmount(input TON how many get the anotherToken)
    /// @param _amount input the TON amount
    function calculSaleToken(uint256 _amount)
        public
        override
        view
        returns (uint256)
    {
        uint256 tokenSaleAmount = _amount.mul(getTokenPrice).div(saleTokenPrice);
        return tokenSaleAmount;
    }

    /// @dev calculator the getAmount(want to get _amount how many input the TON?)
    /// @param _amount input the anotherTokenAmount
    function calculGetToken(uint256 _amount)
        public
        override
        view
        returns (uint256)
    {
        uint256 tokenGetAmount = _amount.mul(saleTokenPrice).div(getTokenPrice);
        return tokenGetAmount;
    }

    function currentRound() public view returns (uint16 round) {
        if (block.timestamp > claimTimes[totalClaimCounts-1]) {
            return totalClaimCounts;
        }
        for (uint16 i = 0; i < totalClaimCounts; i++) {
            if (block.timestamp < claimTimes[i]) {
                return i;
            }
        }
    }

    function calculClaimAmount(address _account, uint16 _round)
        public
        view
        returns (uint256 _amount)
    {
        if (block.timestamp < claimTimes[0]) return 0;

        UserInfoAmount memory user = usersAmount[_account];
        if(user.inputamount == 0) return 0;

        if (totalClaimCounts == _round ) {
            return user.totaloutputamount.sub(user.getAmount);
        }

        uint256 roundClaimPercent;
        for (uint16 i = 0; i < _round; i++) {
            roundClaimPercent = roundClaimPercent.add(claimPercents[i]);
        }
        
        uint256 userGetAmount = (user.totaloutputamount.mul(roundClaimPercent).div(10000)).sub(user.getAmount);
        return userGetAmount;
    }

    function saleTokenAddress() public view returns (address) {
        return address(saleToken);
    }

    /**
     * @dev transform WAD to RAY
     */
    function _toRAY(uint256 v) internal pure returns (uint256) {
        return v * 10 ** 9;
    }

    /**
     * @dev transform RAY to WAD
     */
    function _toWAD(uint256 v) public override pure returns (uint256) {
        return v / 10 ** 9;
    }

    function decodeApproveData(
        bytes memory data
    ) public override pure returns (uint256 approveData) {
        assembly {
            approveData := mload(add(data, 0x20))
        }
    }

    function decodeAddressData(
        bytes memory data
    ) public override pure returns (address claimAddress_) {
        require(data.length == 0x20);

        assembly {
            claimAddress_ := mload(add(data, 0x20))
        }
    }

    function encodeAddressData(
        address _claimAddress
    ) external override pure returns (bytes memory data) {
        data = new bytes(0x20);

        assembly {
            mstore(add(data, 0x20), _claimAddress)
        }
    }

    /* ========== Anyone can execute ========== */

    function onApprove(
        address sender,
        address spender,
        uint256 amount,
        bytes calldata data
    ) external override returns (bool) {
        require(msg.sender == address(getToken) || msg.sender == address(IWTON(wton)), "PrivateSale: only accept TON and WTON approve callback");
        
        address claimAddress = decodeAddressData(data);
        
        if(msg.sender == address(getToken)) {
            buy(sender,claimAddress,amount);
        } else if (msg.sender == address(IWTON(wton))) {
            uint256 wtonAmount = _toWAD(amount);
            buy(sender,claimAddress,wtonAmount);
        }
        
        return true;
    }

    function directBuy(
        address _claimAddress,
        uint256 _amount
    ) public override {
        require(saleStartTime != 0 && saleEndTime != 0, "need to setting saleTime");
        require(block.timestamp >= saleStartTime && block.timestamp <= saleEndTime, "privaSale period end");
        WhiteList storage userwhite = usersWhite[msg.sender];
        require(userwhite.amount >= _amount, "need to add whiteList amount");

        _buy(msg.sender,_claimAddress,_amount);
        userwhite.amount = userwhite.amount.sub(_amount);
    }

    function buy(
        address _sender,
        address _claimAddress,
        uint256 _amount
    ) internal {
        require(saleStartTime != 0 && saleEndTime != 0, "need to setting saleTime");
        require(block.timestamp >= saleStartTime && block.timestamp <= saleEndTime, "privaSale period end");
        WhiteList storage userwhite = usersWhite[_sender];
        require(userwhite.amount >= _amount, "need to add whiteList amount");

        _buy(_sender,_claimAddress,_amount);
        userwhite.amount = userwhite.amount.sub(_amount);
    }

    function _buy(
        address _sender,
        address _claimAddress,
        uint256 _amount
    )
        internal
    {
        if(_claimAddress == address(0)){
            _claimAddress = _sender;
        }

        UserInfoAmount storage user = usersAmount[_claimAddress];

        uint256 tokenSaleAmount = calculSaleToken(_amount);
        uint256 Saledtoken = totalSaleAmount.add(tokenSaleAmount);
        uint256 tokenBalance = saleToken.balanceOf(address(this));

        require(
            tokenBalance >= Saledtoken,
            "don't have token amount"
        );

        uint256 tonAllowance = getToken.allowance(_sender, address(this));
        uint256 tonBalance = getToken.balanceOf(_sender);

        if(tonAllowance > tonBalance) {
            tonAllowance = tonBalance;  //tonAllowance가 tonBlance보다 더 클때 문제가 된다.
        }
        if(tonAllowance < _amount) {
            uint256 needUserWton;
            uint256 needWton = _amount.sub(tonAllowance);
            needUserWton = _toRAY(needWton);
            require(IWTON(wton).allowance(_sender, address(this)) >= needUserWton, "privateSale: wton amount exceeds allowance");
            require(IWTON(wton).balanceOf(_sender) >= needUserWton, "need more wton");
            IERC20(wton).safeTransferFrom(_sender,address(this),needUserWton);
            IWTON(wton).swapToTON(needUserWton);
            require(tonAllowance >= _amount.sub(needWton), "privateSale: ton amount exceeds allowance");
            if(_amount.sub(needWton) > 0) {
                getToken.safeTransferFrom(_sender, address(this), _amount.sub(needWton));   
            }
            getToken.safeTransfer(getTokenOwner, _amount);
        } else {
            require(tonAllowance >= _amount && tonBalance >= _amount, "privateSale: ton amount exceeds allowance");

            getToken.safeTransferFrom(_sender, address(this), _amount);
            getToken.safeTransfer(getTokenOwner, _amount);
        }

        user.inputamount = user.inputamount.add(_amount);
        user.totaloutputamount = user.totaloutputamount.add(tokenSaleAmount);
        user.getAmount = user.getAmount;
        user.inputAddress = _sender;

        totalGetAmount = totalGetAmount.add(_amount);
        totalSaleAmount = totalSaleAmount.add(tokenSaleAmount);

        emit Buyinfo(
            msg.sender, 
            user.inputamount, 
            user.totaloutputamount,
            block.timestamp
        );
    }

    function claim() external override {
        require(saleEndTime != 0, "need to setting Time");
        require(block.timestamp > saleEndTime, "need the endSale");
        require(block.timestamp > claimTimes[0], "need the claimTime");
        _claim();
        
    }

    function _claim() internal {
        require(block.timestamp >= claimTimes[0], "need the time for claim");

        UserInfoAmount storage user = usersAmount[msg.sender];

        require(user.inputamount > 0, "need to buy the token");
        require(user.totaloutputamount > user.getAmount, "already getAllreward");

        uint256 giveTokenAmount = calculClaimAmount(msg.sender, currentRound());
    
        require(user.totaloutputamount.sub(user.getAmount) >= giveTokenAmount, "user is already getAllreward");
        require(saleToken.balanceOf(address(this)) >= giveTokenAmount, "dont have saleToken in pool");

        user.getAmount = user.getAmount.add(giveTokenAmount);

        saleToken.safeTransfer(msg.sender, giveTokenAmount);

        emit Claiminfo(msg.sender, giveTokenAmount);
    }


    function withdraw(
        uint256 _amount
    ) 
        external 
        onlyOwner
        settingCheck 
    {
        require(
            saleToken.balanceOf(address(this)) >= _amount,
            "dont have token amount"
        );
        saleToken.safeTransfer(msg.sender, _amount);

        emit Withdrawinfo(msg.sender, _amount);
    }

}


// File contracts/interfaces/IPrivateSaleProxy.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IPrivateSaleProxy {
    /// @dev Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external;

    /// @dev Set implementation contract
    /// @param impl New implementation contract address
    function upgradeTo(address impl) external;

    /// @dev view implementation address of the proxy[index]
    /// @return address of the implementation
    function implementation() external view returns (address);

    /// @dev set the implementation address and status of the proxy[index]
    /// @param newImplementation Address of the new implementation.
    /// @param _index index of proxy
    /// @param _alive alive status
    function setImplementation2(
        address newImplementation,
        uint256 _index,
        bool _alive
    ) external;

    /// @dev set alive status of implementation
    /// @param newImplementation Address of the new implementation.
    /// @param _alive alive status
    function setAliveImplementation2(address newImplementation, bool _alive)
        external;

    /// @dev set selectors of Implementation
    /// @param _selectors being added selectors
    /// @param _imp implementation address
    function setSelectorImplementations2(
        bytes4[] calldata _selectors,
        address _imp
    ) external;

    /// @dev set the implementation address and status of the proxy[index]
    /// @param _selector the selector of function
    function getSelectorImplementation2(bytes4 _selector)
        external
        view
    returns (address impl);
}


// File contracts/sale/PrivateSaleProxy.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;




contract PrivateSaleProxy is 
    PrivateSaleStorage, 
    ProxyAccessCommon,
    OnApprove2,
    IPrivateSaleProxy
{

    event Upgraded(address indexed implementation);

    event SetAliveImplementation(address indexed impl, bool alive);
    event SetSelectorImplementation(bytes4 indexed selector, address indexed impl);

     /**
     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
     */
    constructor () {
        _setRoleAdmin(PROJECT_ADMIN_ROLE, PROJECT_ADMIN_ROLE);
        _setupRole(PROJECT_ADMIN_ROLE, msg.sender);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function setProxyPause(bool _pause) external override onlyOwner {
        pauseProxy = _pause;
    }

    /// @dev returns the implementation
    function implementation() external override view returns (address) {
        return _implementation2(0);
    }

    /// @notice Set implementation contract
    /// @param impl New implementation contract address
    function upgradeTo(address impl) external override onlyProxyOwner {
        require(impl != address(0), "input is zero");
        require(
            _implementation2(0) != impl,
            "same addr"
        );
        _setImplementation2(impl, 0, true);
        emit Upgraded(impl);
    }

    function implementation2(uint256 _index) external view returns (address) {
        return _implementation2(_index);
    }

    function setImplementation2(
        address newImplementation,
        uint256 _index,
        bool _alive
    ) external override onlyProxyOwner {
        _setImplementation2(newImplementation, _index, _alive);
    }

    function setAliveImplementation2(address newImplementation, bool _alive)
        public 
        override
        onlyProxyOwner
    {
        _setAliveImplementation2(newImplementation, _alive);
    }

    function setSelectorImplementations2(
        bytes4[] calldata _selectors,
        address _imp
    ) public override onlyProxyOwner {
        require(
            _selectors.length > 0,
            "Proxy: _selectors's size is zero"
        );
        require(aliveImplementation[_imp], "Proxy: _imp is not alive");

        for (uint256 i = 0; i < _selectors.length; i++) {
            require(
                selectorImplementation[_selectors[i]] != _imp,
                "LiquidityVaultProxy: same imp"
            );
            selectorImplementation[_selectors[i]] = _imp;
            emit SetSelectorImplementation(_selectors[i], _imp);
        }
    }

    /// @dev set the implementation address and status of the proxy[index]
    /// @param newImplementation Address of the new implementation.
    /// @param _index index of proxy
    /// @param _alive alive status
    function _setImplementation2(
        address newImplementation,
        uint256 _index,
        bool _alive
    ) internal {
        require(
            Address.isContract(newImplementation),
            "Proxy: not contract address"
        );
        if (_alive) proxyImplementation[_index] = newImplementation;
        _setAliveImplementation2(newImplementation, _alive);
    }

    /// @dev set alive status of implementation
    /// @param newImplementation Address of the new implementation.
    /// @param _alive alive status
    function _setAliveImplementation2(address newImplementation, bool _alive)
        internal
    {
        aliveImplementation[newImplementation] = _alive;
        emit SetAliveImplementation(newImplementation, _alive);
    }

    /// @dev view implementation address of the proxy[index]
    /// @param _index index of proxy
    /// @return impl address of the implementation
    function _implementation2(uint256 _index)
        internal
        view
        returns (address impl)
    {
        return proxyImplementation[_index];
    }

    function getSelectorImplementation2(bytes4 _selector)
        public
        override 
        view
        returns (address impl)
    {
        if (selectorImplementation[_selector] == address(0))
            return proxyImplementation[0];
        else if (aliveImplementation[selectorImplementation[_selector]]){
            return selectorImplementation[_selector];
        }
        else return proxyImplementation[0];
    }


    /// @dev receive ether
    receive() external payable {
        revert("cannot receive Ether");
    }

    /// @dev fallback function , execute on undefined function call
    fallback() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    function _fallback() internal {
        address _impl = getSelectorImplementation2(msg.sig);

        require(
            _impl != address(0) && !pauseProxy,
            "Proxy: impl OR proxy is false"
        );

        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }

    /// @dev Initialize
    /// @param _wton wtonAddress
    /// @param _saleToken saleTokenAddress
    /// @param _getToken tonAddress(usually)
    /// @param _getTokenOwner TON get Address
    function initialize(
        address _wton,
        address _saleToken,
        address _getToken,
        address _getTokenOwner
    ) external  onlyProxyOwner {
        wton = _wton;
        saleToken = IERC20(_saleToken);
        getToken = IERC20(_getToken);
        getTokenOwner = _getTokenOwner;
    }
}


// File contracts/sale/PublicSale.sol

// SPDX-License-Identifier: MIT

pragma solidity ^0.7.6;
pragma abicoder v2;








interface IIERC20Burnable {
    /**
     * @dev Destroys `amount` tokens from the caller.
     *
     * See {ERC20-_burn}.
     */
    function burn(uint256 amount) external ;
}

contract PublicSale is
    PublicSaleStorage,
    ProxyAccessCommon,
    ReentrancyGuard,
    IPublicSale
{
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    event AddedWhiteList(address indexed from, uint256 tier);
    event ExclusiveSaled(address indexed from, uint256 amount);
    event Deposited(address indexed from, uint256 amount);

    event Claimed(address indexed from, uint256 amount);
    event Withdrawal(address indexed from, uint256 amount);
    event DepositWithdrawal(address indexed from, uint256 amount, uint256 liquidityAmount);

    modifier nonZero(uint256 _value) {
        require(_value > 0, "PublicSale: zero");
        _;
    }

    modifier nonZeroAddress(address _addr) {
        require(_addr != address(0), "PublicSale: zero address");
        _;
    }

    modifier beforeStartAddWhiteTime() {
        require(
            startAddWhiteTime == 0 ||
                (startAddWhiteTime > 0 && block.timestamp < startAddWhiteTime),
            "PublicSale: not beforeStartAddWhiteTime"
        );
        _;
    }

    modifier beforeEndAddWhiteTime() {
        require(
            endAddWhiteTime == 0 ||
                (endAddWhiteTime > 0 && block.timestamp < endAddWhiteTime),
            "PublicSale: not beforeEndAddWhiteTime"
        );
        _;
    }

    modifier greaterThan(uint256 _value1, uint256 _value2) {
        require(_value1 > _value2, "PublicSale: non greaterThan");
        _;
    }

    modifier lessThan(uint256 _value1, uint256 _value2) {
        require(_value1 < _value2, "PublicSale: non less than");
        _;
    }

    function changeTONOwner(
        address _address
    )
        external
        override
        onlyOwner
    {
        getTokenOwner = _address;
    }

    function setAllsetting(
        uint256[8] calldata _Tier,
        uint256[6] calldata _amount,
        uint256[8] calldata _time,
        uint256[] calldata _claimTimes,
        uint256[] calldata _claimPercents
    )
        external
        override
        onlyOwner
        beforeStartAddWhiteTime
    {
        uint256 balance = saleToken.balanceOf(address(this));
        require((_amount[0] + _amount[1]) <= balance && 1 ether <= balance, "amount err");
        require(_time[6] < _claimTimes[0], "time err");
        require((deployTime + delayTime) < _time[0], "snapshot need later");
        require(_time[0] < _time[1], "whitelist before snapshot");
        require(_claimTimes.length > 0 &&  _claimTimes.length == _claimPercents.length, "need the claimSet");
        
        if(snapshot != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }

        setTier(
            _Tier[0], _Tier[1], _Tier[2], _Tier[3]
        );
        setTierPercents(
            _Tier[4], _Tier[5], _Tier[6], _Tier[7]
        );
        setSaleAmount(
            _amount[0],
            _amount[1]
        );
        setTokenPrice(
            _amount[2],
            _amount[3]
        );
        setHardcap(
            _amount[4],
            _amount[5]
        );
        setSnapshot(_time[0]);
        setExclusiveTime(
            _time[1],
            _time[2],
            _time[3],
            _time[4]
        );
        setOpenTime(
            _time[5],
            _time[6]
        );
        setEachClaim(
            _time[7],
            _claimTimes,
            _claimPercents
        );
    }

    /// @inheritdoc IPublicSale
    function setSnapshot(
        uint256 _snapshot
    )
        public
        override
        onlyOwner
        nonZero(_snapshot)
        beforeStartAddWhiteTime
    {
        if(snapshot != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }

        snapshot = _snapshot;
    }

    /// @inheritdoc IPublicSale
    function setExclusiveTime(
        uint256 _startAddWhiteTime,
        uint256 _endAddWhiteTime,
        uint256 _startExclusiveTime,
        uint256 _endExclusiveTime
    )
        public
        override
        onlyOwner
        nonZero(_startAddWhiteTime)
        nonZero(_endAddWhiteTime)
        nonZero(_startExclusiveTime)
        nonZero(_endExclusiveTime)
        beforeStartAddWhiteTime
    {
        if(startAddWhiteTime != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }

        require(
            (_startAddWhiteTime < _endAddWhiteTime) &&
            (_endAddWhiteTime < _startExclusiveTime) &&
            (_startExclusiveTime < _endExclusiveTime),
            "PublicSale : Round1time err"
        );
        startAddWhiteTime = _startAddWhiteTime;
        endAddWhiteTime = _endAddWhiteTime;
        startExclusiveTime = _startExclusiveTime;
        endExclusiveTime = _endExclusiveTime;
    }

    /// @inheritdoc IPublicSale
    function setOpenTime(
        uint256 _startDepositTime,
        uint256 _endDepositTime
    )
        public
        override
        onlyOwner
        nonZero(_startDepositTime)
        nonZero(_endDepositTime)
        beforeStartAddWhiteTime
    {
        if(startDepositTime != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }

        require(
            (_startDepositTime < _endDepositTime),
            "PublicSale : Round2time err"
        );

        startDepositTime = _startDepositTime;
        endDepositTime = _endDepositTime;
    }

    function setEachClaim(
        uint256 _claimCounts,
        uint256[] calldata _claimTimes,
        uint256[] calldata _claimPercents
    )
        public
        override
        onlyOwner
        beforeStartAddWhiteTime
    {
        if(totalClaimCounts != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }
        
        totalClaimCounts = _claimCounts;
        uint256 i = 0;
        uint256 y = 0;
        for (i = 0; i < _claimCounts; i++) {
            claimTimes.push(_claimTimes[i]);
            if (i != 0){
                require(claimTimes[i-1] < claimTimes[i], "PublicSale: claimtime err");
            }
            claimPercents.push(_claimPercents[i]);
            y = y + _claimPercents[i];
        }

        require(y == 100, "claimPercents err");
    }

    /// @inheritdoc IPublicSale
    function setAllTier(
        uint256[4] calldata _tier,
        uint256[4] calldata _tierPercent
    ) external override onlyOwner {
        require(
            stanTier1 <= _tier[0] &&
            stanTier2 <= _tier[1] &&
            stanTier3 <= _tier[2] &&
            stanTier4 <= _tier[3],
            "tier set error"
        );
        setTier(
            _tier[0],
            _tier[1],
            _tier[2],
            _tier[3]
        );
        setTierPercents(
            _tierPercent[0],
            _tierPercent[1],
            _tierPercent[2],
            _tierPercent[3]
        );
    }

    /// @inheritdoc IPublicSale
    function setTier(
        uint256 _tier1,
        uint256 _tier2,
        uint256 _tier3,
        uint256 _tier4
    )
        public
        override
        onlyOwner
        nonZero(_tier1)
        nonZero(_tier2)
        nonZero(_tier3)
        nonZero(_tier4)
        beforeStartAddWhiteTime
    {
        if(tiers[1] != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }
        tiers[1] = _tier1;
        tiers[2] = _tier2;
        tiers[3] = _tier3;
        tiers[4] = _tier4;
    }

    /// @inheritdoc IPublicSale
    function setTierPercents(
        uint256 _tier1,
        uint256 _tier2,
        uint256 _tier3,
        uint256 _tier4
    )
        public
        override
        onlyOwner
        nonZero(_tier1)
        nonZero(_tier2)
        nonZero(_tier3)
        nonZero(_tier4)
        beforeStartAddWhiteTime
    {
        if(tiersPercents[1] != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }
        require(
            _tier1.add(_tier2).add(_tier3).add(_tier4) == 10000,
            "PublicSale: Sum should be 10000"
        );
        tiersPercents[1] = _tier1;
        tiersPercents[2] = _tier2;
        tiersPercents[3] = _tier3;
        tiersPercents[4] = _tier4;
    }

    /// @inheritdoc IPublicSale
    function setAllAmount(
        uint256[2] calldata _expectAmount,
        uint256[2] calldata _priceAmount
    ) external override onlyOwner {
        setSaleAmount(
            _expectAmount[0],
            _expectAmount[1]
        );
        setTokenPrice(
            _priceAmount[0],
            _priceAmount[1]
        );
    }

    /// @inheritdoc IPublicSale
    function setSaleAmount(
        uint256 _totalExpectSaleAmount,
        uint256 _totalExpectOpenSaleAmount
    )
        public
        override
        onlyOwner
        nonZero(_totalExpectSaleAmount)
        beforeStartAddWhiteTime
    {
        if(totalExpectSaleAmount != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }
        totalExpectSaleAmount = _totalExpectSaleAmount;
        totalExpectOpenSaleAmount = _totalExpectOpenSaleAmount;
    }

    /// @inheritdoc IPublicSale
    function setTokenPrice(
        uint256 _saleTokenPrice,
        uint256 _payTokenPrice
    )
        public
        override
        onlyOwner
        nonZero(_saleTokenPrice)
        nonZero(_payTokenPrice)
        beforeStartAddWhiteTime
    {
        if(saleTokenPrice != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }
        saleTokenPrice = _saleTokenPrice;
        payTokenPrice = _payTokenPrice;
    }

    function setHardcap (
        uint256 _hardcapAmount,
        uint256 _changePercent
    )
        public
        override
        onlyOwner
        nonZero(_changePercent)
        beforeStartAddWhiteTime
    {
        if(changeTOS != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }
        require(_changePercent <= maxPer && _changePercent >= minPer,"PublicSale: need to set min,max");
        hardCap = _hardcapAmount;
        changeTOS = _changePercent;
    }

    function distributionByRounds(
        uint256 startRound,
        uint256 endRound
    ) 
        public
        view
        returns(uint256[] memory)
    {   
        if(startRound == 0) {
            startRound = 1;
        }
        if(totalClaimCounts < startRound) {
            startRound = totalClaimCounts;
        }
        if(endRound < startRound) {
            endRound = startRound;
        }
        if(totalClaimCounts < endRound || endRound == 0) {
            endRound = totalClaimCounts;
        }

        uint length = endRound.sub(startRound.sub(1));
        uint256[] memory claims = new uint256[](length);

        if(block.timestamp > endExclusiveTime && startRound != 0 ) {
            for(uint256 i = 0; i < length; i++) {
                uint256 amount = (((totalExSaleAmount.add(totalOpenSaleAmount())).mul(claimPercents[startRound.add(i).sub(1)])).div(100));
                claims[i] = amount;
            }
        } 
        else {
            for(uint256 i = 0; i < length; i++) {
                uint256 amount = (((totalExpectSaleAmount.add(totalExpectOpenSaleAmount)).mul(claimPercents[startRound.add(i).sub(1)])).div(100));
                claims[i] = amount;
            }
        }
        return claims;
    }

    function distributionByRound(
        uint256 _round
    )
        public
        view
        returns(uint256)
    {
        if(block.timestamp > endExclusiveTime && _round != 0) {
            return (((totalExSaleAmount.add(totalOpenSaleAmount())).mul(claimPercents[(_round-1)])).div(100));

        } else {
            return 0;
        }
    }

    /// @inheritdoc IPublicSale
    function totalExpectOpenSaleAmountView()
        public
        view
        override
        returns(uint256)
    {
        if (block.timestamp < endExclusiveTime) return totalExpectOpenSaleAmount;
        else return totalExpectOpenSaleAmount.add(totalRound1NonSaleAmount());
    }

    /// @inheritdoc IPublicSale
    function totalRound1NonSaleAmount()
        public
        view
        override
        returns(uint256)
    {
        return totalExpectSaleAmount.sub(totalExSaleAmount);
    }


    function _toRAY(uint256 v) internal pure returns (uint256) {
        return v * 10 ** 9;
    }

    /// @inheritdoc IPublicSale
    function calculSaleToken(uint256 _amount)
        public
        view
        override
        returns (uint256)
    {
        uint256 tokenSaleAmount =
            _amount.mul(payTokenPrice).div(saleTokenPrice);
        return tokenSaleAmount;
    }

    /// @inheritdoc IPublicSale
    function calculPayToken(uint256 _amount)
        public
        view
        override
        returns (uint256)
    {
        uint256 tokenPayAmount = _amount.mul(saleTokenPrice).div(payTokenPrice);
        return tokenPayAmount;
    }

    /// @inheritdoc IPublicSale
    function calculTier(address _address)
        public
        view
        override
        nonZeroAddress(address(sTOS))
        nonZero(tiers[1])
        nonZero(tiers[2])
        nonZero(tiers[3])
        nonZero(tiers[4])
        returns (uint256)
    {
        uint256 sTOSBalance = sTOS.balanceOfAt(_address, snapshot);
        uint256 tier;
        if (sTOSBalance >= tiers[1] && sTOSBalance < tiers[2]) {
            tier = 1;
        } else if (sTOSBalance >= tiers[2] && sTOSBalance < tiers[3]) {
            tier = 2;
        } else if (sTOSBalance >= tiers[3] && sTOSBalance < tiers[4]) {
            tier = 3;
        } else if (sTOSBalance >= tiers[4]) {
            tier = 4;
        } else if (sTOSBalance < tiers[1]) {
            tier = 0;
        }
        return tier;
    }

    /// @inheritdoc IPublicSale
    function calculTierAmount(address _address)
        public
        view
        override
        returns (uint256)
    {
        LibPublicSale.UserInfoEx storage userEx = usersEx[_address];
        uint256 tier = calculTier(_address);
        if (userEx.join == true && tier > 0) {
            uint256 salePossible =
                totalExpectSaleAmount
                    .mul(tiersPercents[tier])
                    .div(tiersAccount[tier])
                    .div(10000);
            return salePossible;
        } else if (tier > 0) {
            uint256 tierAccount = tiersAccount[tier].add(1);
            uint256 salePossible =
                totalExpectSaleAmount
                    .mul(tiersPercents[tier])
                    .div(tierAccount)
                    .div(10000);
            return salePossible;
        } else {
            return 0;
        }
    }

    /// @inheritdoc IPublicSale
    function calculOpenSaleAmount(address _account, uint256 _amount)
        public
        view
        override
        returns (uint256)
    {
        LibPublicSale.UserInfoOpen storage userOpen = usersOpen[_account];
        uint256 depositAmount = userOpen.depositAmount.add(_amount);
        uint256 openSalePossible =
            totalExpectOpenSaleAmountView().mul(depositAmount).div(
                totalDepositAmount.add(_amount)
            );
        return openSalePossible;
    }

    function currentRound() public view returns (uint256 round) {
        if (block.timestamp > claimTimes[totalClaimCounts-1]) {
            return totalClaimCounts;
        }
        for (uint256 i = 0; i < totalClaimCounts; i++) {
            if (block.timestamp < claimTimes[i]) {
                return i;
            }
        }
    }

    function calculClaimAmount(address _account, uint256 _round)
        public
        view
        override
        returns (uint256 _reward, uint256 _totalClaim, uint256 _refundAmount)
    {
        if (block.timestamp < startClaimTime) return (0, 0, 0);
        if (_round > totalClaimCounts) return (0, 0, 0);

        LibPublicSale.UserClaim storage userClaim = usersClaim[_account];
        (, uint256 realSaleAmount, uint256 refundAmount) = totalSaleUserAmount(_account);   //유저가 총 구매한 token의 양을 Return 함

        if (realSaleAmount == 0 ) return (0, 0, 0);
        if (userClaim.claimAmount >= realSaleAmount) return (0, 0, 0);    //userClaim.claimAmount  = contract에서 유저에게 준양

        if (_round != 0) {
            uint256 amount = realSaleAmount.mul(claimPercents[(_round.sub(1))]).div(100);
            return (amount, realSaleAmount, refundAmount);
        }

        //해당 라운드에서 받아야하는 토큰의 양 -> (realSaleAmount * claimPercents[i] / 100) : 해당 라운드에서 받아야하는 토큰의 양
        uint256 round = currentRound();

        if (totalClaimCounts == round && _round == 0) {
            uint256 amount = realSaleAmount - userClaim.claimAmount;
            return (amount, realSaleAmount, refundAmount);
        }

        uint256 expectedClaimAmount;
        for (uint256 i = 0; i < round; i++) {
            expectedClaimAmount = expectedClaimAmount.add((realSaleAmount.mul(claimPercents[i]).div(100)));
        }

        //Round를 0으로 넣으면 현재 내가 받을 수 있는 양을 리턴해주고 1 이상을 넣으면 해당 라운드에서 받을 수 있는 토큰의 양을 리턴해줌
        if (_round == 0) {
            uint256 amount = expectedClaimAmount - userClaim.claimAmount;
            return (amount, realSaleAmount, refundAmount);
        }
    }

    /// @inheritdoc IPublicSale
    function totalSaleUserAmount(address user) public override view returns (uint256 _realPayAmount, uint256 _realSaleAmount, uint256 _refundAmount) {
        LibPublicSale.UserInfoEx storage userEx = usersEx[user];

        if (userEx.join) {
            (uint256 realPayAmount, uint256 realSaleAmount, uint256 refundAmount) = openSaleUserAmount(user);
            return ( realPayAmount.add(userEx.payAmount), realSaleAmount.add(userEx.saleAmount), refundAmount);
        } else {
            return openSaleUserAmount(user);
        }
    }

    /// @inheritdoc IPublicSale
    function openSaleUserAmount(address user) public override view returns (uint256 _realPayAmount, uint256 _realSaleAmount, uint256 _refundAmount) {
        LibPublicSale.UserInfoOpen storage userOpen = usersOpen[user];

        if (!userOpen.join || userOpen.depositAmount == 0) return (0, 0, 0);

        uint256 openSalePossible = calculOpenSaleAmount(user, 0);
        uint256 realPayAmount = calculPayToken(openSalePossible);
        uint256 depositAmount = userOpen.depositAmount;
        uint256 realSaleAmount = 0;
        uint256 returnAmount = 0;

        if (realPayAmount < depositAmount) {
            returnAmount = depositAmount.sub(realPayAmount);
            realSaleAmount = calculSaleToken(realPayAmount);
        } else {
            realPayAmount = userOpen.depositAmount;
            realSaleAmount = calculSaleToken(depositAmount);
        }

        return (realPayAmount, realSaleAmount, returnAmount);
    }

    /// @inheritdoc IPublicSale
    function totalOpenSaleAmount() public override view returns (uint256){
        uint256 _calculSaleToken = calculSaleToken(totalDepositAmount);
        uint256 _totalAmount = totalExpectOpenSaleAmountView();

        if (_calculSaleToken < _totalAmount) return _calculSaleToken;
        else return _totalAmount;
    }

    /// @inheritdoc IPublicSale
    function totalOpenPurchasedAmount() public override view returns (uint256){
        uint256 _calculSaleToken = calculSaleToken(totalDepositAmount);
        uint256 _totalAmount = totalExpectOpenSaleAmountView();
        if (_calculSaleToken < _totalAmount) return totalDepositAmount;
        else return  calculPayToken(_totalAmount);
    }

    function totalWhitelists() external view returns (uint256) {
        return whitelists.length;
    }

    /// @inheritdoc IPublicSale
    function addWhiteList() external override nonReentrant {
        require(
            block.timestamp >= startAddWhiteTime,
            "PublicSale: whitelistStartTime has not passed"
        );
        require(
            block.timestamp < endAddWhiteTime,
            "PublicSale: end the whitelistTime"
        );
        uint256 tier = calculTier(msg.sender);
        require(tier >= 1, "PublicSale: need to more sTOS");
        LibPublicSale.UserInfoEx storage userEx = usersEx[msg.sender];
        require(userEx.join != true, "PublicSale: already attended");

        whitelists.push(msg.sender);

        userEx.join = true;
        userEx.tier = tier;
        userEx.saleAmount = 0;
        tiersAccount[tier] = tiersAccount[tier].add(1);

        emit AddedWhiteList(msg.sender, tier);
    }

    function _toWAD(uint256 v) public override pure returns (uint256) {
        return v / 10 ** 9;
    }

    function _decodeApproveData(
        bytes memory data
    ) public override pure returns (uint256 approveData) {
        assembly {
            approveData := mload(add(data, 0x20))
        }
    }

    function calculTONTransferAmount(
        uint256 _amount,
        address _sender
    )
        internal
        nonZero(_amount)
        nonZeroAddress(_sender)

    {
        uint256 tonAllowance = IERC20(getToken).allowance(_sender, address(this));
        uint256 tonBalance = IERC20(getToken).balanceOf(_sender);

        if (tonAllowance > tonBalance) {
            tonAllowance = tonBalance; //tonAllowance가 tonBlance보다 더 클때 문제가 된다.
        }
        if (tonAllowance < _amount) {
            uint256 needUserWton;
            uint256 needWton = _amount.sub(tonAllowance);
            needUserWton = _toRAY(needWton);
            require(IWTON(wton).allowance(_sender, address(this)) >= needUserWton, "PublicSale: wton exceeds allowance");
            require(IWTON(wton).balanceOf(_sender) >= needUserWton, "need more wton");
            IERC20(wton).safeTransferFrom(_sender,address(this),needUserWton);
            IWTON(wton).swapToTON(needUserWton);
            require(tonAllowance >= _amount.sub(needWton), "PublicSale: ton exceeds allowance");
            if (_amount.sub(needWton) > 0) {
                IERC20(getToken).safeTransferFrom(_sender, address(this), _amount.sub(needWton));
            }
        } else {
            require(tonAllowance >= _amount && tonBalance >= _amount, "PublicSale: ton exceeds allowance");
            IERC20(getToken).safeTransferFrom(_sender, address(this), _amount);
        }

        if (block.timestamp < endExclusiveTime) {
            emit ExclusiveSaled(_sender, _amount);
        } else {
            emit Deposited(_sender, _amount);
        }
    }


    /// @inheritdoc IPublicSale
    function exclusiveSale(
        address _sender,
        uint256 _amount
    )
        public
        override
        nonZero(_amount)
        nonZero(totalClaimCounts)
        nonReentrant
    {
        require(
            block.timestamp >= startExclusiveTime,
            "PublicSale: exclusiveStartTime has not passed"
        );
        require(
            block.timestamp < endExclusiveTime,
            "PublicSale: end the exclusiveTime"
        );
        LibPublicSale.UserInfoEx storage userEx = usersEx[_sender];
        require(userEx.join == true, "PublicSale: not registered in whitelist");
        uint256 tokenSaleAmount = calculSaleToken(_amount);
        uint256 salePossible = calculTierAmount(_sender);

        require(
            salePossible >= userEx.saleAmount.add(tokenSaleAmount),
            "PublicSale: just buy tier's allocated amount"
        );

        uint256 tier = calculTier(_sender);

        if(userEx.payAmount == 0) {
            totalRound1Users = totalRound1Users.add(1);
            totalUsers = totalUsers.add(1);
            tiersExAccount[tier] = tiersExAccount[tier].add(1);
        }

        userEx.payAmount = userEx.payAmount.add(_amount);
        userEx.saleAmount = userEx.saleAmount.add(tokenSaleAmount);

        totalExPurchasedAmount = totalExPurchasedAmount.add(_amount);
        totalExSaleAmount = totalExSaleAmount.add(tokenSaleAmount);

        calculTONTransferAmount(_amount, _sender);
    }

    /// @inheritdoc IPublicSale
    function deposit(
        address _sender,
        uint256 _amount
    )
        public
        override
        nonReentrant
    {
        require(
            block.timestamp >= startDepositTime,
            "PublicSale: don't start depositTime"
        );
        require(
            block.timestamp < endDepositTime,
            "PublicSale: end the depositTime"
        );

        LibPublicSale.UserInfoOpen storage userOpen = usersOpen[_sender];

        if (!userOpen.join) {
            depositors.push(_sender);
            userOpen.join = true;

            totalRound2Users = totalRound2Users.add(1);
            LibPublicSale.UserInfoEx storage userEx = usersEx[_sender];
            if (userEx.payAmount == 0) totalUsers = totalUsers.add(1);
        }
        userOpen.depositAmount = userOpen.depositAmount.add(_amount);
        totalDepositAmount = totalDepositAmount.add(_amount);

        calculTONTransferAmount(_amount, _sender);
    }

    /// @inheritdoc IPublicSale
    function claim() external override {
        require(
            block.timestamp >= claimTimes[0],
            "PublicSale: don't start claimTime"
        );
        LibPublicSale.UserInfoOpen storage userOpen = usersOpen[msg.sender];
        LibPublicSale.UserClaim storage userClaim = usersClaim[msg.sender];
        uint256 hardcapcut = hardcapCalcul();
        if (hardcapcut == 0) {
            require(userClaim.exec != true, "PublicSale: already getRefund");
            LibPublicSale.UserInfoEx storage userEx = usersEx[msg.sender];
            uint256 refundTON = userEx.payAmount.add(userOpen.depositAmount);
            userClaim.exec = true;
            IERC20(getToken).safeTransfer(msg.sender, refundTON);
        } else {
            (uint256 reward, uint256 realSaleAmount, uint256 refundAmount) = calculClaimAmount(msg.sender, 0);
            require(
                realSaleAmount > 0,
                "PublicSale: no purchase amount"
            );
            require(reward > 0, "PublicSale: no reward");
            require(
                realSaleAmount.sub(userClaim.claimAmount) >= reward,
                "PublicSale: already getAllreward"
            );
            require(
                saleToken.balanceOf(address(this)) >= reward,
                "PublicSale: dont have saleToken in pool"
            );

            userClaim.claimAmount = userClaim.claimAmount.add(reward);

            saleToken.safeTransfer(msg.sender, reward);

            if (!userClaim.exec && userOpen.join) {
                totalRound2UsersClaim = totalRound2UsersClaim.add(1);
                userClaim.exec = true;
            }

            if (refundAmount > 0 && userClaim.refundAmount == 0){
                require(refundAmount <= IERC20(getToken).balanceOf(address(this)), "PublicSale: dont have refund ton");
                userClaim.refundAmount = refundAmount;
                IERC20(getToken).safeTransfer(msg.sender, refundAmount);
            }

            emit Claimed(msg.sender, reward);
        }
    }

    function hardcapCalcul() public view returns (uint256){
        uint256 totalPurchaseTONamount = totalExPurchasedAmount.add(totalOpenPurchasedAmount());
        uint256 calculAmount;
        if (totalPurchaseTONamount >= hardCap) {
            return calculAmount = totalPurchaseTONamount.mul(changeTOS).div(100);
        } else {
            return 0;
        }
    }

    /// @inheritdoc IPublicSale
    function depositWithdraw() external override {
        require(block.timestamp > endDepositTime,"PublicSale: need to end the depositTime");
        uint256 liquidityTON = hardcapCalcul();
        uint256 getAmount;
        require(liquidityTON > 0, "PublicSale: don't pass the hardCap");
        require(adminWithdraw != true, "PublicSale: already get the TON");
        if (totalRound2Users == totalRound2UsersClaim){
            getAmount = IERC20(getToken).balanceOf(address(this)).sub(liquidityTON);
        } else {
            getAmount = totalExPurchasedAmount.add(totalOpenPurchasedAmount()).sub(liquidityTON).sub(2 ether);
        }
        require(getAmount <= IERC20(getToken).balanceOf(address(this)), "PublicSale: no token to receive");

        IWTON(wton).swapFromTON(liquidityTON);
        uint256 wtonAmount = IERC20(wton).balanceOf(address(this));

        ISwapRouter.ExactInputSingleParams memory params =
            ISwapRouter.ExactInputSingleParams({
                tokenIn: wton,
                tokenOut: address(tos),
                fee: poolFee,
                recipient: address(this),
                deadline: block.timestamp,
                amountIn: wtonAmount,
                amountOutMinimum: 0,
                sqrtPriceLimitX96: 0
            });
        ISwapRouter(uniswapRouter).exactInputSingle(params);

        uint256 burnAmount = totalExpectSaleAmount.add(totalExpectOpenSaleAmount).sub(totalOpenSaleAmount()).sub(totalExSaleAmount);

        uint256 tosAmount = tos.balanceOf(address(this));

        adminWithdraw = true;
        tos.safeTransfer(liquidityVaultAddress, tosAmount);
        IERC20(getToken).safeTransfer(getTokenOwner, getAmount);
        IIERC20Burnable(address(saleToken)).burn(burnAmount);
        emit DepositWithdrawal(msg.sender, getAmount, liquidityTON);
    }
}


// File contracts/sale/PublicSale2.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;
pragma abicoder v2;









interface IIUniswapV3Factory {
    function getPool(address,address,uint24) external view returns (address);
}

interface IIUniswapV3Pool {
    function token0() external view returns (address);
    function token1() external view returns (address);

    function slot0()
        external
        view
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        );

}

interface IIERC20Burnable {
    /**
     * @dev Destroys `amount` tokens from the caller.
     *
     * See {ERC20-_burn}.
     */
    function burn(uint256 amount) external ;
}

contract PublicSale2 is
    PublicSaleStorage,
    ProxyAccessCommon,
    ReentrancyGuard,
    IPublicSale
{
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    bool public exchangeTOS;

    event AddedWhiteList(address indexed from, uint256 tier);
    event ExclusiveSaled(address indexed from, uint256 amount);
    event Deposited(address indexed from, uint256 amount);

    event Claimed(address indexed from, uint256 amount);
    event Withdrawal(address indexed from, uint256 amount);
    event DepositWithdrawal(address indexed from, uint256 amount, uint256 liquidityAmount);

    modifier nonZero(uint256 _value) {
        require(_value > 0, "PublicSale: zero");
        _;
    }

    modifier nonZeroAddress(address _addr) {
        require(_addr != address(0), "PublicSale: zero address");
        _;
    }

    modifier beforeStartAddWhiteTime() {
        require(
            startAddWhiteTime == 0 ||
                (startAddWhiteTime > 0 && block.timestamp < startAddWhiteTime),
            "PublicSale: not beforeStartAddWhiteTime"
        );
        _;
    }

    modifier beforeEndAddWhiteTime() {
        require(
            endAddWhiteTime == 0 ||
                (endAddWhiteTime > 0 && block.timestamp < endAddWhiteTime),
            "PublicSale: not beforeEndAddWhiteTime"
        );
        _;
    }

    modifier greaterThan(uint256 _value1, uint256 _value2) {
        require(_value1 > _value2, "PublicSale: non greaterThan");
        _;
    }

    modifier lessThan(uint256 _value1, uint256 _value2) {
        require(_value1 < _value2, "PublicSale: non less than");
        _;
    }

    function changeTONOwner(
        address _address
    )
        external
        override
        onlyOwner
    {
        getTokenOwner = _address;
    }

    function setAllsetting(
        uint256[8] calldata _Tier,
        uint256[6] calldata _amount,
        uint256[8] calldata _time,
        uint256[] calldata _claimTimes,
        uint256[] calldata _claimPercents
    )
        external
        override
        onlyOwner
        beforeStartAddWhiteTime
    {
        uint256 balance = saleToken.balanceOf(address(this));
        require((_amount[0] + _amount[1]) <= balance && 1 ether <= balance, "amount err");
        require(_time[6] < _claimTimes[0], "time err");
        require((deployTime + delayTime) < _time[0], "snapshot need later");
        require(_time[0] < _time[1], "whitelist before snapshot");
        require(_claimTimes.length > 0 &&  _claimTimes.length == _claimPercents.length, "need the claimSet");
        
        if(snapshot != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }

        setTier(
            _Tier[0], _Tier[1], _Tier[2], _Tier[3]
        );
        setTierPercents(
            _Tier[4], _Tier[5], _Tier[6], _Tier[7]
        );
        setSaleAmount(
            _amount[0],
            _amount[1]
        );
        setTokenPrice(
            _amount[2],
            _amount[3]
        );
        setHardcap(
            _amount[4],
            _amount[5]
        );
        setSnapshot(_time[0]);
        setExclusiveTime(
            _time[1],
            _time[2],
            _time[3],
            _time[4]
        );
        setOpenTime(
            _time[5],
            _time[6]
        );
        setEachClaim(
            _time[7],
            _claimTimes,
            _claimPercents
        );
    }

    /// @inheritdoc IPublicSale
    function setSnapshot(
        uint256 _snapshot
    )
        public
        override
        onlyOwner
        nonZero(_snapshot)
        beforeStartAddWhiteTime
    {
        if(snapshot != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }

        snapshot = _snapshot;
    }

    /// @inheritdoc IPublicSale
    function setExclusiveTime(
        uint256 _startAddWhiteTime,
        uint256 _endAddWhiteTime,
        uint256 _startExclusiveTime,
        uint256 _endExclusiveTime
    )
        public
        override
        onlyOwner
        nonZero(_startAddWhiteTime)
        nonZero(_endAddWhiteTime)
        nonZero(_startExclusiveTime)
        nonZero(_endExclusiveTime)
        beforeStartAddWhiteTime
    {
        if(startAddWhiteTime != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }

        require(
            (_startAddWhiteTime < _endAddWhiteTime) &&
            (_endAddWhiteTime < _startExclusiveTime) &&
            (_startExclusiveTime < _endExclusiveTime),
            "PublicSale : Round1time err"
        );
        startAddWhiteTime = _startAddWhiteTime;
        endAddWhiteTime = _endAddWhiteTime;
        startExclusiveTime = _startExclusiveTime;
        endExclusiveTime = _endExclusiveTime;
    }

    /// @inheritdoc IPublicSale
    function setOpenTime(
        uint256 _startDepositTime,
        uint256 _endDepositTime
    )
        public
        override
        onlyOwner
        nonZero(_startDepositTime)
        nonZero(_endDepositTime)
        beforeStartAddWhiteTime
    {
        if(startDepositTime != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }

        require(
            (_startDepositTime < _endDepositTime),
            "PublicSale : Round2time err"
        );

        startDepositTime = _startDepositTime;
        endDepositTime = _endDepositTime;
    }

    function setEachClaim(
        uint256 _claimCounts,
        uint256[] calldata _claimTimes,
        uint256[] calldata _claimPercents
    )
        public
        override
        onlyOwner
        beforeStartAddWhiteTime
    {
        if(totalClaimCounts != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }
        
        totalClaimCounts = _claimCounts;
        uint256 i = 0;
        uint256 y = 0;
        for (i = 0; i < _claimCounts; i++) {
            claimTimes.push(_claimTimes[i]);
            if (i != 0){
                require(claimTimes[i-1] < claimTimes[i], "PublicSale: claimtime err");
            }
            y = y + _claimPercents[i];
            claimPercents.push(y);
        }

        require(y == 100, "claimPercents err");
    }

    /// @inheritdoc IPublicSale
    function setAllTier(
        uint256[4] calldata _tier,
        uint256[4] calldata _tierPercent
    ) external override onlyOwner {
        require(
            stanTier1 <= _tier[0] &&
            stanTier2 <= _tier[1] &&
            stanTier3 <= _tier[2] &&
            stanTier4 <= _tier[3],
            "tier set error"
        );
        setTier(
            _tier[0],
            _tier[1],
            _tier[2],
            _tier[3]
        );
        setTierPercents(
            _tierPercent[0],
            _tierPercent[1],
            _tierPercent[2],
            _tierPercent[3]
        );
    }

    /// @inheritdoc IPublicSale
    function setTier(
        uint256 _tier1,
        uint256 _tier2,
        uint256 _tier3,
        uint256 _tier4
    )
        public
        override
        onlyOwner
        nonZero(_tier1)
        nonZero(_tier2)
        nonZero(_tier3)
        nonZero(_tier4)
        beforeStartAddWhiteTime
    {
        if(tiers[1] != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }
        tiers[1] = _tier1;
        tiers[2] = _tier2;
        tiers[3] = _tier3;
        tiers[4] = _tier4;
    }

    /// @inheritdoc IPublicSale
    function setTierPercents(
        uint256 _tier1,
        uint256 _tier2,
        uint256 _tier3,
        uint256 _tier4
    )
        public
        override
        onlyOwner
        nonZero(_tier1)
        nonZero(_tier2)
        nonZero(_tier3)
        nonZero(_tier4)
        beforeStartAddWhiteTime
    {
        if(tiersPercents[1] != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }
        require(
            _tier1.add(_tier2).add(_tier3).add(_tier4) == 10000,
            "PublicSale: Sum should be 10000"
        );
        tiersPercents[1] = _tier1;
        tiersPercents[2] = _tier2;
        tiersPercents[3] = _tier3;
        tiersPercents[4] = _tier4;
    }

    /// @inheritdoc IPublicSale
    function setAllAmount(
        uint256[2] calldata _expectAmount,
        uint256[2] calldata _priceAmount
    ) external override onlyOwner {
        setSaleAmount(
            _expectAmount[0],
            _expectAmount[1]
        );
        setTokenPrice(
            _priceAmount[0],
            _priceAmount[1]
        );
    }

    /// @inheritdoc IPublicSale
    function setSaleAmount(
        uint256 _totalExpectSaleAmount,
        uint256 _totalExpectOpenSaleAmount
    )
        public
        override
        onlyOwner
        nonZero(_totalExpectSaleAmount)
        beforeStartAddWhiteTime
    {
        if(totalExpectSaleAmount != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }
        totalExpectSaleAmount = _totalExpectSaleAmount;
        totalExpectOpenSaleAmount = _totalExpectOpenSaleAmount;
    }

    /// @inheritdoc IPublicSale
    function setTokenPrice(
        uint256 _saleTokenPrice,
        uint256 _payTokenPrice
    )
        public
        override
        onlyOwner
        nonZero(_saleTokenPrice)
        nonZero(_payTokenPrice)
        beforeStartAddWhiteTime
    {
        if(saleTokenPrice != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }
        saleTokenPrice = _saleTokenPrice;
        payTokenPrice = _payTokenPrice;
    }

    function setHardcap (
        uint256 _hardcapAmount,
        uint256 _changePercent
    )
        public
        override
        onlyOwner
        nonZero(_changePercent)
        beforeStartAddWhiteTime
    {
        if(changeTOS != 0) {
            require(isProxyAdmin(msg.sender), "only DAO can set");
        }
        require(_changePercent <= maxPer && _changePercent >= minPer,"PublicSale: need to set min,max");
        hardCap = _hardcapAmount;
        changeTOS = _changePercent;
    }

    function distributionByRounds(
        uint256 startRound,
        uint256 endRound
    ) 
        public
        view
        returns(uint256[] memory)
    {   
        if(startRound == 0) {
            startRound = 1;
        }
        if(totalClaimCounts < startRound) {
            startRound = totalClaimCounts;
        }
        if(endRound < startRound) {
            endRound = startRound;
        }
        if(totalClaimCounts < endRound || endRound == 0) {
            endRound = totalClaimCounts;
        }

        uint length = endRound.sub(startRound.sub(1));
        uint256[] memory claims = new uint256[](length);
        uint256 subClaimPercent = claimPercents[(endRound-1)].sub(claimPercents[(startRound-1)]);
        if(block.timestamp > endExclusiveTime && startRound != 0 ) {
            for(uint256 i = 0; i < length; i++) {
                // 실제판매량들 실제판매 시간 이후 계산
                // uint256 amount = (((totalExSaleAmount.add(totalOpenSaleAmount())).mul(claimPercents[startRound.add(i).sub(1)])).div(100));
                if(i > 1) {
                    subClaimPercent = claimPercents[(i-1)].sub(claimPercents[(i-2)]);
                } else {
                    subClaimPercent = claimPercents[(i-1)];
                }
                uint256 amount = (((totalExSaleAmount.add(totalOpenSaleAmount())).mul(subClaimPercent)).div(100));
                claims[i] = amount;
            }
        } else {
            for(uint256 i = 0; i < length; i++) {
                // 판매 예정값들 아직 판매시간 안되었을때 계산
                // uint256 amount = (((totalExpectSaleAmount.add(totalExpectOpenSaleAmount)).mul(claimPercents[startRound.add(i).sub(1)])).div(100));
                 if(i > 1) {
                    subClaimPercent = claimPercents[(i-1)].sub(claimPercents[(i-2)]);
                } else {
                    subClaimPercent = claimPercents[(i-1)];
                }
                uint256 amount = (((totalExpectSaleAmount.add(totalExpectOpenSaleAmount)).mul(subClaimPercent)).div(100));
                claims[i] = amount;
            }
        }
        return claims;
    }

    function distributionByRound(
        uint256 _round
    )
        public
        view
        returns(uint256)
    {
        if(block.timestamp > endExclusiveTime && _round != 0) {
            // return (((totalExSaleAmount.add(totalOpenSaleAmount())).mul(claimPercents[(_round-1)])).div(100));
            if(_round == 1) {
                return (((totalExSaleAmount.add(totalOpenSaleAmount())).mul(claimPercents[(_round-1)])).div(100));
            } else {
                uint256 subClaimPercent = claimPercents[(_round-1)].sub(claimPercents[(_round-2)]);
                return (((totalExSaleAmount.add(totalOpenSaleAmount())).mul(subClaimPercent)).div(100));
            }
        } else {
            return 0;
        }
    }

    /// @inheritdoc IPublicSale
    //1라운드에서 미판매된 물량 + 2라운드 판매에 정해진 물량
    function totalExpectOpenSaleAmountView()
        public
        view
        override
        returns(uint256)
    {
        if (block.timestamp < endExclusiveTime) return totalExpectOpenSaleAmount;
        else return totalExpectOpenSaleAmount.add(totalRound1NonSaleAmount());
    }

    /// @inheritdoc IPublicSale
    function totalRound1NonSaleAmount()
        public
        view
        override
        returns(uint256)
    {
        return totalExpectSaleAmount.sub(totalExSaleAmount);
    }


    function _toRAY(uint256 v) internal pure returns (uint256) {
        return v * 10 ** 9;
    }

    /// @inheritdoc IPublicSale
    function calculSaleToken(uint256 _amount)
        public
        view
        override
        returns (uint256)
    {
        uint256 tokenSaleAmount =
            _amount.mul(payTokenPrice).div(saleTokenPrice);
        return tokenSaleAmount;
    }

    /// @inheritdoc IPublicSale
    function calculPayToken(uint256 _amount)
        public
        view
        override
        returns (uint256)
    {
        uint256 tokenPayAmount = _amount.mul(saleTokenPrice).div(payTokenPrice);
        return tokenPayAmount;
    }

    /// @inheritdoc IPublicSale
    function calculTier(address _address)
        public
        view
        override
        nonZeroAddress(address(sTOS))
        nonZero(tiers[1])
        nonZero(tiers[2])
        nonZero(tiers[3])
        nonZero(tiers[4])
        returns (uint256)
    {
        uint256 sTOSBalance = sTOS.balanceOfAt(_address, snapshot);
        uint256 tier;
        if (sTOSBalance >= tiers[1] && sTOSBalance < tiers[2]) {
            tier = 1;
        } else if (sTOSBalance >= tiers[2] && sTOSBalance < tiers[3]) {
            tier = 2;
        } else if (sTOSBalance >= tiers[3] && sTOSBalance < tiers[4]) {
            tier = 3;
        } else if (sTOSBalance >= tiers[4]) {
            tier = 4;
        } else if (sTOSBalance < tiers[1]) {
            tier = 0;
        }
        return tier;
    }

    /// @inheritdoc IPublicSale
    function calculTierAmount(address _address)
        public
        view
        override
        returns (uint256)
    {
        LibPublicSale.UserInfoEx storage userEx = usersEx[_address];
        uint256 tier = calculTier(_address);
        if (userEx.join == true && tier > 0) {
            uint256 salePossible =
                totalExpectSaleAmount
                    .mul(tiersPercents[tier])
                    .div(tiersAccount[tier])
                    .div(10000);
            return salePossible;
        } else if (tier > 0) {
            uint256 tierAccount = tiersAccount[tier].add(1);
            uint256 salePossible =
                totalExpectSaleAmount
                    .mul(tiersPercents[tier])
                    .div(tierAccount)
                    .div(10000);
            return salePossible;
        } else {
            return 0;
        }
    }

    /// @inheritdoc IPublicSale
    function calculOpenSaleAmount(address _account, uint256 _amount)
        public
        view
        override
        returns (uint256)
    {
        LibPublicSale.UserInfoOpen storage userOpen = usersOpen[_account];
        uint256 depositAmount = userOpen.depositAmount.add(_amount);
        uint256 openSalePossible =
            totalExpectOpenSaleAmountView().mul(depositAmount).div(
                totalDepositAmount.add(_amount)
            );
        return openSalePossible;
    }

    function currentRound() public view returns (uint256 round) {
        if (block.timestamp > claimTimes[totalClaimCounts-1]) {
            return totalClaimCounts;
        }
        for (uint256 i = 0; i < totalClaimCounts; i++) {
            if (block.timestamp < claimTimes[i]) {
                return i;
            }
        }
    }

    function calculClaimAmount(address _account, uint256 _round)
        public
        view
        override
        returns (uint256 _reward, uint256 _totalClaim, uint256 _refundAmount)
    {
        if (block.timestamp < startClaimTime) return (0, 0, 0);
        if (_round > totalClaimCounts) return (0, 0, 0);

        LibPublicSale.UserClaim storage userClaim = usersClaim[_account];
        (, uint256 realSaleAmount, uint256 refundAmount) = totalSaleUserAmount(_account);   //유저가 총 구매한 token의 양을 Return 함

        if (realSaleAmount == 0 ) return (0, 0, 0);
        if (userClaim.claimAmount >= realSaleAmount) return (0, 0, 0);    //userClaim.claimAmount  = contract에서 유저에게 준양

        uint256 round = currentRound();

        uint256 amount;
        if (totalClaimCounts == round && _round == 0) {
            amount = realSaleAmount - userClaim.claimAmount;
            return (amount, realSaleAmount, refundAmount);
        }

        //해당 라운드에서 받아야하는 토큰의 양 -> (realSaleAmount * claimPercents[i] / 100) : 해당 라운드에서 받아야하는 토큰의 양
        //Round를 0으로 넣으면 현재 내가 받을 수 있는 양을 리턴해주고 1 이상을 넣으면 해당 라운드에서 받을 수 있는 토큰의 양을 리턴해줌
        if(_round == 0) {
            amount = realSaleAmount.mul(claimPercents[round.sub(1)]).div(100);
            amount = amount - userClaim.claimAmount;
            return (amount, realSaleAmount, refundAmount);
        } else if(_round == 1) {
            amount = realSaleAmount.mul(claimPercents[round.sub(1)]).div(100);
            return (amount, realSaleAmount, refundAmount);
        } else {
            uint256 amount1 = realSaleAmount.mul(claimPercents[round.sub(1)]).div(100);
            uint256 amount2 = realSaleAmount.mul(claimPercents[round.sub(2)]).div(100);
            amount = amount1.sub(amount2);
            return (amount, realSaleAmount, refundAmount);
        }
    }

    /// @inheritdoc IPublicSale
    function totalSaleUserAmount(address user) public override view returns (uint256 _realPayAmount, uint256 _realSaleAmount, uint256 _refundAmount) {
        LibPublicSale.UserInfoEx storage userEx = usersEx[user];

        if (userEx.join) {
            (uint256 realPayAmount, uint256 realSaleAmount, uint256 refundAmount) = openSaleUserAmount(user);
            return ( realPayAmount.add(userEx.payAmount), realSaleAmount.add(userEx.saleAmount), refundAmount);
        } else {
            return openSaleUserAmount(user);
        }
    }

    /// @inheritdoc IPublicSale
    function openSaleUserAmount(address user) public override view returns (uint256 _realPayAmount, uint256 _realSaleAmount, uint256 _refundAmount) {
        LibPublicSale.UserInfoOpen storage userOpen = usersOpen[user];

        if (!userOpen.join || userOpen.depositAmount == 0) return (0, 0, 0);

        uint256 openSalePossible = calculOpenSaleAmount(user, 0);
        uint256 realPayAmount = calculPayToken(openSalePossible);
        uint256 depositAmount = userOpen.depositAmount;
        uint256 realSaleAmount = 0;
        uint256 returnAmount = 0;

        if (realPayAmount < depositAmount) {
            returnAmount = depositAmount.sub(realPayAmount);
            realSaleAmount = calculSaleToken(realPayAmount);
        } else {
            realPayAmount = userOpen.depositAmount;
            realSaleAmount = calculSaleToken(depositAmount);
        }

        return (realPayAmount, realSaleAmount, returnAmount);
    }

    /// @inheritdoc IPublicSale
    function totalOpenSaleAmount() public override view returns (uint256){
        uint256 _calculSaleToken = calculSaleToken(totalDepositAmount);
        uint256 _totalAmount = totalExpectOpenSaleAmountView();

        if (_calculSaleToken < _totalAmount) return _calculSaleToken;
        else return _totalAmount;
    }

    /// @inheritdoc IPublicSale
    //2라운드에서 판매로 이용된 TON양
    function totalOpenPurchasedAmount() public override view returns (uint256){
        //2라운드 총 입금된 양을 판매토큰 수량으로 변경 (1)
        uint256 _calculSaleToken = calculSaleToken(totalDepositAmount);
        //2라운드 총 판매 토큰 수량 (2)
        uint256 _totalAmount = totalExpectOpenSaleAmountView();
        // (1)이 (2)보다 작으면 2라운드 판매량이 100%가 아님 -> 판매량은 그래도 입금된 양이됨
        // (1)이 (2)보다 크면 2라운드 판매량이 100%를 넘었음 -> 판매량은 2라운드 판매 토큰 수량이 됨
        if (_calculSaleToken < _totalAmount) return totalDepositAmount;
        else return  calculPayToken(_totalAmount);
    }

    function totalWhitelists() external view returns (uint256) {
        return whitelists.length;
    }

    /// @inheritdoc IPublicSale
    function addWhiteList() external override nonReentrant {
        require(
            block.timestamp >= startAddWhiteTime,
            "PublicSale: whitelistStartTime has not passed"
        );
        require(
            block.timestamp < endAddWhiteTime,
            "PublicSale: end the whitelistTime"
        );
        uint256 tier = calculTier(msg.sender);
        require(tier >= 1, "PublicSale: need to more sTOS");
        LibPublicSale.UserInfoEx storage userEx = usersEx[msg.sender];
        require(userEx.join != true, "PublicSale: already attended");

        whitelists.push(msg.sender);

        userEx.join = true;
        userEx.tier = tier;
        userEx.saleAmount = 0;
        tiersAccount[tier] = tiersAccount[tier].add(1);

        emit AddedWhiteList(msg.sender, tier);
    }

    function _toWAD(uint256 v) public override pure returns (uint256) {
        return v / 10 ** 9;
    }

    function _decodeApproveData(
        bytes memory data
    ) public override pure returns (uint256 approveData) {
        assembly {
            approveData := mload(add(data, 0x20))
        }
    }

    function calculTONTransferAmount(
        uint256 _amount,
        address _sender
    )
        internal
        nonZero(_amount)
        nonZeroAddress(_sender)

    {
        uint256 tonAllowance = IERC20(getToken).allowance(_sender, address(this));
        uint256 tonBalance = IERC20(getToken).balanceOf(_sender);

        if (tonAllowance > tonBalance) {
            tonAllowance = tonBalance; //tonAllowance가 tonBlance보다 더 클때 문제가 된다.
        }
        if (tonAllowance < _amount) {
            uint256 needUserWton;
            uint256 needWton = _amount.sub(tonAllowance);
            needUserWton = _toRAY(needWton);
            require(IWTON(wton).allowance(_sender, address(this)) >= needUserWton, "PublicSale: wton exceeds allowance");
            require(IWTON(wton).balanceOf(_sender) >= needUserWton, "need more wton");
            IERC20(wton).safeTransferFrom(_sender,address(this),needUserWton);
            IWTON(wton).swapToTON(needUserWton);
            require(tonAllowance >= _amount.sub(needWton), "PublicSale: ton exceeds allowance");
            if (_amount.sub(needWton) > 0) {
                IERC20(getToken).safeTransferFrom(_sender, address(this), _amount.sub(needWton));
            }
        } else {
            require(tonAllowance >= _amount && tonBalance >= _amount, "PublicSale: ton exceeds allowance");
            IERC20(getToken).safeTransferFrom(_sender, address(this), _amount);
        }

        if (block.timestamp < endExclusiveTime) {
            emit ExclusiveSaled(_sender, _amount);
        } else {
            emit Deposited(_sender, _amount);
        }
    }


    /// @inheritdoc IPublicSale
    function exclusiveSale(
        address _sender,
        uint256 _amount
    )
        public
        override
        nonZero(_amount)
        nonZero(totalClaimCounts)
        nonReentrant
    {
        require(
            block.timestamp >= startExclusiveTime,
            "PublicSale: exclusiveStartTime has not passed"
        );
        require(
            block.timestamp < endExclusiveTime,
            "PublicSale: end the exclusiveTime"
        );
        LibPublicSale.UserInfoEx storage userEx = usersEx[_sender];
        require(userEx.join == true, "PublicSale: not registered in whitelist");
        uint256 tokenSaleAmount = calculSaleToken(_amount);
        uint256 salePossible = calculTierAmount(_sender);

        require(
            salePossible >= userEx.saleAmount.add(tokenSaleAmount),
            "PublicSale: just buy tier's allocated amount"
        );

        uint256 tier = calculTier(_sender);

        if(userEx.payAmount == 0) {
            totalRound1Users = totalRound1Users.add(1);
            totalUsers = totalUsers.add(1);
            tiersExAccount[tier] = tiersExAccount[tier].add(1);
        }

        userEx.payAmount = userEx.payAmount.add(_amount);
        userEx.saleAmount = userEx.saleAmount.add(tokenSaleAmount);

        totalExPurchasedAmount = totalExPurchasedAmount.add(_amount);
        totalExSaleAmount = totalExSaleAmount.add(tokenSaleAmount);

        calculTONTransferAmount(_amount, _sender);
    }

    /// @inheritdoc IPublicSale
    function deposit(
        address _sender,
        uint256 _amount
    )
        public
        override
        nonReentrant
    {
        require(
            block.timestamp >= startDepositTime,
            "PublicSale: don't start depositTime"
        );
        require(
            block.timestamp < endDepositTime,
            "PublicSale: end the depositTime"
        );

        LibPublicSale.UserInfoOpen storage userOpen = usersOpen[_sender];

        if (!userOpen.join) {
            depositors.push(_sender);
            userOpen.join = true;

            totalRound2Users = totalRound2Users.add(1);
            LibPublicSale.UserInfoEx storage userEx = usersEx[_sender];
            if (userEx.payAmount == 0) totalUsers = totalUsers.add(1);
        }
        userOpen.depositAmount = userOpen.depositAmount.add(_amount);
        totalDepositAmount = totalDepositAmount.add(_amount);

        calculTONTransferAmount(_amount, _sender);
    }

    /// @inheritdoc IPublicSale
    function claim() external override {
        require(
            block.timestamp >= claimTimes[0],
            "PublicSale: don't start claimTime"
        );
        LibPublicSale.UserInfoOpen storage userOpen = usersOpen[msg.sender];
        LibPublicSale.UserClaim storage userClaim = usersClaim[msg.sender];
        uint256 hardcapcut = hardcapCalcul();
        if (hardcapcut == 0) {
            require(userClaim.exec != true, "PublicSale: already getRefund");
            LibPublicSale.UserInfoEx storage userEx = usersEx[msg.sender];
            uint256 refundTON = userEx.payAmount.add(userOpen.depositAmount);
            userClaim.exec = true;
            IERC20(getToken).safeTransfer(msg.sender, refundTON);
        } else {
            (uint256 reward, uint256 realSaleAmount, uint256 refundAmount) = calculClaimAmount(msg.sender, 0);
            require(
                realSaleAmount > 0,
                "PublicSale: no purchase amount"
            );
            require(reward > 0, "PublicSale: no reward");
            require(
                realSaleAmount.sub(userClaim.claimAmount) >= reward,
                "PublicSale: already getAllreward"
            );
            require(
                saleToken.balanceOf(address(this)) >= reward,
                "PublicSale: dont have saleToken in pool"
            );

            userClaim.claimAmount = userClaim.claimAmount.add(reward);

            saleToken.safeTransfer(msg.sender, reward);

            if (!userClaim.exec && userOpen.join) {
                totalRound2UsersClaim = totalRound2UsersClaim.add(1);
                userClaim.exec = true;
            }

            if (refundAmount > 0 && userClaim.refundAmount == 0){
                require(refundAmount <= IERC20(getToken).balanceOf(address(this)), "PublicSale: dont have refund ton");
                userClaim.refundAmount = refundAmount;
                IERC20(getToken).safeTransfer(msg.sender, refundAmount);
            }

            emit Claimed(msg.sender, reward);
        }
    }

    function hardcapCalcul() public view returns (uint256){
        //1차 2차 라운드에서 토큰판매에 대한 TON양
        uint256 totalPurchaseTONamount = totalExPurchasedAmount.add(totalOpenPurchasedAmount());
        uint256 calculAmount;
        if (totalPurchaseTONamount >= hardCap) {
            //토큰판매에 대한 TON양 중 TOS로 변경해야할 TON양을 리턴함
            return calculAmount = totalPurchaseTONamount.mul(changeTOS).div(100);
        } else {
            return 0;
        }
    }

    /// @inheritdoc IPublicSale
    //TON보상 중 liquidityVault로 가야하는 수량의 TON이 다 옮겨지고 난 후에 이걸 실행해서 TON분배 Vault로 TON을 이동
    function depositWithdraw() external override {
        require(block.timestamp > endDepositTime,"PublicSale: need to end the depositTime");
        uint256 liquidityTON = hardcapCalcul();
        uint256 getAmount;
        require(liquidityTON > 0, "PublicSale: don't pass the hardCap");
        require(adminWithdraw != true, "PublicSale: already get the TON");
        if (totalRound2Users == totalRound2UsersClaim){
            getAmount = IERC20(getToken).balanceOf(address(this)).sub(liquidityTON);
        } else {
            getAmount = totalExPurchasedAmount.add(totalOpenPurchasedAmount()).sub(liquidityTON).sub(2 ether);
        }
        require(getAmount <= IERC20(getToken).balanceOf(address(this)), "PublicSale: no token to receive");

        IWTON(wton).swapFromTON(liquidityTON);
        uint256 wtonAmount = IERC20(wton).balanceOf(address(this));

        ISwapRouter.ExactInputSingleParams memory params =
            ISwapRouter.ExactInputSingleParams({
                tokenIn: wton,
                tokenOut: address(tos),
                fee: poolFee,
                recipient: address(this),
                deadline: block.timestamp,
                amountIn: wtonAmount,
                amountOutMinimum: 0,
                sqrtPriceLimitX96: 0
            });
        ISwapRouter(uniswapRouter).exactInputSingle(params);

        uint256 burnAmount = totalExpectSaleAmount.add(totalExpectOpenSaleAmount).sub(totalOpenSaleAmount()).sub(totalExSaleAmount);

        uint256 tosAmount = tos.balanceOf(address(this));

        adminWithdraw = true;
        tos.safeTransfer(liquidityVaultAddress, tosAmount);
        IERC20(getToken).safeTransfer(getTokenOwner, getAmount);
        IIERC20Burnable(address(saleToken)).burn(burnAmount);
        emit DepositWithdrawal(msg.sender, getAmount, liquidityTON);
    }

    function tonWithdraw() external {
        // uint256 wtonAmount = IERC20(wton).balanceOf(address(this));
        require(adminWithdraw != true && exchangeTOS == true,"PublicSale : need the exchangeWTONtoTOS");

        uint256 getAmount;
        uint256 liquidityTON = hardcapCalcul();
        if (totalRound2Users == totalRound2UsersClaim){
            getAmount = IERC20(getToken).balanceOf(address(this)).sub(liquidityTON);
        } else {
            getAmount = totalExPurchasedAmount.add(totalOpenPurchasedAmount()).sub(liquidityTON).sub(2 ether);
        }        
        require(getAmount <= IERC20(getToken).balanceOf(address(this)), "PublicSale: no token to receive");
        
        adminWithdraw = true;
        IERC20(getToken).safeTransfer(getTokenOwner, getAmount);
    }

    //판매 후 TON밖에 없으니까 TON을 WTON으로 바꿔줌
    //최초 실행 분기점은 WTON 유무로 판별 가능함
    //amountIn은 wton의 수량이다.
    function exchangeWTONtoTOS(
        uint256 amountIn
    ) external {
        require(amountIn > 0, "zero input amount");
        require(block.timestamp > endDepositTime,"PublicSale: need to end the depositTime");

        //hardCap이 넘었는지 확인
        uint256 liquidityTON = hardcapCalcul();
        require(liquidityTON > 0, "PublicSale: don't pass the hardCap");

        IIUniswapV3Pool pool = IIUniswapV3Pool(getPoolAddress());
        require(address(pool) != address(0), "pool didn't exist");

        (uint160 sqrtPriceX96, int24 tick,,,,,) =  pool.slot0();
        require(sqrtPriceX96 > 0, "pool is not initialized");

        // uint24 fee = 3000;
        // int24 tickSpacings = 60;
        // int24 acceptTickChangeInterval = 8; +=5% 까지만 허용
        // minimumTickInterval = 18; 가격이 떨어져도 +-10프로, 수수료가 있어서 2틱정도 더내림
        int24 timeWeightedAverageTick = OracleLibrary.consult(address(pool), 120);
        require(
            acceptMinTick(timeWeightedAverageTick, 60, 8) <= tick
            && tick < acceptMaxTick(timeWeightedAverageTick, 60, 8),
            "It's not allowed changed tick range."
        );

        (uint256 amountOutMinimum, , uint160 sqrtPriceLimitX96)
            = limitPrameters(amountIn, address(pool), wton, address(saleToken), 18);

        // 초기 한번만 ton을 wton으로 변경한다.
        uint256 wtonAmount = IERC20(wton).balanceOf(address(this));
        require(wtonAmount >= amountIn, "PublicSale : amountIn is too large");
        //wton이 없으면 ton을 변경한적이 없다는 가정하에 변경
        if(wtonAmount == 0) {
            IWTON(wton).swapFromTON(liquidityTON);
            exchangeTOS = true;
        }

        //변경 뒤 입력한 amount만큼 스왑해줌
        ISwapRouter.ExactInputSingleParams memory params =
            ISwapRouter.ExactInputSingleParams({
                tokenIn: wton,
                tokenOut: address(tos),
                fee: poolFee,
                recipient: address(this),
                deadline: block.timestamp + 100,
                amountIn: amountIn,
                amountOutMinimum: amountOutMinimum,
                sqrtPriceLimitX96: sqrtPriceLimitX96
            });
        uint256 amountOut = ISwapRouter(uniswapRouter).exactInputSingle(params);

        // uint256 tosAmount = tos.balanceOf(address(this));
        tos.safeTransfer(liquidityVaultAddress, amountOut);
    }

    function getQuoteAtTick(
        int24 tick,
        uint128 amountIn,
        address baseToken,
        address quoteToken
    ) public pure returns (uint256 amountOut) {
        return OracleLibrary.getQuoteAtTick(tick, amountIn, baseToken, quoteToken);
    }

    function getPoolAddress() public view returns(address) {
        address factory = 0x1F98431c8aD98523631AE4a59f267346ea31F984;
        return IIUniswapV3Factory(factory).getPool(wton, address(tos), 3000);
    }

    function getMiniTick(int24 tickSpacings) public pure returns (int24){
        return (TickMath.MIN_TICK / tickSpacings) * tickSpacings ;
    }

    function getMaxTick(int24 tickSpacings) public pure  returns (int24){
        return (TickMath.MAX_TICK / tickSpacings) * tickSpacings ;
    }

    function acceptMinTick(int24 _tick, int24 _tickSpacings, int24 _acceptTickInterval) public pure returns (int24) {
        int24 _minTick = getMiniTick(_tickSpacings);
        int24 _acceptMinTick = _tick - (_tickSpacings * _acceptTickInterval);

        if(_minTick < _acceptMinTick) return _acceptMinTick;
        else return _minTick;
    }

    function acceptMaxTick(int24 _tick, int24 _tickSpacings, int24 _acceptTickInterval) public pure returns (int24) {
        int24 _maxTick = getMaxTick(_tickSpacings);
        int24 _acceptMinTick = _tick + (_tickSpacings * _acceptTickInterval);

        if(_maxTick < _acceptMinTick) return _maxTick;
        else return _acceptMinTick;
    }
    
    function limitPrameters(
        uint256 amountIn,
        address _pool,
        address token0,
        address token1,
        int24 acceptTickCounts
    ) public view returns  (uint256 amountOutMinimum, uint256 priceLimit, uint160 sqrtPriceX96Limit) {
        IIUniswapV3Pool pool = IIUniswapV3Pool(_pool);
        (, int24 tick,,,,,) =  pool.slot0();

        int24 _tick = tick;
        if(token0 < token1) {
            _tick = tick - acceptTickCounts * 60;
            if(_tick < TickMath.MIN_TICK ) _tick =  TickMath.MIN_TICK ;
        } else {
            _tick = tick + acceptTickCounts * 60;
            if(_tick > TickMath.MAX_TICK ) _tick =  TickMath.MAX_TICK ;
        }
        address token1_ = token1;
        address token0_ = token0;
        return (
              getQuoteAtTick(
                _tick,
                uint128(amountIn),
                token0_,
                token1_
                ),
             getQuoteAtTick(
                _tick,
                uint128(10**27),
                token0_,
                token1_
             ),
             TickMath.getSqrtRatioAtTick(_tick)
        );
    }
}


// File contracts/sale/PublicSaleTest.sol

// SPDX-License-Identifier: MIT

pragma solidity ^0.7.6;

contract PublicSaleTest is
    PublicSale
{
    function resetAllData() external onlyOwner {
        startAddWhiteTime = 0;
        totalExSaleAmount = 0;
        totalExPurchasedAmount = 0;
        totalDepositAmount = 0;
        totalUsers = 0;
        totalRound1Users = 0;
        totalRound2Users = 0;
        totalRound2UsersClaim = 0;

        for (uint256 i = 0; i < whitelists.length; i++) {
            LibPublicSale.UserInfoEx storage userEx = usersEx[whitelists[i]];
            userEx.join = false;
            userEx.payAmount = 0;
            userEx.saleAmount = 0;
            LibPublicSale.UserClaim storage userClaim = usersClaim[whitelists[i]];
            userClaim.claimAmount = 0;
            userClaim.refundAmount = 0;
            userClaim.exec = false;
        }
        for (uint256 j = 0; j < depositors.length; j++) {
            LibPublicSale.UserInfoOpen storage userOpen = usersOpen[depositors[j]];
            userOpen.depositAmount = 0;
            userOpen.join = false;
            userOpen.payAmount = 0;
            LibPublicSale.UserClaim storage userClaim = usersClaim[depositors[j]];
            userClaim.claimAmount = 0;
            userClaim.refundAmount = 0;
            userClaim.exec = false;
        }
        for (uint256 k = 1; k < 5; k++) {
            tiersAccount[k] = 0;
            tiersExAccount[k] = 0;
        }
        delete whitelists;
    }
}


// File contracts/stake/LockTOSStorage.sol

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

contract LockTOSStorage {
    /// @dev flag for pause proxy
    bool public pauseProxy;

    /// @dev registry
    address public stakeRegistry;
    bool public migratedL2;

    uint256 public epochUnit;
    uint256 public maxTime;

    uint256 public constant MULTIPLIER = 1e18;

    address public tos;
    uint256 public lockIdCounter;
    uint256 public cumulativeEpochUnit;
    uint256 public cumulativeTOSAmount;

    uint256 internal free = 1;

    address[] public uniqueUsers;
    LibLockTOS.Point[] public pointHistory;
    mapping(uint256 => LibLockTOS.Point[]) public lockPointHistory;
    mapping(address => mapping(uint256 => LibLockTOS.LockedBalance))
        public lockedBalances;

    mapping(uint256 => LibLockTOS.LockedBalance) public allLocks;
    mapping(address => uint256[]) public userLocks;
    mapping(uint256 => int256) public slopeChanges;
    mapping(uint256 => bool) public inUse;
}


// File contracts/stake/LockTOS.sol

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;
pragma abicoder v2;










contract LockTOS is LockTOSStorage, AccessibleCommon, ILockTOS {
    using SafeMath for uint256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    event LockCreated(
        address account,
        uint256 lockId,
        uint256 value,
        uint256 unlockTime
    );
    event LockAmountIncreased(address account, uint256 lockId, uint256 value);
    event LockUnlockTimeIncreased(
        address account,
        uint256 lockId,
        uint256 unlockTime
    );
    event LockDeposited(address account, uint256 lockId, uint256 value);
    event LockWithdrawn(address account, uint256 lockId, uint256 value);

    /// @dev Check if a function is used or not
    modifier ifFree {
        require(free == 1, "LockId is already in use");
        free = 0;
        _;
        free = 1;
    }

    /// @inheritdoc ILockTOS
    function needCheckpoint() external override view returns (bool need) {
        uint256 len = pointHistory.length;
        if (len == 0) {
            return true;
        }
        need = (block.timestamp - pointHistory[len - 1].timestamp) > epochUnit; // if the last record was within a week
    }

    /// @inheritdoc ILockTOS
    function setMaxTime(uint256 _maxTime) external override onlyOwner {
        maxTime = _maxTime;
    }

    /// @inheritdoc ILockTOS
    function increaseAmount(uint256 _lockId, uint256 _value) external override {
        depositFor(msg.sender, _lockId, _value);
    }

    /// @inheritdoc ILockTOS
    function allHolders() external override view returns (address[] memory) {
        return uniqueUsers;
    }

    /// @inheritdoc ILockTOS
    function activeHolders() external override view returns (address[] memory) {
        bool[] memory activeCheck = new bool[](uniqueUsers.length);
        uint256 activeSize = 0;
        for (uint256 i = 0; i < uniqueUsers.length; ++i) {
            uint256[] memory activeLocks = activeLocksOf(uniqueUsers[i]);
            if (activeLocks.length > 0) {
                activeSize++;
                activeCheck[i] = true;
            }
        }

        address[] memory activeUsers = new address[](activeSize);
        uint256 j = 0;
        for (uint256 i = 0; i < uniqueUsers.length; ++i) {
            if (activeCheck[i]) {
                activeUsers[j++] = uniqueUsers[i];
            }
        }
        return activeUsers;
    }

    /// @inheritdoc ILockTOS
    function createLockWithPermit(
        uint256 _value,
        uint256 _unlockWeeks,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external override returns (uint256 lockId) {
        ITOS(tos).permit(
            msg.sender,
            address(this),
            _value,
            _deadline,
            _v,
            _r,
            _s
        );
        lockId = createLock(_value, _unlockWeeks);
    }

    /// @inheritdoc ILockTOS
    function increaseUnlockTime(uint256 _lockId, uint256 _unlockWeeks)
        external
        override
    {
        require(_unlockWeeks > 0, "Unlock period less than a week");
        cumulativeEpochUnit = cumulativeEpochUnit.add(_unlockWeeks);

        LibLockTOS.LockedBalance memory lock =
            lockedBalances[msg.sender][_lockId];
        uint256 unlockTime = lock.end.add(_unlockWeeks.mul(epochUnit));
        unlockTime = unlockTime.div(epochUnit).mul(epochUnit);
        require(
            unlockTime - block.timestamp < maxTime,
            "Max unlock time is 3 years"
        );
        require(lock.end > block.timestamp, "Lock time already finished");
        require(lock.end < unlockTime, "New lock time must be greater");
        require(lock.amount > 0, "No existing locked TOS");
        _deposit(msg.sender, _lockId, 0, unlockTime);

        emit LockUnlockTimeIncreased(msg.sender, _lockId, unlockTime);
    }

    /// @inheritdoc ILockTOS
    function withdrawAll() external override ifFree {
        uint256[] storage locks = userLocks[msg.sender];
        if (locks.length == 0) {
            return;
        }

        for (uint256 i = 0; i < locks.length; i++) {
            LibLockTOS.LockedBalance memory lock = allLocks[locks[i]];
            if (
                lock.withdrawn == false &&
                locks[i] > 0 &&
                lock.amount > 0 &&
                lock.start > 0 &&
                lock.end > 0 &&
                lock.end < block.timestamp
            ) {
                _withdraw(locks[i]);
            }
        }
    }

    /// @inheritdoc ILockTOS
    function globalCheckpoint() external override {
        _recordHistoryPoints();
    }

    /// @inheritdoc ILockTOS
    function withdraw(uint256 _lockId) public override ifFree {
        require(_lockId > 0, "_lockId is zero");
        _withdraw(_lockId);
    }

    /// @dev Send staked amount back to user
    function _withdraw(uint256 _lockId) internal {
        LibLockTOS.LockedBalance memory lockedOld =
            lockedBalances[msg.sender][_lockId];
        require(lockedOld.withdrawn == false, "Already withdrawn");
        require(lockedOld.start > 0, "Lock does not exist");
        require(lockedOld.end < block.timestamp, "Lock time not finished");
        require(lockedOld.amount > 0, "No amount to withdraw");

        LibLockTOS.LockedBalance memory lockedNew =
            LibLockTOS.LockedBalance({
                amount: 0,
                start: 0,
                end: 0,
                withdrawn: true
            });

        // Checkpoint
        _checkpoint(lockedNew, lockedOld);

        // Transfer TOS back
        uint256 amount = lockedOld.amount;
        lockedBalances[msg.sender][_lockId] = lockedNew;
        allLocks[_lockId] = lockedNew;

        IERC20(tos).transfer(msg.sender, amount);
        emit LockWithdrawn(msg.sender, _lockId, amount);
    }

    /// @inheritdoc ILockTOS
    function createLock(uint256 _value, uint256 _unlockWeeks)
        public
        override
        returns (uint256 lockId)
    {
        require(_value > 0, "Value locked should be non-zero");
        require(_unlockWeeks > 0, "Unlock period less than a week");

        cumulativeEpochUnit = cumulativeEpochUnit.add(_unlockWeeks);
        cumulativeTOSAmount = cumulativeTOSAmount.add(_value);
        uint256 unlockTime = block.timestamp.add(_unlockWeeks.mul(epochUnit));
        unlockTime = unlockTime.div(epochUnit).mul(epochUnit);
        require(
            unlockTime - block.timestamp <= maxTime,
            "Max unlock time is 3 years"
        );

        if (userLocks[msg.sender].length == 0) { // check if user for the first time
            uniqueUsers.push(msg.sender);
        }

        lockIdCounter = lockIdCounter.add(1);
        lockId = lockIdCounter;

        _deposit(msg.sender, lockId, _value, unlockTime);
        userLocks[msg.sender].push(lockId);

        emit LockCreated(msg.sender, lockId, _value, unlockTime);
    }

    /// @inheritdoc ILockTOS
    function depositFor(
        address _addr,
        uint256 _lockId,
        uint256 _value
    ) public override {
        require(_value > 0, "Value locked should be non-zero");
        LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][_lockId];
        require(lock.withdrawn == false, "Lock is withdrawn");
        require(lock.start > 0, "Lock does not exist");
        require(lock.end > block.timestamp, "Lock time is finished");

        cumulativeTOSAmount = cumulativeTOSAmount.add(_value);
        _deposit(_addr, _lockId, _value, 0);
        emit LockDeposited(msg.sender, _lockId, _value);
    }

    /// @inheritdoc ILockTOS
    function totalSupplyAt(uint256 _timestamp)
        public
        view
        override
        returns (uint256)
    {
        if (pointHistory.length == 0) {
            return 0;
        }

        (bool success, LibLockTOS.Point memory point) =
            _findClosestPoint(pointHistory, _timestamp);
        if (!success) {
            return 0;
        }

        point = _fillRecordGaps(point, _timestamp);
        int256 currentBias =
            point.slope * (_timestamp.sub(point.timestamp).toInt256());
        return
            uint256(point.bias > currentBias ? point.bias - currentBias : 0)
                .div(MULTIPLIER);
    }

    /// @inheritdoc ILockTOS
    function totalLockedAmountOf(address _addr) external view override returns (uint256) {
        uint256 len = userLocks[_addr].length;
        uint256 stakedAmount = 0;
        for (uint256 i = 0; i < len; ++i) {
            uint256 lockId = userLocks[_addr][i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];
            stakedAmount = stakedAmount.add(lock.amount);
        }
        return stakedAmount;
    }

    /// @inheritdoc ILockTOS
    function withdrawableAmountOf(address _addr) external view override returns (uint256) {
        uint256 len = userLocks[_addr].length;
        uint256 amount = 0;
        for(uint i = 0; i < len; i++){
            uint256 lockId = userLocks[_addr][i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];
            if(lock.end <= block.timestamp && lock.amount > 0 && lock.withdrawn == false) {
                amount = amount.add(lock.amount);
            }
        }
        return amount;
    }

    /// @inheritdoc ILockTOS
    function totalSupply() external view override returns (uint256) {
        if (pointHistory.length == 0) {
            return 0;
        }

        LibLockTOS.Point memory point = _fillRecordGaps(
            pointHistory[pointHistory.length - 1],
            block.timestamp
        );

        int256 currentBias =
            point.slope.mul(block.timestamp.sub(point.timestamp).toInt256());
        return
            uint256(point.bias > currentBias ? point.bias.sub(currentBias) : 0)
                .div(MULTIPLIER);
    }

    /// @inheritdoc ILockTOS
    function balanceOfLockAt(uint256 _lockId, uint256 _timestamp)
        public
        view
        override
        returns (uint256)
    {
        (bool success, LibLockTOS.Point memory point) =
            _findClosestPoint(lockPointHistory[_lockId], _timestamp);
        if (!success) {
            return 0;
        }
        int256 currentBias =
            point.slope.mul(_timestamp.sub(point.timestamp).toInt256());
        return
            uint256(point.bias > currentBias ? point.bias.sub(currentBias) : 0)
                .div(MULTIPLIER);
    }

    /// @inheritdoc ILockTOS
    function balanceOfLock(uint256 _lockId)
        public
        view
        override
        returns (uint256)
    {
        uint256 len = lockPointHistory[_lockId].length;
        if (len == 0) {
            return 0;
        }

        LibLockTOS.Point memory point = lockPointHistory[_lockId][len - 1];
        int256 currentBias =
            point.slope.mul(block.timestamp.sub(point.timestamp).toInt256());
        return
            uint256(point.bias > currentBias ? point.bias.sub(currentBias) : 0)
                .div(MULTIPLIER);
    }

    /// @inheritdoc ILockTOS
    function balanceOfAt(address _addr, uint256 _timestamp)
        public
        view
        override
        returns (uint256 balance)
    {
        uint256[] memory locks = userLocks[_addr];
        if (locks.length == 0) return 0;
        for (uint256 i = 0; i < locks.length; ++i) {
            balance = balance.add(balanceOfLockAt(locks[i], _timestamp));
        }
    }

    /// @inheritdoc ILockTOS
    function balanceOf(address _addr)
        public
        view
        override
        returns (uint256 balance)
    {
        uint256[] memory locks = userLocks[_addr];
        if (locks.length == 0) return 0;
        for (uint256 i = 0; i < locks.length; ++i) {
            balance = balance.add(balanceOfLock(locks[i]));
        }
    }

    /// @inheritdoc ILockTOS
    function locksInfo(uint256 _lockId)
        public
        view
        override
        returns (
            uint256 start,
            uint256 end,
            uint256 amount
        )
    {
        return (
            allLocks[_lockId].start,
            allLocks[_lockId].end,
            allLocks[_lockId].amount
        );
    }

    /// @inheritdoc ILockTOS
    function locksOf(address _addr)
        public
        view
        override
        returns (uint256[] memory)
    {
        return userLocks[_addr];
    }

    /// @inheritdoc ILockTOS
    function withdrawableLocksOf(address _addr)  external view override returns (uint256[] memory) {
        uint256 len = userLocks[_addr].length;
        uint256 size = 0;
        for(uint i = 0; i < len; i++){
            uint256 lockId = userLocks[_addr][i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];
            if(lock.end <= block.timestamp && lock.amount > 0 && lock.withdrawn == false) {
                size++;
            }
        }

        uint256[] memory withdrawable = new uint256[](size);
        size = 0;
        for(uint i = 0; i < len; i++) {
            uint256 lockId = userLocks[_addr][i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];
            if(lock.end <= block.timestamp && lock.amount > 0 && lock.withdrawn == false) {
                withdrawable[size++] = lockId;
            }
        }
        return withdrawable;
    }

    /// @inheritdoc ILockTOS
    function activeLocksOf(address _addr)
        public
        view
        override
        returns (uint256[] memory)
    {
        uint256 len = userLocks[_addr].length;
        uint256 _size = 0;
        for(uint i = 0; i < len; i++){
            uint256 lockId = userLocks[_addr][i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];
            if(lock.end > block.timestamp) {
                _size++;
            }
        }

        uint256[] memory activeLocks = new uint256[](_size);
        _size = 0;
        for(uint i = 0; i < len; i++) {
            uint256 lockId = userLocks[_addr][i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];
            if(lock.end > block.timestamp) {
                activeLocks[_size++] = lockId;
            }
        }
        return activeLocks;
    }

    /// @inheritdoc ILockTOS
    function pointHistoryOf(uint256 _lockId)
        public
        view
        override
        returns (LibLockTOS.Point[] memory)
    {
        return lockPointHistory[_lockId];
    }

    /// @dev Finds closest point
    function _findClosestPoint(
        LibLockTOS.Point[] storage _history,
        uint256 _timestamp
    ) internal view returns (bool success, LibLockTOS.Point memory point) {
        if (_history.length == 0) {
            return (false, point);
        }

        uint256 left = 0;
        uint256 right = _history.length;
        while (left + 1 < right) {
            uint256 mid = left.add(right).div(2);
            if (_history[mid].timestamp <= _timestamp) {
                left = mid;
            } else {
                right = mid;
            }
        }

        if (_history[left].timestamp <= _timestamp) {
            return (true, _history[left]);
        }
        return (false, point);
    }

    /// @dev Deposit
    function _deposit(
        address _addr,
        uint256 _lockId,
        uint256 _value,
        uint256 _unlockTime
    ) internal ifFree {
        LibLockTOS.LockedBalance memory lockedOld =
            lockedBalances[_addr][_lockId];
        LibLockTOS.LockedBalance memory lockedNew =
            LibLockTOS.LockedBalance({
                amount: lockedOld.amount,
                start: lockedOld.start,
                end: lockedOld.end,
                withdrawn: false
            });

        // Make new lock
        lockedNew.amount = lockedNew.amount.add(_value);
        if (_unlockTime > 0) {
            lockedNew.end = _unlockTime;
        }
        if (lockedNew.start == 0) {
            lockedNew.start = block.timestamp;
        }

        // Checkpoint
        _checkpoint(lockedNew, lockedOld);

        // Save new lock
        lockedBalances[_addr][_lockId] = lockedNew;
        allLocks[_lockId] = lockedNew;

        // Save user point,
        int256 userSlope =
            lockedNew.amount.mul(MULTIPLIER).div(maxTime).toInt256();
        int256 userBias =
            userSlope.mul(lockedNew.end.sub(block.timestamp).toInt256());
        LibLockTOS.Point memory userPoint =
            LibLockTOS.Point({
                timestamp: block.timestamp,
                slope: userSlope,
                bias: userBias
            });
        lockPointHistory[_lockId].push(userPoint);

        // Transfer TOS
        require(
            IERC20(tos).transferFrom(msg.sender, address(this), _value),
            "LockTOS: fail transferFrom"
        );
    }

    /// @dev Checkpoint
    function _checkpoint(
        LibLockTOS.LockedBalance memory lockedNew,
        LibLockTOS.LockedBalance memory lockedOld
    ) internal {
        uint256 timestamp = block.timestamp;
        LibLockTOS.SlopeChange memory changeNew =
            LibLockTOS.SlopeChange({slope: 0, bias: 0, changeTime: 0});
        LibLockTOS.SlopeChange memory changeOld =
            LibLockTOS.SlopeChange({slope: 0, bias: 0, changeTime: 0});

        // Initialize slope changes
        if (lockedNew.end > timestamp && lockedNew.amount > 0) {
            changeNew.slope = lockedNew
                .amount
                .mul(MULTIPLIER)
                .div(maxTime)
                .toInt256();
            changeNew.bias = changeNew.slope
                .mul(lockedNew.end.sub(timestamp).toInt256());
            changeNew.changeTime = lockedNew.end;
        }
        if (lockedOld.end > timestamp && lockedOld.amount > 0) {
            changeOld.slope = lockedOld
                .amount
                .mul(MULTIPLIER)
                .div(maxTime)
                .toInt256();
            changeOld.bias = changeOld.slope
                .mul(lockedOld.end.sub(timestamp).toInt256());
            changeOld.changeTime = lockedOld.end;
        }

        // Record history gaps
        LibLockTOS.Point memory currentWeekPoint = _recordHistoryPoints();
        currentWeekPoint.bias = currentWeekPoint.bias.add(
            changeNew.bias.sub(changeOld.bias)
        );
        currentWeekPoint.slope = currentWeekPoint.slope.add(
            changeNew.slope.sub(changeOld.slope)
        );
        currentWeekPoint.bias = currentWeekPoint.bias > 0
            ? currentWeekPoint.bias
            : 0;
        currentWeekPoint.slope = currentWeekPoint.slope > 0
            ? currentWeekPoint.slope
            : 0;
        pointHistory[pointHistory.length - 1] = currentWeekPoint;

        // Update slope changes
        _updateSlopeChanges(changeNew, changeOld);
    }

    /// @dev Fill the gaps
    function _recordHistoryPoints()
        internal
        returns (LibLockTOS.Point memory lastWeek)
    {
        uint256 timestamp = block.timestamp;
        if (pointHistory.length > 0) {
            lastWeek = pointHistory[pointHistory.length - 1];
        } else {
            lastWeek = LibLockTOS.Point({
                bias: 0,
                slope: 0,
                timestamp: timestamp
            });
        }

        // Iterate through all past unrecoreded weeks and record
        uint256 pointTimestampIterator =
            lastWeek.timestamp.div(epochUnit).mul(epochUnit);
        while (pointTimestampIterator != timestamp) {
            pointTimestampIterator = Math.min(
                pointTimestampIterator.add(epochUnit),
                timestamp
            );
            int256 deltaSlope = slopeChanges[pointTimestampIterator];
            int256 deltaTime =
                Math.min(pointTimestampIterator.sub(lastWeek.timestamp), epochUnit).toInt256();
            lastWeek.bias = lastWeek.bias.sub(lastWeek.slope.mul(deltaTime));
            lastWeek.slope = lastWeek.slope.add(deltaSlope);
            lastWeek.bias = lastWeek.bias > 0 ? lastWeek.bias : 0;
            lastWeek.slope = lastWeek.slope > 0 ? lastWeek.slope : 0;
            lastWeek.timestamp = pointTimestampIterator;
            pointHistory.push(lastWeek);
        }
        return lastWeek;
    }

    /// @dev Fills the record gaps
    function _fillRecordGaps(LibLockTOS.Point memory week, uint256 timestamp)
        internal
        view
        returns (LibLockTOS.Point memory)
    {
        // Iterate through all past unrecoreded weeks
        uint256 pointTimestampIterator =
            week.timestamp.div(epochUnit).mul(epochUnit);
        while (pointTimestampIterator != timestamp) {
            pointTimestampIterator = Math.min(
                pointTimestampIterator.add(epochUnit),
                timestamp
            );
            int256 deltaSlope = slopeChanges[pointTimestampIterator];
            int256 deltaTime =
                Math.min(pointTimestampIterator.sub(week.timestamp), epochUnit).toInt256();
            week.bias = week.bias.sub(week.slope.mul(deltaTime));
            week.slope = week.slope.add(deltaSlope);
            week.bias = week.bias > 0 ? week.bias : 0;
            week.slope = week.slope > 0 ? week.slope : 0;
            week.timestamp = pointTimestampIterator;
        }
        return week;
    }

    /// @dev Update slope changes
    function _updateSlopeChanges(
        LibLockTOS.SlopeChange memory changeNew,
        LibLockTOS.SlopeChange memory changeOld
    ) internal {
        int256 deltaSlopeNew = slopeChanges[changeNew.changeTime];
        int256 deltaSlopeOld = slopeChanges[changeOld.changeTime];
        if (changeOld.changeTime > block.timestamp) {
            deltaSlopeOld = deltaSlopeOld.add(changeOld.slope);
            if (changeOld.changeTime == changeNew.changeTime) {
                deltaSlopeOld = deltaSlopeOld.sub(changeNew.slope);
            }
            slopeChanges[changeOld.changeTime] = deltaSlopeOld;
        }
        if (
            changeNew.changeTime > block.timestamp &&
            changeNew.changeTime > changeOld.changeTime
        ) {
            deltaSlopeNew = deltaSlopeNew.sub(changeNew.slope);
            slopeChanges[changeNew.changeTime] = deltaSlopeNew;
        }
    }

    function getCurrentTime() external view returns (uint256) {
        return block.timestamp;
    }

    function currentStakedTotalTOS() external view returns (uint256) {
        return IERC20(tos).balanceOf(address(this));
    }
}


// File contracts/interfaces/ILockTOSDividend.sol

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;


interface ILockTOSDividend {
    /// @dev Claim batch
    function claimBatch(address[] calldata _tokens) external;

    /// @dev Claim
    function claim(address _token) external;

    /// @dev Claim up to `_timestamp`
    function claimUpTo(address _token, uint256 _timestamp) external;

    /// @dev Epoch to timestamp
    // function epochToTimestamp(uint256 _epoch) external view returns (uint256);

    /// @dev Distribute
    // function redistribute(address _token, uint256 _weeklyEpoch) external;

    /// @dev Distribute
    function distribute(address _token, uint256 _amount) external;

    /// @dev getCurrentWeeklyEpochTimestamp
    function getCurrentWeeklyEpochTimestamp() external view returns (uint256);

    /// @dev ifDistributionPossible
    function ifDistributionPossible() external view returns (bool);
    
    /// @dev getAvailableClaims
    function getAvailableClaims(address _account) external view returns (address[] memory claimableTokens, uint256[] memory claimableAmounts);

    /// @dev Get weekly epoch for `_timestamp`
    function getWeeklyEpoch(uint256 _timestamp) external view returns (uint256);

    /// @dev Get current weekly epoch
    function getCurrentWeeklyEpoch() external view returns (uint256);

    /// @dev Returns tokens per week at `_timestamp`
    function tokensPerWeekAt(address _token, uint256 _timestamp)
        external
        view
        returns (uint256);

    /// @dev Returns the last epoch claimed for `_lockId`
    function claimStartWeeklyEpoch(address _token, uint256 _lockId)
        external
        view
        returns (uint256);

    /// @dev Returns claimable amount
    function claimable(address _account, address _token) external view returns (uint256);
    
    /// @dev Returns claimable amount from `_timeStart` to `_timeEnd`
    function claimableForPeriod(address _account, address _token, uint256 _timeStart, uint256 _timeEnd) external view returns (uint256);
}


// File contracts/libraries/LibLockTOSDividend.sol

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;


library LibLockTOSDividend {
    struct Distribution {
        bool exists;
        uint256 totalDistribution;
        uint256 lastBalance;
        mapping (uint256 => uint256) tokensPerWeek;
        mapping (uint256 => uint256) claimStartWeeklyEpoch;
    } 
}


// File contracts/stake/LockTOSDividendStorage.sol

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

contract LockTOSDividendStorage {
    /// @dev flag for pause proxy
    bool public pauseProxy;

    /// @dev registry
    address public stakeRegistry;
    bool public migratedL2;

    uint256 public epochUnit;
    address public lockTOS;
    uint256 public genesis;
    mapping(address => LibLockTOSDividend.Distribution) public distributions;
    address[] public distributedTokens;
    uint256 internal free = 1;
}


// File contracts/stake/LockTOSDividend.sol

// SPDX-License-Identifier: Unlicense
pragma solidity >=0.7.6;







contract LockTOSDividend is
    LockTOSDividendStorage,
    AccessibleCommon,
    ILockTOSDividend
{
    event Claim(address indexed token, uint256 amount, uint256 timestamp);
    event Distribute(address indexed token, uint256 amount);
    event Redistribute(address indexed token, uint256 oldEpoch, uint256 newEpoch);

    using SafeMath for uint256;
    using SafeCast for uint256;

    /// @dev Check if a function is used or not
    modifier ifFree {
        require(free == 1, "LockId is already in use");
        free = 0;
        _;
        free = 1;
    }

    /// @inheritdoc ILockTOSDividend
    function claim(address _token) public override {
        uint256 timestamp = block.timestamp - epochUnit;
        _claimUpTo(_token, timestamp);
    }

    /// @inheritdoc ILockTOSDividend
    function claimBatch(address[] calldata _tokens) external override {
        for (uint i = 0; i < _tokens.length; ++i) {
            claim(_tokens[i]);
        }
    }

    /// @inheritdoc ILockTOSDividend
    function claimUpTo(address _token, uint256 _timestamp) external override {
        uint256 timestamp = Math.min(_timestamp, block.timestamp - epochUnit);
        _claimUpTo(_token, timestamp);
    }

    function redistribute(address _token, uint256 _weeklyEpoch)
        external
        // override
    {
        require(_weeklyEpoch < getCurrentWeeklyEpoch());
        uint256 timestamp = genesis.add(_weeklyEpoch.mul(epochUnit)).add(epochUnit);

        require(
            ILockTOS(lockTOS).totalSupplyAt(timestamp) == 0,
            "Locked Token exists for that epoch"
        );

        uint256 newEpoch = _weeklyEpoch.add(1);
        uint256 newTimestamp = timestamp.add(epochUnit);
        while (newTimestamp <= block.timestamp) {
            if (ILockTOS(lockTOS).totalSupplyAt(newTimestamp) > 0) {
                break;
            }
            newTimestamp = newTimestamp.add(epochUnit);
            newEpoch = newEpoch.add(1);
        }
        require(
            newTimestamp <= block.timestamp,
            "Cannot find epoch to redistribute"
        );

        LibLockTOSDividend.Distribution storage distr = distributions[_token];
        distr.tokensPerWeek[newEpoch] = distr.tokensPerWeek[newEpoch].add(
            distr.tokensPerWeek[_weeklyEpoch]
        );
        distr.tokensPerWeek[_weeklyEpoch] = 0;

        emit Redistribute(_token, _weeklyEpoch, newEpoch);
    }

    /// @inheritdoc ILockTOSDividend
    function distribute(address _token, uint256 _amount)
        external
        override
        ifFree
    {
        uint256 weeklyEpoch = getCurrentWeeklyEpoch();
        LibLockTOSDividend.Distribution storage distr = distributions[_token];
        IERC20(_token).transferFrom(msg.sender, address(this), _amount);
        if (distr.exists == false) {
            distributedTokens.push(_token);
        }

        uint256 newBalance = IERC20(_token).balanceOf(address(this));
        uint256 increment = newBalance.sub(distr.lastBalance);
        distr.exists = true;
        distr.lastBalance = newBalance;
        distr.totalDistribution = distr.totalDistribution.add(increment);
        distr.tokensPerWeek[weeklyEpoch] = distr.tokensPerWeek[weeklyEpoch].add(increment);
        emit Distribute(_token, _amount);
    }

    /// @inheritdoc ILockTOSDividend
    function getWeeklyEpoch(uint256 _timestamp)
        public
        view
        override
        returns (uint256)
    {
        return _timestamp > genesis ? (_timestamp.sub(genesis)).div(epochUnit) : 0;
    }

    function epochToTimestamp(uint256 _epoch)
        public
        view
        // override
        returns (uint256)
    {
        return genesis.add(_epoch.mul(epochUnit)).add(epochUnit);
    }

    /// @inheritdoc ILockTOSDividend
    function tokensPerWeekAt(address _token, uint256 _timestamp)
        external
        view
        override
        returns (uint256)
    {
        uint256 weeklyEpoch = getWeeklyEpoch(_timestamp);
        return distributions[_token].tokensPerWeek[weeklyEpoch];
    }

    /// @inheritdoc ILockTOSDividend
    function claimStartWeeklyEpoch(address _token, uint256 _lockId)
        external
        view
        override
        returns (uint256)
    {
        return distributions[_token].claimStartWeeklyEpoch[_lockId];
    }

    /// @inheritdoc ILockTOSDividend
    function getCurrentWeeklyEpoch() public view override returns (uint256) {
        return getWeeklyEpoch(block.timestamp);
    }

    /// @inheritdoc ILockTOSDividend
    function getCurrentWeeklyEpochTimestamp() public view override returns (uint256) {
        uint256 weeklyEpoch = getCurrentWeeklyEpoch();
        uint256 timestamp = genesis.add(weeklyEpoch.mul(epochUnit)) + epochUnit;
        return timestamp;
    }

    /// @inheritdoc ILockTOSDividend
    function ifDistributionPossible() public view override returns (bool) {
        uint256 timestamp = getCurrentWeeklyEpochTimestamp();
        return ILockTOS(lockTOS).totalSupplyAt(timestamp) > 0;
    }

    /// @inheritdoc ILockTOSDividend
    function claimable(address _account, address _token) public view override returns (uint256) {
        return claimableForPeriod(_account, _token, genesis, block.timestamp);
    }

    /// @inheritdoc ILockTOSDividend
    function getAvailableClaims(address _account) public view override returns (address[] memory claimableTokens, uint256[] memory claimableAmounts) {
        uint256[] memory amounts = new uint256[](distributedTokens.length);
        uint256 claimableCount = 0;
        for (uint256 i = 0; i < distributedTokens.length; ++i) {
            amounts[i] = claimable(_account, distributedTokens[i]);
            if (amounts[i] > 0) {
                claimableCount += 1;
            }
        }

        claimableAmounts = new uint256[](claimableCount);
        claimableTokens = new address[](claimableCount);
        uint256 j = 0;
        for (uint256 i = 0; i < distributedTokens.length; ++i) {
            if (amounts[i] > 0) {
                claimableAmounts[j] = amounts[i];
                claimableTokens[j] = distributedTokens[i];
                j++;
            }
        }
    }

    /// @inheritdoc ILockTOSDividend
    function claimableForPeriod(
        address _account,
        address _token,
        uint256 _timeStart,
        uint256 _timeEnd
    ) public view override returns (uint256) {
        uint256 epochStart = getWeeklyEpoch(_timeStart);
        uint256 timestampEnd = Math.min(_timeEnd, block.timestamp - epochUnit);
        uint256 epochEnd = getWeeklyEpoch(timestampEnd);
        if (epochEnd == 0) {
            return 0;
        }

        uint256[] memory userLocks = ILockTOS(lockTOS).locksOf(_account);
        uint256 amountToClaim = 0;
        LibLockTOSDividend.Distribution storage distr = distributions[_token];
        for (uint256 i = 0; i < userLocks.length; ++i) {
            uint256 lockId = userLocks[i];
            amountToClaim += _calculateClaim(
                distr,
                lockId,
                Math.max(epochStart, distr.claimStartWeeklyEpoch[lockId]),
                epochEnd
            );
        }
        return amountToClaim;
    }

    /// @dev Claim rewards
    function _claimUpTo(address _token, uint256 _timestamp) internal ifFree {
        uint256 weeklyEpoch = getWeeklyEpoch(_timestamp);
        uint256[] memory userLocks = ILockTOS(lockTOS).locksOf(msg.sender);
        uint256 amountToClaim = 0;
        for (uint256 i = 0; i < userLocks.length; ++i) {
            amountToClaim = amountToClaim.add(
                _recordClaim(_token, userLocks[i], weeklyEpoch)
            );
        }
        require(amountToClaim > 0, "Amount to be claimed is zero");
        IERC20(_token).transfer(msg.sender, amountToClaim);
        emit Claim(_token, amountToClaim, _timestamp);
    }

    /// @dev Record claim
    function _recordClaim(
        address _token,
        uint256 _lockId,
        uint256 _weeklyEpoch
    ) internal returns (uint256 amountToClaim) {
        LibLockTOSDividend.Distribution storage distr = distributions[_token];
        amountToClaim = _calculateClaim(
            distr,
            _lockId,
            distr.claimStartWeeklyEpoch[_lockId],
            _weeklyEpoch
        );

        distr.claimStartWeeklyEpoch[_lockId] = _weeklyEpoch.add(1);
        distr.lastBalance = distr.lastBalance.sub(amountToClaim);
        return amountToClaim;
    }

    /// @dev Amount claimable
    function _calculateClaim(
        LibLockTOSDividend.Distribution storage _distr,
        uint256 _lockId,
        uint256 _startEpoch,
        uint256 _endEpoch
    ) internal view returns (uint256) {
        (uint256 start, uint256 end,) = ILockTOS(lockTOS).locksInfo(_lockId);

        uint256 epochIterator = Math.max(_startEpoch, getWeeklyEpoch(start));
        uint256 epochLimit = Math.min(_endEpoch, getWeeklyEpoch(end));

        uint256 accumulated = 0;
        while (epochIterator <= epochLimit) {
            accumulated = accumulated.add(
                _calculateClaimPerEpoch(
                    _lockId,
                    epochIterator,
                    _distr.tokensPerWeek[epochIterator]
                )
            );
            epochIterator = epochIterator.add(1);
        }
        return accumulated;
    }

    /// @dev Calculates claim portion
    function _calculateClaimPerEpoch(
        uint256 _lockId,
        uint256 _weeklyEpoch,
        uint256 _tokensPerWeek
    ) internal view returns (uint256) {
        uint256 timestamp =
            genesis.add(_weeklyEpoch.mul(epochUnit)) + epochUnit;
        uint256 balance = ILockTOS(lockTOS).balanceOfLockAt(_lockId, timestamp);
        uint256 supply = ILockTOS(lockTOS).totalSupplyAt(timestamp);
        if (balance == 0 || supply == 0) {
            return 0;
        }
        return _tokensPerWeek.mul(balance).div(supply);
    }
}


// File contracts/interfaces/ILockTOSDividendProxy.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface ILockTOSDividendProxy {
    /// @dev Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external;

    /// @dev Set implementation contract
    /// @param _impl New implementation contract address
    function upgradeTo(address _impl) external;

    /// @dev view implementation address
    /// @return the logic address
    function implementation() external view returns (address);

    /// @dev initialize
    function initialize(address _lockTOS, uint256 _epochUnit) external;
}


// File hardhat/console.sol@v2.13.1

// SPDX-License-Identifier: MIT
pragma solidity >= 0.4.22 <0.9.0;

library console {
	address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);

	function _sendLogPayload(bytes memory payload) private view {
		uint256 payloadLength = payload.length;
		address consoleAddress = CONSOLE_ADDRESS;
		assembly {
			let payloadStart := add(payload, 32)
			let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
		}
	}

	function log() internal view {
		_sendLogPayload(abi.encodeWithSignature("log()"));
	}

	function logInt(int256 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
	}

	function logUint(uint256 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
	}

	function logString(string memory p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string)", p0));
	}

	function logBool(bool p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
	}

	function logAddress(address p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address)", p0));
	}

	function logBytes(bytes memory p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
	}

	function logBytes1(bytes1 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
	}

	function logBytes2(bytes2 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
	}

	function logBytes3(bytes3 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
	}

	function logBytes4(bytes4 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
	}

	function logBytes5(bytes5 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
	}

	function logBytes6(bytes6 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
	}

	function logBytes7(bytes7 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
	}

	function logBytes8(bytes8 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
	}

	function logBytes9(bytes9 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
	}

	function logBytes10(bytes10 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
	}

	function logBytes11(bytes11 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
	}

	function logBytes12(bytes12 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
	}

	function logBytes13(bytes13 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
	}

	function logBytes14(bytes14 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
	}

	function logBytes15(bytes15 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
	}

	function logBytes16(bytes16 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
	}

	function logBytes17(bytes17 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
	}

	function logBytes18(bytes18 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
	}

	function logBytes19(bytes19 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
	}

	function logBytes20(bytes20 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
	}

	function logBytes21(bytes21 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
	}

	function logBytes22(bytes22 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
	}

	function logBytes23(bytes23 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
	}

	function logBytes24(bytes24 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
	}

	function logBytes25(bytes25 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
	}

	function logBytes26(bytes26 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
	}

	function logBytes27(bytes27 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
	}

	function logBytes28(bytes28 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
	}

	function logBytes29(bytes29 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
	}

	function logBytes30(bytes30 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
	}

	function logBytes31(bytes31 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
	}

	function logBytes32(bytes32 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
	}

	function log(uint256 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
	}

	function log(string memory p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string)", p0));
	}

	function log(bool p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
	}

	function log(address p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address)", p0));
	}

	function log(uint256 p0, uint256 p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256)", p0, p1));
	}

	function log(uint256 p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string)", p0, p1));
	}

	function log(uint256 p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool)", p0, p1));
	}

	function log(uint256 p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address)", p0, p1));
	}

	function log(string memory p0, uint256 p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
	}

	function log(string memory p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
	}

	function log(string memory p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
	}

	function log(string memory p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
	}

	function log(bool p0, uint256 p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256)", p0, p1));
	}

	function log(bool p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
	}

	function log(bool p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
	}

	function log(bool p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
	}

	function log(address p0, uint256 p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256)", p0, p1));
	}

	function log(address p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
	}

	function log(address p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
	}

	function log(address p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
	}

	function log(uint256 p0, uint256 p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256)", p0, p1, p2));
	}

	function log(uint256 p0, uint256 p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string)", p0, p1, p2));
	}

	function log(uint256 p0, uint256 p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool)", p0, p1, p2));
	}

	function log(uint256 p0, uint256 p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address)", p0, p1, p2));
	}

	function log(uint256 p0, string memory p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256)", p0, p1, p2));
	}

	function log(uint256 p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string)", p0, p1, p2));
	}

	function log(uint256 p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool)", p0, p1, p2));
	}

	function log(uint256 p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address)", p0, p1, p2));
	}

	function log(uint256 p0, bool p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256)", p0, p1, p2));
	}

	function log(uint256 p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string)", p0, p1, p2));
	}

	function log(uint256 p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool)", p0, p1, p2));
	}

	function log(uint256 p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address)", p0, p1, p2));
	}

	function log(uint256 p0, address p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256)", p0, p1, p2));
	}

	function log(uint256 p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string)", p0, p1, p2));
	}

	function log(uint256 p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool)", p0, p1, p2));
	}

	function log(uint256 p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address)", p0, p1, p2));
	}

	function log(string memory p0, uint256 p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256)", p0, p1, p2));
	}

	function log(string memory p0, uint256 p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string)", p0, p1, p2));
	}

	function log(string memory p0, uint256 p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool)", p0, p1, p2));
	}

	function log(string memory p0, uint256 p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
	}

	function log(string memory p0, address p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256)", p0, p1, p2));
	}

	function log(string memory p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
	}

	function log(string memory p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
	}

	function log(string memory p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
	}

	function log(bool p0, uint256 p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256)", p0, p1, p2));
	}

	function log(bool p0, uint256 p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string)", p0, p1, p2));
	}

	function log(bool p0, uint256 p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool)", p0, p1, p2));
	}

	function log(bool p0, uint256 p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
	}

	function log(bool p0, bool p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256)", p0, p1, p2));
	}

	function log(bool p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
	}

	function log(bool p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
	}

	function log(bool p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
	}

	function log(bool p0, address p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256)", p0, p1, p2));
	}

	function log(bool p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
	}

	function log(bool p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
	}

	function log(bool p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
	}

	function log(address p0, uint256 p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256)", p0, p1, p2));
	}

	function log(address p0, uint256 p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string)", p0, p1, p2));
	}

	function log(address p0, uint256 p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool)", p0, p1, p2));
	}

	function log(address p0, uint256 p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address)", p0, p1, p2));
	}

	function log(address p0, string memory p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256)", p0, p1, p2));
	}

	function log(address p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
	}

	function log(address p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
	}

	function log(address p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
	}

	function log(address p0, bool p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256)", p0, p1, p2));
	}

	function log(address p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
	}

	function log(address p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
	}

	function log(address p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
	}

	function log(address p0, address p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256)", p0, p1, p2));
	}

	function log(address p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
	}

	function log(address p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
	}

	function log(address p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
	}

	function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
	}

}


// File contracts/stake/LockTOSDividendProxy.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;





/// @title The proxy of TOS Plaform
/// @notice Admin can createVault, createStakeContract.
/// User can excute the tokamak staking function of each contract through this logic.
contract LockTOSDividendProxy is
    LockTOSDividendStorage,
    AccessibleCommon,
    ProxyBase,
    ILockTOSDividendProxy
{
    event Upgraded(address indexed implementation);

    using SafeMath for uint256;

    /// @dev constructor of StakeVaultProxy
    /// @param _impl the logic address of StakeVaultProxy
    /// @param _admin the admin address of StakeVaultProxy
    constructor(address _impl, address _admin) {
        assert(
            IMPLEMENTATION_SLOT ==
                bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1)
        );

        require(_impl != address(0), "LockTOSProxy: logic is zero");

        _setImplementation(_impl);

        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, _admin);
        _setupRole(ADMIN_ROLE, address(this));
    }

    /// @notice Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external override onlyOwner {
        pauseProxy = _pause;
    }

    /// @notice Set implementation contract
    /// @param impl New implementation contract address
    function upgradeTo(address impl) external override onlyOwner {
        require(impl != address(0), "LockTOSProxy: input is zero");
        require(_implementation() != impl, "LockTOSProxy: same");
        _setImplementation(impl);
        emit Upgraded(impl);
    }

    /// @dev returns the implementation
    function implementation() public view override returns (address) {
        return _implementation();
    }

    /// @dev receive ether
    receive() external payable {
        revert("cannot receive Ether");
    }

    /// @dev fallback function , execute on undefined function call
    fallback() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    function _fallback() internal {
        address _impl = _implementation();
        require(
            _impl != address(0) && !pauseProxy,
            "LockTOSProxy: impl OR proxy is false"
        );

        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }

    /// @dev Initialize
    function initialize(address _lockTOS, uint256 _epochUnit) external override onlyOwner {
        lockTOS = _lockTOS;
        epochUnit = _epochUnit;
        genesis = block.timestamp.div(epochUnit).mul(epochUnit);
    }
}


// File contracts/interfaces/ILockTOSProxy.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface ILockTOSProxy {
    /// @dev Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external;

    /// @dev Set implementation contract
    /// @param _impl New implementation contract address
    function upgradeTo(address _impl) external;

    /// @dev view implementation address
    /// @return the logic address
    function implementation() external view returns (address);

    /// @dev initialize
    function initialize(
        address _tos,
        uint256 _epochUnit,
        uint256 _maxTime
    ) external;
}


// File contracts/stake/LockTOSProxy.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;




/// @title The proxy of TOS Plaform
/// @notice Admin can createVault, createStakeContract.
/// User can excute the tokamak staking function of each contract through this logic.
contract LockTOSProxy is
    LockTOSStorage,
    AccessibleCommon,
    ProxyBase,
    ILockTOSProxy
{
    event Upgraded(address indexed implementation);

    /// @dev constructor of StakeVaultProxy
    /// @param _impl the logic address of StakeVaultProxy
    constructor(address _impl, address _admin) {
        assert(
            IMPLEMENTATION_SLOT ==
                bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1)
        );

        require(_impl != address(0), "LockTOSProxy: logic is zero");

        _setImplementation(_impl);

        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, _admin);
        lockIdCounter = 0;
        cumulativeEpochUnit = 0;
        cumulativeTOSAmount = 0;
    }

    /// @notice Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external override onlyOwner {
        pauseProxy = _pause;
    }

    /// @notice Set implementation contract
    /// @param impl New implementation contract address
    function upgradeTo(address impl) external override onlyOwner {
        require(impl != address(0), "LockTOSProxy: input is zero");
        require(_implementation() != impl, "LockTOSProxy: same");
        _setImplementation(impl);
        emit Upgraded(impl);
    }

    /// @dev returns the implementation
    function implementation() public view override returns (address) {
        return _implementation();
    }

    /// @dev receive ether
    receive() external payable {
        revert("cannot receive Ether");
    }

    /// @dev fallback function , execute on undefined function call
    fallback() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    function _fallback() internal {
        address _impl = _implementation();
        require(
            _impl != address(0) && !pauseProxy,
            "LockTOSProxy: impl OR proxy is false"
        );

        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }

    /// @dev Initialize
    function initialize(
        address _tos,
        uint256 _epochUnit,
        uint256 _maxTime
    ) external override onlyOwner {
        require(tos == address(0), "Already initialized");
        tos = _tos;
        epochUnit = _epochUnit;
        maxTime = _maxTime;
    }
}


// File contracts/stake/LockTOSv2Storage.sol

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;


contract LockTOSv2Storage {

    mapping(uint256 => address) public proxyImplementation;
    mapping(address => bool) public aliveImplementation;
    mapping(bytes4 => address) public selectorImplementation;

    bool public lock_;
    address public staker;

    modifier onlyStaker {
        require(msg.sender == staker, "caller is not staker");
        _;
    }
}


// File contracts/stake/LockTOSv2Logic0.sol

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;
pragma abicoder v2;












// import "hardhat/console.log";

interface MyTreasury {
    function isTreasury() external view returns (bool);
}

contract LockTOSv2Logic0 is
    LockTOSStorage,
    AccessibleCommon,
    ProxyBase,
    LockTOSv2Storage,
    ILockTOSv2Action0
{
    using SafeMath for uint256;
    using SafeCast for uint256;
    using SignedSafeMath for int256;

    event LockCreated(
        address account,
        uint256 lockId,
        uint256 value,
        uint256 unlockTime
    );
    event LockAmountIncreased(address account, uint256 lockId, uint256 value);
    event LockUnlockTimeIncreased(
        address account,
        uint256 lockId,
        uint256 unlockTime
    );
    event LockDeposited(address account, uint256 lockId, uint256 value);
    event LockWithdrawn(address account, uint256 lockId, uint256 value);


    modifier ifFree {
        require(free == 1, "LockId is already in use");
        free = 0;
        _;
        free = 1;
    }

    /// @inheritdoc ILockTOSv2Action0
    function needCheckpoint() external view override returns (bool need) {
        uint256 len = pointHistory.length;
        if (len == 0) {
            return true;
        }
        need = (block.timestamp - pointHistory[len - 1].timestamp) > epochUnit; // if the last record was within a week
    }

    /// @inheritdoc ILockTOSv2Action0
    function setMaxTime(uint256 _maxTime) external override onlyOwner {
        maxTime = _maxTime;
    }

    /// @inheritdoc ILockTOSv2Action0
    function transferTosToTreasury(address _treasury) external  override onlyOwner {
        require(_treasury != address(0), "zero address");
        require(MyTreasury(_treasury).isTreasury(), "not treasury");

        IERC20(tos).transfer(_treasury, IERC20(tos).balanceOf(address(this)));
    }

    /// @inheritdoc ILockTOSv2Action0
    function setStaker(address _staker) external  override onlyOwner {
        require(_staker != address(0), "zero address");
        require(staker != _staker, "same address");
        staker = _staker;
    }

    /// @inheritdoc ILockTOSv2Action0
    function allHolders() external view override returns (address[] memory) {
        return uniqueUsers;
    }

    /// @inheritdoc ILockTOSv2Action0
    function activeHolders() external view override returns (address[] memory) {
        bool[] memory activeCheck = new bool[](uniqueUsers.length);
        uint256 activeSize = 0;
        for (uint256 i = 0; i < uniqueUsers.length; ++i) {
            uint256[] memory activeLocks = activeLocksOf(uniqueUsers[i]);
            if (activeLocks.length > 0) {
                activeSize++;
                activeCheck[i] = true;
            }
        }

        address[] memory activeUsers = new address[](activeSize);
        uint256 j = 0;
        for (uint256 i = 0; i < uniqueUsers.length; ++i) {
            if (activeCheck[i]) {
                activeUsers[j++] = uniqueUsers[i];
            }
        }
        return activeUsers;
    }

    /// @inheritdoc ILockTOSv2Action0
    function increaseAmountByStaker(address user, uint256 _lockId, uint256 _value) external override onlyStaker {
        depositFor(user, _lockId, _value);
    }

    function increaseAmountOfIds(
        address[] memory users,
        uint256[] memory _lockIds,
        uint256[] memory _values,
        uint256 curTime
    )
        external onlyOwner
    {
        require(
            users.length > 0
            && users.length ==  _lockIds.length
            && users.length ==  _values.length ,
            "wrong length"
        );

        uint256 len = users.length;
        //console.log("increaseAmountOfIds len %s", len);

        for (uint256 i = 0; i < len; i++){
            address _account = users[i];
            uint256 _id = _lockIds[i];
            uint256 _value = _values[i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_account][_id];
            if (lock.withdrawn == false  && _value > 0) {
                //console.log("increaseAmountOfIds _id %s , _value %s", _id, _value);

                cumulativeTOSAmount.add(_value);

                // ==========================

                LibLockTOS.LockedBalance memory lockedOld = lock;
                LibLockTOS.LockedBalance memory lockedNew =
                    LibLockTOS.LockedBalance({
                        amount: lockedOld.amount,
                        start: lockedOld.start,
                        end: lockedOld.end,
                        withdrawn: false
                    });

                // Make new lock
                lockedNew.amount = lockedNew.amount.add(_value);

                // Checkpoint
                _checkpointForSync(lockedNew, lockedOld, curTime);

                // Save new lock
                lockedBalances[_account][_id] = lockedNew;
                allLocks[_id] = lockedNew;
                //console.log("Save new lock _id %s ", _id);

                // Save user point,
                int256 userSlope = lockedNew.amount.mul(MULTIPLIER).div(maxTime).toInt256();
                int256 userBias = userSlope.mul(lockedNew.end.sub(curTime).toInt256());
                LibLockTOS.Point memory userPoint =
                    LibLockTOS.Point({
                        timestamp: curTime,
                        slope: userSlope,
                        bias: userBias
                    });
                lockPointHistory[_id].push(userPoint);
                // ==========================
                // emit LockDeposited(_account, _id, _value);
            }
        }

    }

    /// @inheritdoc ILockTOSv2Action0
    function increaseUnlockTimeByStaker(address user, uint256 _lockId, uint256 _unlockWeeks)
        external override
        onlyStaker
    {
        require(_unlockWeeks > 0, "Unlock period less than a week");
        cumulativeEpochUnit = cumulativeEpochUnit.add(_unlockWeeks);

        LibLockTOS.LockedBalance memory lock =
            lockedBalances[user][_lockId];
        uint256 unlockTime = lock.end.add(_unlockWeeks.mul(epochUnit));
        unlockTime = unlockTime.div(epochUnit).mul(epochUnit);
        require(
            unlockTime - block.timestamp < maxTime,
            "Max unlock time is 3 years"
        );
        require(lock.end > block.timestamp, "Lock time already finished");
        require(lock.end < unlockTime, "New lock time must be greater");
        require(lock.amount > 0, "No existing locked TOS");
        _deposit(user, _lockId, 0, unlockTime);

        emit LockUnlockTimeIncreased(user, _lockId, unlockTime);
    }

    /// @inheritdoc ILockTOSv2Action0
    function increaseAmountUnlockTimeByStaker(address user, uint256 _lockId, uint256 _value, uint256 _unlockWeeks)
        external override onlyStaker
    {
        // console.log("increaseAmountUnlockTimeByStaker in ");
        require(_value > 0, "Value locked should be non-zero");
        require(_unlockWeeks > 0, "Unlock period less than a week");

        LibLockTOS.LockedBalance memory lock = lockedBalances[user][_lockId];
        require(lock.withdrawn == false, "Lock is withdrawn");
        require(lock.start > 0, "Lock does not exist");
        require(lock.end > block.timestamp, "Lock time is finished");

        uint256 unlockTime = lock.end.add(_unlockWeeks.mul(epochUnit));
        unlockTime = unlockTime.div(epochUnit).mul(epochUnit);
        require(
            unlockTime - block.timestamp < maxTime,
            "Max unlock time is 3 years"
        );
        require(lock.end < unlockTime, "New lock time must be greater");
        require(lock.amount > 0, "No existing locked TOS");

        cumulativeTOSAmount = cumulativeTOSAmount.add(_value);
        cumulativeEpochUnit = cumulativeEpochUnit.add(_unlockWeeks);

        _deposit(user, _lockId, _value, unlockTime);

        emit LockDeposited(user, _lockId, _value);
        emit LockUnlockTimeIncreased(user, _lockId, unlockTime);
    }



    /// @inheritdoc ILockTOSv2Action0
    function withdrawAllByStaker(address user) external override ifFree onlyStaker{
        uint256[] storage locks = userLocks[user];
        if (locks.length == 0) {
            return;
        }

        for (uint256 i = 0; i < locks.length; i++) {
            LibLockTOS.LockedBalance memory lock = allLocks[locks[i]];
            if (
                lock.withdrawn == false &&
                locks[i] > 0 &&
                lock.amount > 0 &&
                lock.start > 0 &&
                lock.end > 0 &&
                lock.end < block.timestamp
            ) {
                _withdraw(user, locks[i]);
            }
        }
    }

    /// @inheritdoc ILockTOSv2Action0
    function globalCheckpoint() external  override {
        _recordHistoryPoints();
    }

    /// @inheritdoc ILockTOSv2Action0
    function withdrawByStaker(address user, uint256 _lockId) public override ifFree onlyStaker {
        require(_lockId > 0, "_lockId is zero");
        _withdraw(user, _lockId);
    }

    function _withdraw(address user, uint256 _lockId) internal {
        LibLockTOS.LockedBalance memory lockedOld =
            lockedBalances[user][_lockId];
        require(lockedOld.withdrawn == false, "Already withdrawn");
        require(lockedOld.start > 0, "Lock does not exist");
        require(lockedOld.end < block.timestamp, "Lock time not finished");
        require(lockedOld.amount > 0, "No amount to withdraw");

        LibLockTOS.LockedBalance memory lockedNew =
            LibLockTOS.LockedBalance({
                amount: 0,
                start: 0,
                end: 0,
                withdrawn: true
            });

        // Checkpoint
        _checkpoint(lockedNew, lockedOld);

        // Transfer TOS back
        uint256 amount = lockedOld.amount;
        lockedBalances[user][_lockId] = lockedNew;
        allLocks[_lockId] = lockedNew;

        // IERC20(tos).transfer(user, amount);
        emit LockWithdrawn(user, _lockId, amount);
    }

    /// @inheritdoc ILockTOSv2Action0
    function createLockByStaker(address user, uint256 _value, uint256 _unlockWeeks)
        public override
        onlyStaker
        returns (uint256 lockId)
    {
        require(_value > 0, "Value locked should be non-zero");
        require(_unlockWeeks > 0, "Unlock period less than a week");

        cumulativeEpochUnit = cumulativeEpochUnit.add(_unlockWeeks);
        cumulativeTOSAmount = cumulativeTOSAmount.add(_value);
        uint256 unlockTime = block.timestamp.add(_unlockWeeks.mul(epochUnit));
        unlockTime = unlockTime.div(epochUnit).mul(epochUnit);
        require(
            unlockTime - block.timestamp <= maxTime,
            "Max unlock time is 3 years"
        );

        if (userLocks[user].length == 0) { // check if user for the first time
            uniqueUsers.push(user);
        }

        lockIdCounter = lockIdCounter.add(1);
        lockId = lockIdCounter;

        _deposit(user, lockId, _value, unlockTime);
        userLocks[user].push(lockId);

        emit LockCreated(user, lockId, _value, unlockTime);
    }

    /// @inheritdoc ILockTOSv2Action0
    function depositFor(
        address _addr,
        uint256 _lockId,
        uint256 _value
    ) public override onlyStaker {
        require(_value > 0, "Value locked should be non-zero");
        LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][_lockId];
        require(lock.withdrawn == false, "Lock is withdrawn");
        require(lock.start > 0, "Lock does not exist");
        require(lock.end > block.timestamp, "Lock time is finished");

        cumulativeTOSAmount = cumulativeTOSAmount.add(_value);
        _deposit(_addr, _lockId, _value, 0);
        emit LockDeposited(_addr, _lockId, _value);
    }

    /// @inheritdoc ILockTOSv2Action0
    function totalSupplyAt(uint256 _timestamp)
        public
        view override
        returns (uint256)
    {
        if (pointHistory.length == 0) {
            return 0;
        }

        (bool success, LibLockTOS.Point memory point) =
            _findClosestPoint(pointHistory, _timestamp);
        if (!success) {
            return 0;
        }

        point = _fillRecordGaps(point, _timestamp);
        int256 currentBias =
            point.slope * (_timestamp.sub(point.timestamp).toInt256());
        return
            uint256(point.bias > currentBias ? point.bias - currentBias : 0)
                .div(MULTIPLIER);
    }

    /// @inheritdoc ILockTOSv2Action0
    function totalLockedAmountOf(address _addr) external view override returns (uint256) {
        uint256 len = userLocks[_addr].length;
        uint256 stakedAmount = 0;
        for (uint256 i = 0; i < len; ++i) {
            uint256 lockId = userLocks[_addr][i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];
            stakedAmount = stakedAmount.add(lock.amount);
        }
        return stakedAmount;
    }

    /// @inheritdoc ILockTOSv2Action0
    function withdrawableAmountOf(address _addr) external view override returns (uint256) {
        uint256 len = userLocks[_addr].length;
        uint256 amount = 0;
        for(uint i = 0; i < len; i++){
            uint256 lockId = userLocks[_addr][i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];
            if(lock.end <= block.timestamp && lock.amount > 0 && lock.withdrawn == false) {
                amount = amount.add(lock.amount);
            }
        }
        return amount;
    }

    /// @inheritdoc ILockTOSv2Action0
    function totalSupply() external view override returns (uint256) {
        if (pointHistory.length == 0) {
            return 0;
        }

        LibLockTOS.Point memory point = _fillRecordGaps(
            pointHistory[pointHistory.length - 1],
            block.timestamp
        );

        int256 currentBias =
            point.slope.mul(block.timestamp.sub(point.timestamp).toInt256());
        return
            uint256(point.bias > currentBias ? point.bias.sub(currentBias) : 0)
                .div(MULTIPLIER);
    }

    /// @inheritdoc ILockTOSv2Action0
    function balanceOfLockAt(uint256 _lockId, uint256 _timestamp)
        public override
        view
        returns (uint256)
    {
        (bool success, LibLockTOS.Point memory point) =
            _findClosestPoint(lockPointHistory[_lockId], _timestamp);
        if (!success) {
            return 0;
        }
        int256 currentBias =
            point.slope.mul(_timestamp.sub(point.timestamp).toInt256());
        return
            uint256(point.bias > currentBias ? point.bias.sub(currentBias) : 0)
                .div(MULTIPLIER);
    }

    /// @inheritdoc ILockTOSv2Action0
    function balanceOfLock(uint256 _lockId)
        public override
        view
        returns (uint256)
    {
        uint256 len = lockPointHistory[_lockId].length;
        if (len == 0) {
            return 0;
        }

        LibLockTOS.Point memory point = lockPointHistory[_lockId][len - 1];
        int256 currentBias =
            point.slope.mul(block.timestamp.sub(point.timestamp).toInt256());
        return
            uint256(point.bias > currentBias ? point.bias.sub(currentBias) : 0)
                .div(MULTIPLIER);
    }

    /// @inheritdoc ILockTOSv2Action0
    function balanceOfAt(address _addr, uint256 _timestamp)
        public override
        view
        returns (uint256 balance)
    {
        uint256[] memory locks = userLocks[_addr];
        if (locks.length == 0) return 0;
        for (uint256 i = 0; i < locks.length; ++i) {
            balance = balance.add(balanceOfLockAt(locks[i], _timestamp));
        }
    }

    /// @inheritdoc ILockTOSv2Action0
    function balanceOf(address _addr)
        public override
        view
        returns (uint256 balance)
    {
        uint256[] memory locks = userLocks[_addr];
        if (locks.length == 0) return 0;
        for (uint256 i = 0; i < locks.length; ++i) {
            balance = balance.add(balanceOfLock(locks[i]));
        }
    }

    /// @inheritdoc ILockTOSv2Action0
    function locksInfo(uint256 _lockId)
        public override
        view
        returns (
            uint256 start,
            uint256 end,
            uint256 amount
        )
    {
        return (
            allLocks[_lockId].start,
            allLocks[_lockId].end,
            allLocks[_lockId].amount
        );
    }

    /// @inheritdoc ILockTOSv2Action0
    function locksOf(address _addr)
        public override
        view
        returns (uint256[] memory)
    {
        return userLocks[_addr];
    }

    /// @inheritdoc ILockTOSv2Action0
    function withdrawableLocksOf(address _addr)  external view override onlyStaker returns (uint256[] memory) {
        uint256 len = userLocks[_addr].length;
        uint256 size = 0;
        for(uint i = 0; i < len; i++){
            uint256 lockId = userLocks[_addr][i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];
            if(lock.end <= block.timestamp && lock.amount > 0 && lock.withdrawn == false) {
                size++;
            }
        }

        uint256[] memory withdrawable = new uint256[](size);
        size = 0;
        for(uint i = 0; i < len; i++) {
            uint256 lockId = userLocks[_addr][i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];
            if(lock.end <= block.timestamp && lock.amount > 0 && lock.withdrawn == false) {
                withdrawable[size++] = lockId;
            }
        }
        return withdrawable;
    }

    /// @inheritdoc ILockTOSv2Action0
    function activeLocksOf(address _addr)
        public
        view override
        returns (uint256[] memory)
    {
        uint256 len = userLocks[_addr].length;
        uint256 _size = 0;
        for(uint i = 0; i < len; i++){
            uint256 lockId = userLocks[_addr][i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];
            if(lock.end > block.timestamp) {
                _size++;
            }
        }

        uint256[] memory activeLocks = new uint256[](_size);
        _size = 0;
        for(uint i = 0; i < len; i++) {
            uint256 lockId = userLocks[_addr][i];
            LibLockTOS.LockedBalance memory lock = lockedBalances[_addr][lockId];
            if(lock.end > block.timestamp) {
                activeLocks[_size++] = lockId;
            }
        }
        return activeLocks;
    }

    /// @inheritdoc ILockTOSv2Action0
    function pointHistoryOf(uint256 _lockId)
        public
        view override
        returns (LibLockTOS.Point[] memory)
    {
        return lockPointHistory[_lockId];
    }


    function _findClosestPoint(
        LibLockTOS.Point[] storage _history,
        uint256 _timestamp
    ) internal view returns (bool success, LibLockTOS.Point memory point) {
        if (_history.length == 0) {
            return (false, point);
        }

        uint256 left = 0;
        uint256 right = _history.length;
        while (left + 1 < right) {
            uint256 mid = left.add(right).div(2);
            if (_history[mid].timestamp <= _timestamp) {
                left = mid;
            } else {
                right = mid;
            }
        }

        if (_history[left].timestamp <= _timestamp) {
            return (true, _history[left]);
        }
        return (false, point);
    }


    function _deposit(
        address _addr,
        uint256 _lockId,
        uint256 _value,
        uint256 _unlockTime
    ) internal ifFree {
        LibLockTOS.LockedBalance memory lockedOld =
            lockedBalances[_addr][_lockId];
        LibLockTOS.LockedBalance memory lockedNew =
            LibLockTOS.LockedBalance({
                amount: lockedOld.amount,
                start: lockedOld.start,
                end: lockedOld.end,
                withdrawn: false
            });

        // Make new lock
        lockedNew.amount = lockedNew.amount.add(_value);
        if (_unlockTime > 0) {
            lockedNew.end = _unlockTime;
        }
        if (lockedNew.start == 0) {
            lockedNew.start = block.timestamp;
        }

        // Checkpoint
        _checkpoint(lockedNew, lockedOld);

        // Save new lock
        lockedBalances[_addr][_lockId] = lockedNew;
        allLocks[_lockId] = lockedNew;

        // Save user point,
        int256 userSlope =
            lockedNew.amount.mul(MULTIPLIER).div(maxTime).toInt256();
        int256 userBias =
            userSlope.mul(lockedNew.end.sub(block.timestamp).toInt256());
        LibLockTOS.Point memory userPoint =
            LibLockTOS.Point({
                timestamp: block.timestamp,
                slope: userSlope,
                bias: userBias
            });
        lockPointHistory[_lockId].push(userPoint);

        // Transfer TOS
        // require(
        //     IERC20(tos).transferFrom(_addr, address(this), _value),
        //     "LockTOS: fail transferFrom"
        // );
    }

    function _checkpointForSync(
        LibLockTOS.LockedBalance memory lockedNew,
        LibLockTOS.LockedBalance memory lockedOld,
        uint256 curTime
    ) internal {
        uint256 timestamp = curTime;
        LibLockTOS.SlopeChange memory changeNew =
            LibLockTOS.SlopeChange({slope: 0, bias: 0, changeTime: 0});
        LibLockTOS.SlopeChange memory changeOld =
            LibLockTOS.SlopeChange({slope: 0, bias: 0, changeTime: 0});

        // Initialize slope changes
        if (lockedNew.end > timestamp && lockedNew.amount > 0) {
            changeNew.slope = lockedNew
                .amount
                .mul(MULTIPLIER)
                .div(maxTime)
                .toInt256();
            changeNew.bias = changeNew.slope
                .mul(lockedNew.end.sub(timestamp).toInt256());
            changeNew.changeTime = lockedNew.end;
        }
        if (lockedOld.end > timestamp && lockedOld.amount > 0) {
            changeOld.slope = lockedOld
                .amount
                .mul(MULTIPLIER)
                .div(maxTime)
                .toInt256();
            changeOld.bias = changeOld.slope
                .mul(lockedOld.end.sub(timestamp).toInt256());
            changeOld.changeTime = lockedOld.end;
        }

        // Record history gaps
        LibLockTOS.Point memory currentWeekPoint = _recordHistoryPoints();
        currentWeekPoint.bias = currentWeekPoint.bias.add(
            changeNew.bias.sub(changeOld.bias)
        );
        currentWeekPoint.slope = currentWeekPoint.slope.add(
            changeNew.slope.sub(changeOld.slope)
        );
        currentWeekPoint.bias = currentWeekPoint.bias > 0
            ? currentWeekPoint.bias
            : 0;
        currentWeekPoint.slope = currentWeekPoint.slope > 0
            ? currentWeekPoint.slope
            : 0;
        pointHistory[pointHistory.length - 1] = currentWeekPoint;

        // Update slope changes
        _updateSlopeChangesForSync(changeNew, changeOld, curTime);
    }

    function _updateSlopeChangesForSync(
        LibLockTOS.SlopeChange memory changeNew,
        LibLockTOS.SlopeChange memory changeOld,
        uint256 curTIme
    ) internal {
        int256 deltaSlopeNew = slopeChanges[changeNew.changeTime];
        int256 deltaSlopeOld = slopeChanges[changeOld.changeTime];
        if (changeOld.changeTime > curTIme) {
            deltaSlopeOld = deltaSlopeOld.add(changeOld.slope);
            if (changeOld.changeTime == changeNew.changeTime) {
                deltaSlopeOld = deltaSlopeOld.sub(changeNew.slope);
            }
            slopeChanges[changeOld.changeTime] = deltaSlopeOld;
        }
        if (
            changeNew.changeTime > curTIme &&
            changeNew.changeTime > changeOld.changeTime
        ) {
            deltaSlopeNew = deltaSlopeNew.sub(changeNew.slope);
            slopeChanges[changeNew.changeTime] = deltaSlopeNew;
        }
    }

    function _checkpoint(
        LibLockTOS.LockedBalance memory lockedNew,
        LibLockTOS.LockedBalance memory lockedOld
    ) internal {
        uint256 timestamp = block.timestamp;
        LibLockTOS.SlopeChange memory changeNew =
            LibLockTOS.SlopeChange({slope: 0, bias: 0, changeTime: 0});
        LibLockTOS.SlopeChange memory changeOld =
            LibLockTOS.SlopeChange({slope: 0, bias: 0, changeTime: 0});

        // Initialize slope changes
        if (lockedNew.end > timestamp && lockedNew.amount > 0) {
            changeNew.slope = lockedNew
                .amount
                .mul(MULTIPLIER)
                .div(maxTime)
                .toInt256();
            changeNew.bias = changeNew.slope
                .mul(lockedNew.end.sub(timestamp).toInt256());
            changeNew.changeTime = lockedNew.end;
        }
        if (lockedOld.end > timestamp && lockedOld.amount > 0) {
            changeOld.slope = lockedOld
                .amount
                .mul(MULTIPLIER)
                .div(maxTime)
                .toInt256();
            changeOld.bias = changeOld.slope
                .mul(lockedOld.end.sub(timestamp).toInt256());
            changeOld.changeTime = lockedOld.end;
        }

        // Record history gaps
        LibLockTOS.Point memory currentWeekPoint = _recordHistoryPoints();
        currentWeekPoint.bias = currentWeekPoint.bias.add(
            changeNew.bias.sub(changeOld.bias)
        );
        currentWeekPoint.slope = currentWeekPoint.slope.add(
            changeNew.slope.sub(changeOld.slope)
        );
        currentWeekPoint.bias = currentWeekPoint.bias > 0
            ? currentWeekPoint.bias
            : 0;
        currentWeekPoint.slope = currentWeekPoint.slope > 0
            ? currentWeekPoint.slope
            : 0;
        pointHistory[pointHistory.length - 1] = currentWeekPoint;

        // Update slope changes
        _updateSlopeChanges(changeNew, changeOld);
    }


    function _recordHistoryPoints()
        internal
        returns (LibLockTOS.Point memory lastWeek)
    {
        uint256 timestamp = block.timestamp;
        if (pointHistory.length > 0) {
            lastWeek = pointHistory[pointHistory.length - 1];
        } else {
            lastWeek = LibLockTOS.Point({
                bias: 0,
                slope: 0,
                timestamp: timestamp
            });
        }

        // Iterate through all past unrecoreded weeks and record
        uint256 pointTimestampIterator =
            lastWeek.timestamp.div(epochUnit).mul(epochUnit);
        while (pointTimestampIterator != timestamp) {
            pointTimestampIterator = Math.min(
                pointTimestampIterator.add(epochUnit),
                timestamp
            );
            int256 deltaSlope = slopeChanges[pointTimestampIterator];
            int256 deltaTime =
                Math.min(pointTimestampIterator.sub(lastWeek.timestamp), epochUnit).toInt256();
            lastWeek.bias = lastWeek.bias.sub(lastWeek.slope.mul(deltaTime));
            lastWeek.slope = lastWeek.slope.add(deltaSlope);
            lastWeek.bias = lastWeek.bias > 0 ? lastWeek.bias : 0;
            lastWeek.slope = lastWeek.slope > 0 ? lastWeek.slope : 0;
            lastWeek.timestamp = pointTimestampIterator;
            pointHistory.push(lastWeek);
        }
        return lastWeek;
    }


    function _fillRecordGaps(LibLockTOS.Point memory week, uint256 timestamp)
        internal
        view
        returns (LibLockTOS.Point memory)
    {
        // Iterate through all past unrecoreded weeks
        uint256 pointTimestampIterator =
            week.timestamp.div(epochUnit).mul(epochUnit);
        while (pointTimestampIterator != timestamp) {
            pointTimestampIterator = Math.min(
                pointTimestampIterator.add(epochUnit),
                timestamp
            );
            int256 deltaSlope = slopeChanges[pointTimestampIterator];
            int256 deltaTime =
                Math.min(pointTimestampIterator.sub(week.timestamp), epochUnit).toInt256();
            week.bias = week.bias.sub(week.slope.mul(deltaTime));
            week.slope = week.slope.add(deltaSlope);
            week.bias = week.bias > 0 ? week.bias : 0;
            week.slope = week.slope > 0 ? week.slope : 0;
            week.timestamp = pointTimestampIterator;
        }
        return week;
    }


    function _updateSlopeChanges(
        LibLockTOS.SlopeChange memory changeNew,
        LibLockTOS.SlopeChange memory changeOld
    ) internal {
        int256 deltaSlopeNew = slopeChanges[changeNew.changeTime];
        int256 deltaSlopeOld = slopeChanges[changeOld.changeTime];
        if (changeOld.changeTime > block.timestamp) {
            deltaSlopeOld = deltaSlopeOld.add(changeOld.slope);
            if (changeOld.changeTime == changeNew.changeTime) {
                deltaSlopeOld = deltaSlopeOld.sub(changeNew.slope);
            }
            slopeChanges[changeOld.changeTime] = deltaSlopeOld;
        }
        if (
            changeNew.changeTime > block.timestamp &&
            changeNew.changeTime > changeOld.changeTime
        ) {
            deltaSlopeNew = deltaSlopeNew.sub(changeNew.slope);
            slopeChanges[changeNew.changeTime] = deltaSlopeNew;
        }
    }

    function getCurrentTime() external view returns (uint256) {
        return block.timestamp;
    }

    function currentStakedTotalTOS() external view returns (uint256) {
        return IERC20(tos).balanceOf(address(this));
    }

    function version2() external pure returns (bool) {
        return true;
    }

}


// File contracts/stake/LockTOSv2Proxy.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;
pragma abicoder v2;




contract LockTOSv2Proxy is
    LockTOSStorage,
    AccessibleCommon,
    ProxyBase,
    LockTOSv2Storage
{
    event UpgradedLogic(address indexed implementation, uint256 _index, bool _alive);

    modifier lock() {
        require(lock_ == false, "LockTOSv2Proxy: LOCKED");
        lock_ = true;
        _;
        lock_ = false;
    }

    constructor() {}

    /// @dev view implementation address of the proxy[index]
    /// @param _index index of proxy
    /// @return address of the implementation
    function implementation2(uint256 _index) public view returns (address) {
        return _implementation2(_index);
    }

    /// @dev returns the implementation
    function implementation() external view returns (address) {
        return implementation2(0);
    }

    /// @dev set the implementation address and status of the proxy[index]
    /// @param newImplementation Address of the new implementation.
    /// @param _index index
    /// @param _alive _alive
    function setImplementation2(
        address newImplementation,
        uint256 _index,
        bool _alive
    ) external onlyOwner {
        _setImplementation2(newImplementation, _index, _alive);

        UpgradedLogic(newImplementation, _index, _alive);
    }

    /// @dev set alive status of implementation
    /// @param newImplementation Address of the new implementation.
    /// @param _alive alive status
    function setAliveImplementation2(address newImplementation, bool _alive)
        public
        onlyOwner
    {
        _setAliveImplementation2(newImplementation, _alive);
    }

    /// @dev set selectors of Implementation
    /// @param _selectors being added selectors
    /// @param _imp implementation address
    function setSelectorImplementations2(
        bytes4[] calldata _selectors,
        address _imp
    ) public onlyOwner {
        require(
            _selectors.length > 0,
            "LockTOSv2Proxy: _selectors's size is zero"
        );
        require(aliveImplementation[_imp], "LockTOSv2Proxy: _imp is not alive");

        for (uint256 i = 0; i < _selectors.length; i++) {
            require(
                selectorImplementation[_selectors[i]] != _imp,
                "LockTOSv2Proxy: same imp"
            );
            selectorImplementation[_selectors[i]] = _imp;
        }
    }

    /// @dev set the implementation address and status of the proxy[index]
    /// @param newImplementation Address of the new implementation.
    /// @param _index index of proxy
    /// @param _alive alive status
    function _setImplementation2(
        address newImplementation,
        uint256 _index,
        bool _alive
    ) internal {
        require(
            Address.isContract(newImplementation),
            "LockTOSv2Proxy: Cannot set a proxy implementation to a non-contract address"
        );
        if (_alive) proxyImplementation[_index] = newImplementation;
        _setAliveImplementation2(newImplementation, _alive);
    }

    /// @dev set alive status of implementation
    /// @param newImplementation Address of the new implementation.
    /// @param _alive alive status
    function _setAliveImplementation2(address newImplementation, bool _alive)
        internal
    {
        aliveImplementation[newImplementation] = _alive;
    }

    /// @dev view implementation address of the proxy[index]
    /// @param _index index of proxy
    /// @return impl address of the implementation
    function _implementation2(uint256 _index)
        internal
        view
        returns (address impl)
    {
        return proxyImplementation[_index];
    }

    /// @dev view implementation address of selector of function
    /// @param _selector selector of function
    /// @return impl address of the implementation
    function getSelectorImplementation2(bytes4 _selector)
        public
        view
        returns (address impl)
    {
        if (selectorImplementation[_selector] == address(0))
            return proxyImplementation[0];
        else if (aliveImplementation[selectorImplementation[_selector]])
            return selectorImplementation[_selector];
        else return proxyImplementation[0];
    }

    /// @dev receive ether
    receive() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    fallback() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    function _fallback() internal {
        address _impl = getSelectorImplementation2(msg.sig);
        require(
            _impl != address(0) && !pauseProxy,
            "LockTOSv2Proxy: impl OR proxy is false"
        );

        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }
}


// File contracts/interfaces/IProxy.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

interface IProxy {
    function upgradeTo(address impl) external;
}


// File contracts/interfaces/IStake1Logic.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStake1Logic {
    /// @dev event on create vault
    /// @param vault the vault address created
    /// @param paytoken the token used for staking by user
    /// @param cap  allocated reward amount
    event CreatedVault(address indexed vault, address paytoken, uint256 cap);

    /// @dev event on create stake contract in vault
    /// @param vault the vault address
    /// @param stakeContract the stake contract address created
    /// @param phase the phase of TOS platform
    event CreatedStakeContract(
        address indexed vault,
        address indexed stakeContract,
        uint256 phase
    );

    /// @dev event on sale-closed
    /// @param vault the vault address
    event ClosedSale(address indexed vault);

    /// @dev event on setting stake registry
    /// @param stakeRegistry the stakeRegistry address
    event SetStakeRegistry(address stakeRegistry);

    /// Set initial variables
    /// @param _tos  TOS token address
    /// @param _stakeRegistry the registry address
    /// @param _stakeFactory the StakeFactory address
    /// @param _stakeVaultFactory the StakeVaultFactory address
    /// @param _ton  TON address in Tokamak
    /// @param _wton WTON address in Tokamak
    /// @param _depositManager DepositManager address in Tokamak
    /// @param _seigManager SeigManager address in Tokamak
    function setStore(
        address _tos,
        address _stakeRegistry,
        address _stakeFactory,
        address _stakeVaultFactory,
        address _ton,
        address _wton,
        address _depositManager,
        address _seigManager
    ) external;

    /// @dev Set factory address by StakeType

    /// @param _stakeType the stake type , 0:TON, 1: Simple, 2: UniswapV3LP
    /// @param _factory the factory address
    function setFactoryByStakeType(uint256 _stakeType, address _factory)
        external;

    /// @dev create vault
    /// @param _paytoken the token used for staking by user
    /// @param _cap  allocated reward amount
    /// @param _saleStartBlock  the start block that can stake by user
    /// @param _stakeStartBlock the start block that end staking by user and start that can claim reward by user
    /// @param _phase  phase of TOS platform
    /// @param _vaultName  vault's name's hash
    /// @param _stakeType  stakeContract's type, if 0, StakeTON, else if 1 , StakeSimple , else if 2, StakeDefi
    /// @param _defiAddr  extra defi address , default is zero address
    function createVault(
        address _paytoken,
        uint256 _cap,
        uint256 _saleStartBlock,
        uint256 _stakeStartBlock,
        uint256 _phase,
        bytes32 _vaultName,
        uint256 _stakeType,
        address _defiAddr
    ) external;

    /// @dev create stake contract in vault
    /// @param _phase the phase of TOS platform
    /// @param _vault  vault's address
    /// @param token  the reward token's address
    /// @param paytoken  the token used for staking by user
    /// @param periodBlock  the period that generate reward
    /// @param _name  the stake contract's name
    function createStakeContract(
        uint256 _phase,
        address _vault,
        address token,
        address paytoken,
        uint256 periodBlock,
        string memory _name
    ) external;

    /// @dev create stake contract in vault
    /// @param _phase phase of TOS platform
    /// @param _vaultName vault's name's hash
    /// @param _vault vault's address
    function addVault(
        uint256 _phase,
        bytes32 _vaultName,
        address _vault
    ) external;

    /// @dev end to staking by user
    /// @param _vault vault's address
    function closeSale(address _vault) external;

    /// @dev list of stakeContracts in vault
    /// @param _vault vault's address
    function stakeContractsOfVault(address _vault)
        external
        view
        returns (address[] memory);

    /// @dev list of vaults in _phase
    /// @param _phase the phase number
    function vaultsOfPhase(uint256 _phase)
        external
        view
        returns (address[] memory);

    /// @dev stake in tokamak's layer2
    /// @param _stakeContract the stakeContract's address
    /// @param _layer2 the layer2 address in Tokamak
    /// @param stakeAmount the amount that stake to layer2
    function tokamakStaking(
        address _stakeContract,
        address _layer2,
        uint256 stakeAmount
    ) external;

    /// @dev Requests unstaking in tokamak's layer2
    /// @param _stakeContract the stakeContract's address
    /// @param _layer2 the layer2 address in Tokamak
    /// @param amount the amount of unstaking
    function tokamakRequestUnStaking(
        address _stakeContract,
        address _layer2,
        uint256 amount
    ) external;

    /// @dev Requests unstaking the amount of all  in tokamak's layer2
    /// @param _stakeContract the stakeContract's address
    /// @param _layer2 the layer2 address in Tokamak
    function tokamakRequestUnStakingAll(address _stakeContract, address _layer2)
        external;

    /// @dev Processes unstaking the requested unstaking amount in tokamak's layer2
    /// @param _stakeContract the stakeContract's address
    /// @param _layer2 the layer2 address in Tokamak
    function tokamakProcessUnStaking(address _stakeContract, address _layer2)
        external;

    /// @dev Swap TON to TOS using uniswap v3
    /// @dev this function used in StakeTON ( stakeType=0 )
    /// @param _stakeContract the stakeContract's address
    /// @param amountIn the input amount
    /// @param amountOutMinimum the minimun output amount
    /// @param deadline deadline
    /// @param sqrtPriceLimitX96 sqrtPriceLimitX96
    /// @param _type the function type, if 0, use exactInputSingle function, else if, use exactInput function
    function exchangeWTONtoTOS(
        address _stakeContract,
        uint256 amountIn,
        uint256 amountOutMinimum,
        uint256 deadline,
        uint160 sqrtPriceLimitX96,
        uint256 _type
    ) external returns (uint256 amountOut);
}


// File contracts/interfaces/IStakeTONTokamak.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStakeTONTokamak {
    /// @dev  staking the staked TON in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    /// @param stakeAmount the amount that stake to layer2
    function tokamakStaking(address _layer2, uint256 stakeAmount) external;

    /// @dev  request unstaking the wtonAmount in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    /// @param wtonAmount the amount requested to unstaking
    function tokamakRequestUnStaking(address _layer2, uint256 wtonAmount)
        external;

    /// @dev Requests unstaking the amount of all  in tokamak's layer2
    /// @param _layer2 the layer2 address in Tokamak
    function tokamakRequestUnStakingAll(address _layer2) external;

    /// @dev process unstaking in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    function tokamakProcessUnStaking(address _layer2) external;

    /// @dev exchange holded WTON to TOS using uniswap
    /// @param _amountIn the input amount
    /// @param _amountOutMinimum the minimun output amount
    /// @param _deadline deadline
    /// @param sqrtPriceLimitX96 sqrtPriceLimitX96
    /// @param _kind the function type, if 0, use exactInputSingle function, else if, use exactInput function
    /// @return amountOut the amount of exchanged out token
    function exchangeWTONtoTOS(
        uint256 _amountIn,
        uint256 _amountOutMinimum,
        uint256 _deadline,
        uint160 sqrtPriceLimitX96,
        uint256 _kind
    ) external returns (uint256 amountOut);
}


// File contracts/interfaces/IStakeUniswapV3.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStakeUniswapV3 {
    /// @dev stake tokenId of UniswapV3
    /// @param tokenId  tokenId
    /// @param deadline the deadline that valid the owner's signature
    /// @param v the owner's signature - v
    /// @param r the owner's signature - r
    /// @param s the owner's signature - s
    function stakePermit(
        uint256 tokenId,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /// @dev stake tokenId of UniswapV3
    /// @param tokenId  tokenId
    function stake(uint256 tokenId) external;

    /// @dev view mining information of tokenId
    /// @param tokenId  tokenId
    function getMiningTokenId(uint256 tokenId)
        external
        returns (
            uint256 miningAmount,
            uint256 nonMiningAmount,
            uint256 minableAmount,
            uint160 secondsInside,
            uint256 secondsInsideDiff256,
            uint256 liquidity,
            uint256 balanceOfTokenIdRay,
            uint256 minableAmountRay,
            uint256 secondsInside256,
            uint256 secondsAbsolute256
        );

    /// @dev withdraw the deposited token.
    ///      The amount mined with the deposited liquidity is claimed and taken.
    ///      The amount of mining taken is changed in proportion to the amount of time liquidity
    ///      has been provided since recent mining
    /// @param tokenId  tokenId
    function withdraw(uint256 tokenId) external;

    /// @dev The amount mined with the deposited liquidity is claimed and taken.
    ///      The amount of mining taken is changed in proportion to the amount of time liquidity
    ///       has been provided since recent mining
    /// @param tokenId  tokenId
    function claim(uint256 tokenId) external;

    // function setPool(
    //     address token0,
    //     address token1,
    //     string calldata defiInfoName
    // ) external;

    /// @dev
    function getUserStakedTokenIds(address user)
        external
        view
        returns (uint256[] memory ids);

    /// @dev tokenId's deposited information
    /// @param tokenId   tokenId
    /// @return poolAddress   poolAddress
    /// @return tick tick,
    /// @return liquidity liquidity,
    /// @return args liquidity,  startTime, claimedTime, startBlock, claimedBlock, claimedAmount
    /// @return secondsPL secondsPerLiquidityInsideInitialX128, secondsPerLiquidityInsideX128Las
    function getDepositToken(uint256 tokenId)
        external
        view
        returns (
            address poolAddress,
            int24[2] memory tick,
            uint128 liquidity,
            uint256[5] memory args,
            uint160[2] memory secondsPL
        );

    function getUserStakedTotal(address user)
        external
        view
        returns (
            uint256 totalDepositAmount,
            uint256 totalClaimedAmount,
            uint256 totalUnableClaimAmount
        );

    /// @dev Give the infomation of this stakeContracts
    /// @return return1  [token, vault, stakeRegistry, coinage]
    /// @return return2  [poolToken0, poolToken1, nonfungiblePositionManager, uniswapV3FactoryAddress]
    /// @return return3  [totalStakers, totalStakedAmount, rewardClaimedTotal,rewardNonLiquidityClaimTotal]
    function infos()
        external
        view
        returns (
            address[4] memory,
            address[4] memory,
            uint256[4] memory
        );

    /*
    /// @dev pool's infos
    /// @return factory  pool's factory address
    /// @return token0  token0 address
    /// @return token1  token1 address
    /// @return fee  fee
    /// @return tickSpacing  tickSpacing
    /// @return maxLiquidityPerTick  maxLiquidityPerTick
    /// @return liquidity  pool's liquidity
    function poolInfos()
        external
        view
        returns (
            address factory,
            address token0,
            address token1,
            uint24 fee,
            int24 tickSpacing,
            uint128 maxLiquidityPerTick,
            uint128 liquidity
        );

    /// @dev key's info
    /// @param key hash(owner, tickLower, tickUpper)
    /// @return _liquidity  key's liquidity
    /// @return feeGrowthInside0LastX128  key's feeGrowthInside0LastX128
    /// @return feeGrowthInside1LastX128  key's feeGrowthInside1LastX128
    /// @return tokensOwed0  key's tokensOwed0
    /// @return tokensOwed1  key's tokensOwed1
    function poolPositions(bytes32 key)
        external
        view
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );
    */

    /// @dev pool's slot0 (current position)
    /// @return sqrtPriceX96  The current price of the pool as a sqrt(token1/token0) Q64.96 value
    /// @return tick  The current tick of the pool
    /// @return observationIndex  The index of the last oracle observation that was written,
    /// @return observationCardinality  The current maximum number of observations stored in the pool,
    /// @return observationCardinalityNext  The next maximum number of observations, to be updated when the observation.
    /// @return feeProtocol  The protocol fee for both tokens of the pool
    /// @return unlocked  Whether the pool is currently locked to reentrancy
    function poolSlot0()
        external
        view
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        );

    /*
    /// @dev _tokenId's position
    /// @param _tokenId  tokenId
    /// @return nonce  the nonce for permits
    /// @return operator  the address that is approved for spending this token
    /// @return token0  The address of the token0 for pool
    /// @return token1  The address of the token1 for pool
    /// @return fee  The fee associated with the pool
    /// @return tickLower  The lower end of the tick range for the position
    /// @return tickUpper  The higher end of the tick range for the position
    /// @return liquidity  The liquidity of the position
    /// @return feeGrowthInside0LastX128  The fee growth of token0 as of the last action on the individual position
    /// @return feeGrowthInside1LastX128  The fee growth of token1 as of the last action on the individual position
    /// @return tokensOwed0  The uncollected amount of token0 owed to the position as of the last computation
    /// @return tokensOwed1  The uncollected amount of token1 owed to the position as of the last computation
    function npmPositions(uint256 _tokenId)
        external
        view
        returns (
            uint96 nonce,
            address operator,
            address token0,
            address token1,
            uint24 fee,
            int24 tickLower,
            int24 tickUpper,
            uint128 liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    /// @dev snapshotCumulativesInside
    /// @param tickLower  The lower tick of the range
    /// @param tickUpper  The upper tick of the range
    /// @return tickCumulativeInside  The snapshot of the tick accumulator for the range
    /// @return secondsPerLiquidityInsideX128  The snapshot of seconds per liquidity for the range
    /// @return secondsInside  The snapshot of seconds per liquidity for the range
    /// @return curTimestamps  current Timestamps
    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)
        external
        returns (
            int56 tickCumulativeInside,
            uint160 secondsPerLiquidityInsideX128,
            uint32 secondsInside,
            uint32 curTimestamps
        );
    */
    /// @dev mining end time
    /// @return endTime mining end time
    function miningEndTime() external view returns (uint256 endTime);

    /// @dev get price
    /// @param decimals pool's token1's decimals (ex. 1e18)
    /// @return price price
    function getPrice(uint256 decimals) external view returns (uint256 price);

    /// @dev Liquidity provision time (seconds) at a specific point in time since the token was recently mined
    /// @param tokenId token id
    /// @param expectBlocktimestamp The specific time you want to know (It must be greater than the last mining time.) set it to the current time.
    /// @return secondsAbsolute Absolute duration (in seconds) from the latest mining to the time of expectTime
    /// @return secondsInsideDiff256 The time (in seconds) that the token ID provided liquidity from the last claim (or staking time) to the present time.
    /// @return expectTime time used in the calculation
    function currentliquidityTokenId(
        uint256 tokenId,
        uint256 expectBlocktimestamp
    )
        external
        view
        returns (
            uint256 secondsAbsolute,
            uint256 secondsInsideDiff256,
            uint256 expectTime
        );

    /// @dev Coinage balance information that tokens can receive in the future
    /// @param tokenId token id
    /// @param expectBlocktimestamp The specific time you want to know (It must be greater than the last mining time.)
    /// @return currentTotalCoinage Current Coinage Total Balance
    /// @return afterTotalCoinage Total balance of Coinage at a future point in time
    /// @return afterBalanceTokenId The total balance of the coin age of the token at a future time
    /// @return expectTime future time
    /// @return addIntervalTime Duration (in seconds) between the future time and the recent mining time
    function currentCoinageBalanceTokenId(
        uint256 tokenId,
        uint256 expectBlocktimestamp
    )
        external
        view
        returns (
            uint256 currentTotalCoinage,
            uint256 afterTotalCoinage,
            uint256 afterBalanceTokenId,
            uint256 expectTime,
            uint256 addIntervalTime
        );

    /// @dev Estimated additional claimable amount on a specific time
    /// @param tokenId token id
    /// @param expectBlocktimestamp The specific time you want to know (It must be greater than the last mining time.)
    /// @return miningAmount Amount you can claim
    /// @return nonMiningAmount The amount that burn without receiving a claim
    /// @return minableAmount Total amount of mining allocated at the time of claim
    /// @return minableAmountRay Total amount of mining allocated at the time of claim (ray unit)
    /// @return expectTime time used in the calculation
    function expectedPlusClaimableAmount(
        uint256 tokenId,
        uint256 expectBlocktimestamp
    )
        external
        view
        returns (
            uint256 miningAmount,
            uint256 nonMiningAmount,
            uint256 minableAmount,
            uint256 minableAmountRay,
            uint256 expectTime
        );
}


// File contracts/stake/StakeProxyStorage.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

//import "../interfaces/IStakeProxyStorage.sol";



/// @title The storage of StakeProxy
contract StakeProxyStorage {
    /// @dev stakeRegistry
    IStakeRegistry public stakeRegistry;

    /// @dev stakeFactory
    IStakeFactory public stakeFactory;

    /// @dev stakeVaultFactory
    IStakeVaultFactory public stakeVaultFactory;

    /// @dev TOS address
    address public tos;

    /// @dev TON address in Tokamak
    address public ton;

    /// @dev WTON address in Tokamak
    address public wton;

    /// @dev Depositmanager address in Tokamak
    address public depositManager;

    /// @dev SeigManager address in Tokamak
    address public seigManager;

    /// @dev flag for pause proxy
    bool public pauseProxy;

    /// @dev implementation of proxy index
    mapping(uint256 => address) public proxyImplementation;

    mapping(address => bool) public aliveImplementation;

    mapping(bytes4 => address) public selectorImplementation;
}


// File contracts/stake/Stake1Logic.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;







/// @title The logic of TOS Plaform
/// @notice Admin can createVault, createStakeContract.
/// User can excute the tokamak staking function of each contract through this logic.
contract Stake1Logic is StakeProxyStorage, AccessibleCommon, IStake1Logic {
    modifier nonZeroAddress(address _addr) {
        require(_addr != address(0), "Stake1Logic:zero address");
        _;
    }

    /*
    /// @dev event on create vault
    /// @param vault the vault address created
    /// @param paytoken the token used for staking by user
    /// @param cap  allocated reward amount
    event CreatedVault(address indexed vault, address paytoken, uint256 cap);

    /// @dev event on create stake contract in vault
    /// @param vault the vault address
    /// @param stakeContract the stake contract address created
    /// @param phase the phase of TOS platform
    event CreatedStakeContract(
        address indexed vault,
        address indexed stakeContract,
        uint256 phase
    );

    /// @dev event on sale-closed
    /// @param vault the vault address
    event ClosedSale(address indexed vault);

    /// @dev event on setting stake registry
    /// @param stakeRegistry the stakeRegistry address
    event SetStakeRegistry(address stakeRegistry);
    */

    constructor() {}

    /// @dev upgrade to the logic of _stakeProxy
    /// @param _stakeProxy the StakeProxy address, it is stakeContract address in vault.
    /// @param _implementation new logic address
    function upgradeStakeTo(address _stakeProxy, address _implementation)
        external
        onlyOwner
    {
        IProxy(_stakeProxy).upgradeTo(_implementation);
    }

    /// @dev grant the role to account in target
    /// @param target target address
    /// @param role  byte32 of role
    /// @param account account address
    function grantRole(
        address target,
        bytes32 role,
        address account
    ) external onlyOwner {
        AccessControl(target).grantRole(role, account);
    }

    /// @dev revoke the role to account in target
    /// @param target target address
    /// @param role  byte32 of role
    /// @param account account address
    function revokeRole(
        address target,
        bytes32 role,
        address account
    ) external onlyOwner {
        AccessControl(target).revokeRole(role, account);
    }

    /// @dev Sets TOS address
    /// @param _tos new TOS address
    function setTOS(address _tos) public onlyOwner nonZeroAddress(_tos) {
        tos = _tos;
    }

    /// @dev Sets Stake Registry address
    /// @param _stakeRegistry new StakeRegistry address
    function setStakeRegistry(address _stakeRegistry)
        public
        onlyOwner
        nonZeroAddress(_stakeRegistry)
    {
        stakeRegistry = IStakeRegistry(_stakeRegistry);
        emit SetStakeRegistry(_stakeRegistry);
    }

    /// @dev Sets StakeFactory address
    /// @param _stakeFactory new StakeFactory address
    function setStakeFactory(address _stakeFactory)
        public
        onlyOwner
        nonZeroAddress(_stakeFactory)
    {
        stakeFactory = IStakeFactory(_stakeFactory);
    }

    /// @dev Set factory address by StakeType
    /// @param _stakeType the stake type , 0:TON, 1: Simple, 2: UniswapV3LP
    /// @param _factory the factory address
    function setFactoryByStakeType(uint256 _stakeType, address _factory)
        external
        override
        onlyOwner
        nonZeroAddress(address(stakeFactory))
    {
        stakeFactory.setFactoryByStakeType(_stakeType, _factory);
    }

    /// @dev Sets StakeVaultFactory address
    /// @param _stakeVaultFactory new StakeVaultFactory address
    function setStakeVaultFactory(address _stakeVaultFactory)
        external
        onlyOwner
        nonZeroAddress(_stakeVaultFactory)
    {
        stakeVaultFactory = IStakeVaultFactory(_stakeVaultFactory);
    }

    /// Set initial variables
    /// @param _tos  TOS token address
    /// @param _stakeRegistry the registry address
    /// @param _stakeFactory the StakeFactory address
    /// @param _stakeVaultFactory the StakeVaultFactory address
    /// @param _ton  TON address in Tokamak
    /// @param _wton WTON address in Tokamak
    /// @param _depositManager DepositManager address in Tokamak
    /// @param _seigManager SeigManager address in Tokamak
    function setStore(
        address _tos,
        address _stakeRegistry,
        address _stakeFactory,
        address _stakeVaultFactory,
        address _ton,
        address _wton,
        address _depositManager,
        address _seigManager
    )
        external
        override
        onlyOwner
        nonZeroAddress(_stakeVaultFactory)
        nonZeroAddress(_ton)
        nonZeroAddress(_wton)
        nonZeroAddress(_depositManager)
    {
        setTOS(_tos);
        setStakeRegistry(_stakeRegistry);
        setStakeFactory(_stakeFactory);
        stakeVaultFactory = IStakeVaultFactory(_stakeVaultFactory);

        ton = _ton;
        wton = _wton;
        depositManager = _depositManager;
        seigManager = _seigManager;
    }

    /// @dev create vault
    /// @param _paytoken the token used for staking by user
    /// @param _cap  allocated reward amount
    /// @param _saleStartBlock  the start block that can stake by user
    /// @param _stakeStartBlock the start block that end staking by user and start that can claim reward by user
    /// @param _phase  phase of TOS platform
    /// @param _vaultName  vault's name's hash
    /// @param _stakeType  stakeContract's type, if 0, StakeTON, else if 1 , StakeSimple , else if 2, StakeDefi
    /// @param _defiAddr  extra defi address , default is zero address
    function createVault(
        address _paytoken,
        uint256 _cap,
        uint256 _saleStartBlock,
        uint256 _stakeStartBlock,
        uint256 _phase,
        bytes32 _vaultName,
        uint256 _stakeType,
        address _defiAddr
    ) external override onlyOwner nonZeroAddress(address(stakeVaultFactory)) {
        address vault =
            stakeVaultFactory.create(
                _phase,
                [tos, _paytoken, address(stakeFactory), _defiAddr],
                [_stakeType, _cap, _saleStartBlock, _stakeStartBlock],
                address(this)
            );
        require(vault != address(0), "Stake1Logic: vault is zero");
        stakeRegistry.addVault(vault, _phase, _vaultName);

        emit CreatedVault(vault, _paytoken, _cap);
    }

    /// @dev create stake contract in vault
    /// @param _phase the phase of TOS platform
    /// @param _vault  vault's address
    /// @param token  the reward token's address
    /// @param paytoken  the token used for staking by user
    /// @param periodBlock  the period that generate reward
    /// @param _name  the stake contract's name
    function createStakeContract(
        uint256 _phase,
        address _vault,
        address token,
        address paytoken,
        uint256 periodBlock,
        string memory _name
    ) external override onlyOwner {
        require(
            stakeRegistry.validVault(_phase, _vault),
            "Stake1Logic: unvalidVault"
        );

        IStake1Vault vault = IStake1Vault(_vault);

        (
            address[2] memory addrInfos,
            ,
            uint256 stakeType,
            uint256[3] memory iniInfo,
            ,

        ) = vault.infos();

        require(paytoken == addrInfos[0], "Stake1Logic: differrent paytoken");
        uint256 phase = _phase;
        address[4] memory _addr = [token, addrInfos[0], _vault, addrInfos[1]];

        // solhint-disable-next-line max-line-length
        address _contract =
            stakeFactory.create(
                stakeType,
                _addr,
                address(stakeRegistry),
                [iniInfo[0], iniInfo[1], periodBlock]
            );
        require(_contract != address(0), "Stake1Logic: deploy fail");

        IStake1Vault(_vault).addSubVaultOfStake(_name, _contract, periodBlock);
        stakeRegistry.addStakeContract(address(vault), _contract);

        emit CreatedStakeContract(address(vault), _contract, phase);
    }

    /// @dev create stake contract in vault
    /// @param _phase phase of TOS platform
    /// @param _vaultName vault's name's hash
    /// @param _vault vault's address
    function addVault(
        uint256 _phase,
        bytes32 _vaultName,
        address _vault
    ) external override onlyOwner {
        stakeRegistry.addVault(_vault, _phase, _vaultName);
    }

    /// @dev end to staking by user
    /// @param _vault vault's address
    function closeSale(address _vault) external override {
        IStake1Vault(_vault).closeSale();

        emit ClosedSale(_vault);
    }

    /// @dev list of stakeContracts in vault
    /// @param _vault vault's address
    function stakeContractsOfVault(address _vault)
        external
        view
        override
        nonZeroAddress(_vault)
        returns (address[] memory)
    {
        return IStake1Vault(_vault).stakeAddressesAll();
    }

    /// @dev list of vaults in _phase
    /// @param _phase the _phase number
    function vaultsOfPhase(uint256 _phase)
        external
        view
        override
        returns (address[] memory)
    {
        return stakeRegistry.phasesAll(_phase);
    }

    /// @dev stake in tokamak's layer2
    /// @param _stakeContract the stakeContract's address
    /// @param _layer2 the layer2 address in Tokamak
    /// @param stakeAmount the amount that stake to layer2
    function tokamakStaking(
        address _stakeContract,
        address _layer2,
        uint256 stakeAmount
    ) external override {
        IStakeTONTokamak(_stakeContract).tokamakStaking(_layer2, stakeAmount);
    }

    /// @dev Requests unstaking the amount WTON in tokamak's layer2
    /// @param _stakeContract the stakeContract's address
    /// @param _layer2 the layer2 address in Tokamak
    /// @param amount the amount of unstaking
    function tokamakRequestUnStaking(
        address _stakeContract,
        address _layer2,
        uint256 amount
    ) external override {
        IStakeTONTokamak(_stakeContract).tokamakRequestUnStaking(
            _layer2,
            amount
        );
    }

    /// @dev Requests unstaking the amount of all  in tokamak's layer2
    /// @param _stakeContract the stakeContract's address
    /// @param _layer2 the layer2 address in Tokamak
    function tokamakRequestUnStakingAll(address _stakeContract, address _layer2)
        external
        override
    {
        IStakeTONTokamak(_stakeContract).tokamakRequestUnStakingAll(_layer2);
    }

    /// @dev Processes unstaking the requested unstaking amount in tokamak's layer2
    /// @param _stakeContract the stakeContract's address
    /// @param _layer2 the layer2 address in Tokamak
    function tokamakProcessUnStaking(address _stakeContract, address _layer2)
        external
        override
    {
        IStakeTONTokamak(_stakeContract).tokamakProcessUnStaking(_layer2);
    }

    /// @dev Swap TON to TOS using uniswap v3
    /// @dev this function used in StakeTON ( stakeType=0 )
    /// @param _stakeContract the stakeContract's address
    /// @param amountIn the input amount
    /// @param amountOutMinimum the minimun output amount
    /// @param deadline deadline
    /// @param sqrtPriceLimitX96 sqrtPriceLimitX96
    /// @param _type the function type, if 0, use exactInputSingle function, else if, use exactInput function
    function exchangeWTONtoTOS(
        address _stakeContract,
        uint256 amountIn,
        uint256 amountOutMinimum,
        uint256 deadline,
        uint160 sqrtPriceLimitX96,
        uint256 _type
    ) external override returns (uint256 amountOut) {
        return
            IStakeTONTokamak(_stakeContract).exchangeWTONtoTOS(
                amountIn,
                amountOutMinimum,
                deadline,
                sqrtPriceLimitX96,
                _type
            );
    }
}


// File contracts/interfaces/IStakeProxy.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStakeProxy {
    /// @dev Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external;

    /// @dev Set implementation contract
    /// @param impl New implementation contract address
    /// @param _index index of proxy
    function upgradeTo(address impl, uint256 _index) external;

    /// @dev view implementation address of the proxy[index]
    /// @param _index index of proxy
    /// @return address of the implementation
    function implementation(uint256 _index) external view returns (address);

    /// @dev set the implementation address and status of the proxy[index]
    /// @param newImplementation Address of the new implementation.
    /// @param _index index of proxy
    /// @param _alive alive status
    function setImplementation(
        address newImplementation,
        uint256 _index,
        bool _alive
    ) external;

    /// @dev set alive status of implementation
    /// @param newImplementation Address of the new implementation.
    /// @param _alive alive status
    function setAliveImplementation(address newImplementation, bool _alive)
        external;

    /// @dev set selectors of Implementation
    /// @param _selectors being added selectors
    /// @param _imp implementation address
    function setSelectorImplementations(
        bytes4[] calldata _selectors,
        address _imp
    ) external;

    /// @dev set the implementation address and status of the proxy[index]
    /// @param _selector the selector of function
    function getSelectorImplementation(bytes4 _selector)
        external
        view
        returns (address impl);
}


// File contracts/stake/Stake1Proxy.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;



//import "./ProxyBase.sol";

/// @title The proxy of TOS Plaform
/// @notice Admin can createVault, createStakeContract.
/// User can excute the tokamak staking function of each contract through this logic.
contract Stake1Proxy is StakeProxyStorage, AccessibleCommon, IStakeProxy {
    event Upgraded(address indexed implementation, uint256 _index);

    /// @dev constructor of Stake1Proxy
    constructor(address _logic) {
        //assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

        require(_logic != address(0), "Stake1Proxy: logic is zero");

        _setImplementation(_logic, 0, true);

        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, address(this));
    }

    /// @dev Set pause state
    /// @param _pause true:pause or false:resume
    function setProxyPause(bool _pause) external override onlyOwner {
        pauseProxy = _pause;
    }

    /// @dev Set implementation contract
    /// @param impl New implementation contract address
    /// @param _index index of proxy
    function upgradeTo(address impl, uint256 _index)
        external
        override
        onlyOwner
    {
        require(impl != address(0), "input is zero");
        require(_implementation(_index) != impl, "same");

        setAliveImplementation(_implementation(_index), false);
        _setImplementation(impl, _index, true);

        emit Upgraded(impl, _index);
    }

    /// @dev view implementation address of the proxy[index]
    /// @param _index index of proxy
    /// @return address of the implementation
    function implementation(uint256 _index)
        external
        view
        override
        returns (address)
    {
        return _implementation(_index);
    }

    /// @dev set the implementation address and status of the proxy[index]
    /// @param newImplementation Address of the new implementation.
    /// @param _index index
    /// @param _alive _alive
    function setImplementation(
        address newImplementation,
        uint256 _index,
        bool _alive
    ) external override onlyOwner {
        _setImplementation(newImplementation, _index, _alive);
    }

    /// @dev set alive status of implementation
    /// @param newImplementation Address of the new implementation.
    /// @param _alive alive status
    function setAliveImplementation(address newImplementation, bool _alive)
        public
        override
        onlyOwner
    {
        _setAliveImplementation(newImplementation, _alive);
    }

    /// @dev set selectors of Implementation
    /// @param _selectors being added selectors
    /// @param _imp implementation address
    function setSelectorImplementations(
        bytes4[] calldata _selectors,
        address _imp
    ) public override onlyOwner {
        require(
            _selectors.length > 0,
            "Stake1Proxy: _selectors's size is zero"
        );
        require(aliveImplementation[_imp], "Stake1Proxy: _imp is not alive");

        for (uint256 i = 0; i < _selectors.length; i++) {
            require(
                selectorImplementation[_selectors[i]] != _imp,
                "Stake1Proxy: same imp"
            );
            selectorImplementation[_selectors[i]] = _imp;
        }
    }

    /// @dev set the implementation address and status of the proxy[index]
    /// @param newImplementation Address of the new implementation.
    /// @param _index index of proxy
    /// @param _alive alive status
    function _setImplementation(
        address newImplementation,
        uint256 _index,
        bool _alive
    ) internal {
        require(
            Address.isContract(newImplementation),
            "ProxyBase: Cannot set a proxy implementation to a non-contract address"
        );
        if (_alive) proxyImplementation[_index] = newImplementation;
        _setAliveImplementation(newImplementation, _alive);
    }

    /// @dev set alive status of implementation
    /// @param newImplementation Address of the new implementation.
    /// @param _alive alive status
    function _setAliveImplementation(address newImplementation, bool _alive)
        internal
    {
        aliveImplementation[newImplementation] = _alive;
    }

    /// @dev view implementation address of the proxy[index]
    /// @param _index index of proxy
    /// @return impl address of the implementation
    function _implementation(uint256 _index)
        internal
        view
        returns (address impl)
    {
        return proxyImplementation[_index];
    }

    /// @dev view implementation address of selector of function
    /// @param _selector selector of function
    /// @return impl address of the implementation
    function getSelectorImplementation(bytes4 _selector)
        public
        view
        override
        returns (address impl)
    {
        if (selectorImplementation[_selector] == address(0))
            return proxyImplementation[0];
        else if (aliveImplementation[selectorImplementation[_selector]])
            return selectorImplementation[_selector];
        else return proxyImplementation[0];
    }

    /// @dev receive ether
    receive() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    fallback() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    function _fallback() internal {
        address _impl = getSelectorImplementation(msg.sig);
        require(_impl != address(0) && !pauseProxy, "impl OR proxy is false");

        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }
}


// File contracts/interfaces/IStake1Storage.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStake1Storage {
    /// @dev reward token : TOS
    function token() external view returns (address);

    /// @dev registry
    function stakeRegistry() external view returns (address);

    /// @dev paytoken is the token that the user stakes. ( if paytoken is ether, paytoken is address(0) )
    function paytoken() external view returns (address);

    /// @dev A vault that holds TOS rewards.
    function vault() external view returns (address);

    /// @dev the start block for sale.
    function saleStartBlock() external view returns (uint256);

    /// @dev the staking start block, once staking starts, users can no longer apply for staking.
    function startBlock() external view returns (uint256);

    /// @dev the staking end block.
    function endBlock() external view returns (uint256);

    //// @dev the total amount claimed
    function rewardClaimedTotal() external view returns (uint256);

    /// @dev the total staked amount
    function totalStakedAmount() external view returns (uint256);

    /// @dev total stakers
    function totalStakers() external view returns (uint256);

    /// @dev user's staked information
    function getUserStaked(address user)
        external
        view
        returns (
            uint256 amount,
            uint256 claimedBlock,
            uint256 claimedAmount,
            uint256 releasedBlock,
            uint256 releasedAmount,
            uint256 releasedTOSAmount,
            bool released
        );
}


// File contracts/stake/Stake1Vault.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;
pragma abicoder v2;







/// @title TOS Token's Vault - stores the TOS for the period of time
/// @notice A vault is associated with the set of stake contracts.
/// Stake contracts can interact with the vault to claim TOS tokens
contract Stake1Vault is StakeVaultStorage, IStake1Vault {
    using SafeMath for uint256;

    /// @dev event on sale-closed
    event ClosedSale();

    /// @dev event of according to request from(staking contract)  the amount of compensation is paid to to.
    /// @param from the stakeContract address that call claim
    /// @param to the address that will receive the reward
    /// @param amount the amount of reward
    event ClaimedReward(address indexed from, address to, uint256 amount);

    /// @dev constructor of Stake1Vault
    constructor() {}

    /// @dev receive function
    receive() external payable {
        revert("cannot receive Ether");
    }

    /// @dev Sets TOS address
    /// @param _tos  TOS address
    function setTOS(address _tos) external override onlyOwner {
        require(_tos != address(0), "Stake1Vault: input is zero");
        tos = _tos;
    }

    /// @dev Change cap of the vault
    /// @param _cap  allocated reward amount
    function changeCap(uint256 _cap) external override onlyOwner {
        require(_cap > 0 && cap != _cap, "Stake1Vault: changeCap fails");
        cap = _cap;
    }

    /// @dev Set Defi Address
    /// @param _defiAddr DeFi related address
    function setDefiAddr(address _defiAddr) external override onlyOwner {
        require(
            _defiAddr != address(0) && defiAddr != _defiAddr,
            "Stake1Vault: _defiAddr is zero"
        );
        defiAddr = _defiAddr;
    }

    /// @dev If the vault has more money than the reward to give, the owner can withdraw the remaining amount.
    /// @param _amount the amount of withdrawal
    function withdrawReward(uint256 _amount) external override onlyOwner {
        require(saleClosed, "Stake1Vault: didn't end sale");
        uint256 rewardAmount = 0;
        for (uint256 i = 0; i < stakeAddresses.length; i++) {
            rewardAmount = rewardAmount
                .add(stakeInfos[stakeAddresses[i]].totalRewardAmount)
                .sub(stakeInfos[stakeAddresses[i]].claimRewardAmount);
        }
        uint256 balanceOf = IERC20(tos).balanceOf(address(this));
        require(
            balanceOf >= rewardAmount.add(_amount),
            "Stake1Vault: insuffient"
        );
        require(
            IERC20(tos).transfer(msg.sender, _amount),
            "Stake1Vault: fail withdrawReward"
        );
    }

    /// @dev  Add stake contract
    /// @param _name stakeContract's name
    /// @param stakeContract stakeContract's address
    /// @param periodBlocks the period that give rewards of stakeContract
    function addSubVaultOfStake(
        string memory _name,
        address stakeContract,
        uint256 periodBlocks
    ) external override onlyOwner {
        require(
            stakeContract != address(0) && cap > 0 && periodBlocks > 0,
            "Stake1Vault: addStakerInVault init fails"
        );
        require(
            block.number < stakeStartBlock,
            "Stake1Vault: Already started stake"
        );
        require(!saleClosed, "Stake1Vault: closed sale");
        require(
            paytoken == IStake1Storage(stakeContract).paytoken(),
            "Stake1Vault: Different paytoken"
        );

        LibTokenStake1.StakeInfo storage info = stakeInfos[stakeContract];
        require(info.startBlock == 0, "Stake1Vault: Already added");

        stakeAddresses.push(stakeContract);
        uint256 _endBlock = stakeStartBlock.add(periodBlocks);

        info.name = _name;
        info.startBlock = stakeStartBlock;
        info.endBlock = _endBlock;

        if (stakeEndBlock < _endBlock) stakeEndBlock = _endBlock;
        orderedEndBlocks.push(stakeEndBlock);
    }

    /// @dev  Close the sale that can stake by user
    function closeSale() external override {
        require(!saleClosed, "Stake1Vault: already closed");
        require(
            cap > 0 &&
                stakeStartBlock > 0 &&
                stakeStartBlock < stakeEndBlock &&
                block.number > stakeStartBlock,
            "Stake1Vault: Before stakeStartBlock"
        );
        require(stakeAddresses.length > 0, "Stake1Vault: no stakes");

        realEndBlock = stakeEndBlock;

        // check balance, update balance
        for (uint256 i = 0; i < stakeAddresses.length; i++) {
            LibTokenStake1.StakeInfo storage stakeInfo =
                stakeInfos[stakeAddresses[i]];
            if (paytoken == address(0)) {
                stakeInfo.balance = address(uint160(stakeAddresses[i])).balance;
            } else {
                uint256 balanceAmount =
                    IERC20(paytoken).balanceOf(stakeAddresses[i]);
                stakeInfo.balance = balanceAmount;
            }
            if (stakeInfo.balance > 0)
                realEndBlock = stakeInfos[stakeAddresses[i]].endBlock;
        }

        blockTotalReward = cap.div(realEndBlock.sub(stakeStartBlock));

        uint256 sum = 0;
        // update total
        for (uint256 i = 0; i < stakeAddresses.length; i++) {
            LibTokenStake1.StakeInfo storage totalcheck =
                stakeInfos[stakeAddresses[i]];

            uint256 total = 0;
            for (uint256 j = 0; j < stakeAddresses.length; j++) {
                if (
                    stakeInfos[stakeAddresses[j]].endBlock >=
                    totalcheck.endBlock
                ) {
                    total = total.add(stakeInfos[stakeAddresses[j]].balance);
                }
            }

            if (totalcheck.endBlock > realEndBlock) {
                continue;
            }

            stakeEndBlockTotal[totalcheck.endBlock] = total;
            sum = sum.add(total);

            // reward total
            uint256 totalReward = 0;
            for (uint256 k = i; k > 0; k--) {
                if (
                    stakeEndBlockTotal[stakeInfos[stakeAddresses[k]].endBlock] >
                    0
                ) {
                    totalReward = totalReward.add(
                        stakeInfos[stakeAddresses[k]]
                            .endBlock
                            .sub(stakeInfos[stakeAddresses[k - 1]].endBlock)
                            .mul(blockTotalReward)
                            .mul(totalcheck.balance)
                            .div(
                            stakeEndBlockTotal[
                                stakeInfos[stakeAddresses[k]].endBlock
                            ]
                        )
                    );
                }
            }

            if (
                stakeEndBlockTotal[stakeInfos[stakeAddresses[0]].endBlock] > 0
            ) {
                totalReward = totalReward.add(
                    stakeInfos[stakeAddresses[0]]
                        .endBlock
                        .sub(stakeInfos[stakeAddresses[0]].startBlock)
                        .mul(blockTotalReward)
                        .mul(totalcheck.balance)
                        .div(
                        stakeEndBlockTotal[
                            stakeInfos[stakeAddresses[0]].endBlock
                        ]
                    )
                );
            }
            totalcheck.totalRewardAmount = totalReward;
        }

        saleClosed = true;
        emit ClosedSale();
    }

    /// @dev claim function.
    /// @dev sender is a staking contract.
    /// @dev A function that pays the amount(_amount) to _to by the staking contract.
    /// @dev A function that _to claim the amount(_amount) from the staking contract and gets the tos in the vault.
    /// @param _to a user that received reward
    /// @param _amount the receiving amount
    /// @return true
    function claim(address _to, uint256 _amount)
        external
        override
        returns (bool)
    {
        require(
            saleClosed && _amount > 0,
            "Stake1Vault: on sale or need to end the sale"
        );
        uint256 tosBalance = IERC20(tos).balanceOf(address(this));
        require(tosBalance >= _amount, "Stake1Vault: not enough balance");

        LibTokenStake1.StakeInfo storage stakeInfo = stakeInfos[msg.sender];
        require(stakeInfo.startBlock > 0, "Stake1Vault: startBlock zero");
        require(
            stakeInfo.totalRewardAmount > 0,
            "Stake1Vault: totalRewardAmount is zero"
        );
        require(
            stakeInfo.totalRewardAmount >=
                stakeInfo.claimRewardAmount.add(_amount),
            "Stake1Vault: claim amount exceeds"
        );

        stakeInfo.claimRewardAmount = stakeInfo.claimRewardAmount.add(_amount);

        require(
            IERC20(tos).transfer(_to, _amount),
            "Stake1Vault: TOS transfer fail"
        );

        emit ClaimedReward(msg.sender, _to, _amount);
        return true;
    }

    /// @dev  Whether user(to) can receive a reward amount(_amount)
    /// @param _to  a staking contract.
    /// @param _amount the total reward amount of stakeContract
    /// @return true
    function canClaim(address _to, uint256 _amount)
        external
        view
        override
        returns (bool)
    {
        require(saleClosed, "Stake1Vault: on sale or need to end the sale");
        uint256 tosBalance = IERC20(tos).balanceOf(address(this));
        require(tosBalance >= _amount, "not enough");

        LibTokenStake1.StakeInfo storage stakeInfo = stakeInfos[_to];
        require(stakeInfo.startBlock > 0, "Stake1Vault: startBlock is zero");

        require(
            stakeInfo.totalRewardAmount > 0,
            "Stake1Vault: amount is wrong"
        );
        require(
            stakeInfo.totalRewardAmount >=
                stakeInfo.claimRewardAmount.add(_amount),
            "Stake1Vault: amount exceeds"
        );

        return true;
    }

    /// @dev Returns Give the TOS balance stored in the vault
    /// @return the balance of TOS in this vault.
    function balanceTOSAvailableAmount()
        external
        view
        override
        returns (uint256)
    {
        return IERC20(tos).balanceOf(address(this));
    }

    /// @dev Give all stakeContracts's addresses in this vault
    /// @return all stakeContracts's addresses
    function stakeAddressesAll()
        external
        view
        override
        returns (address[] memory)
    {
        return stakeAddresses;
    }

    /// @dev Give the ordered end blocks of stakeContracts in this vault
    /// @return the ordered end blocks
    function orderedEndBlocksAll()
        external
        view
        override
        returns (uint256[] memory)
    {
        return orderedEndBlocks;
    }

    /// @dev Give Total reward amount of stakeContract(_account)
    /// @return Total reward amount of stakeContract(_account)
    function totalRewardAmount(address _account)
        external
        view
        override
        returns (uint256)
    {
        return stakeInfos[_account].totalRewardAmount;
    }

    /// @dev Give the infomation of this vault
    /// @return [paytoken,defiAddr], cap, stakeType, [saleStartBlock, stakeStartBlock, stakeEndBlock], blockTotalReward, saleClosed
    function infos()
        external
        view
        override
        returns (
            address[2] memory,
            uint256,
            uint256,
            uint256[3] memory,
            uint256,
            bool
        )
    {
        return (
            [paytoken, defiAddr],
            cap,
            stakeType,
            [saleStartBlock, stakeStartBlock, stakeEndBlock],
            blockTotalReward,
            saleClosed
        );
    }
}


// File contracts/interfaces/IStake2Logic.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStake2Logic {
    /// @dev event on create vault
    /// @param vault the vault address created
    /// @param paytoken the token used for staking by user
    /// @param cap  allocated reward amount
    event CreatedVault2(address indexed vault, address paytoken, uint256 cap);

    /// @dev event on create stake contract in vault
    /// @param vault the vault address
    /// @param stakeContract the stake contract address created
    /// @param phase the phase of TOS platform
    event CreatedStakeContract2(
        address indexed vault,
        address indexed stakeContract,
        uint256 phase
    );

    /// @dev Set stakeVaultLogic address by _phase
    /// @param _phase the stake type
    /// @param _logic the vault logic address
    function setVaultLogicByPhase(uint256 _phase, address _logic) external;

    /// @dev create vault2
    /// @param _cap  allocated reward amount
    /// @param _miningPerSecond  the mining per second
    /// @param _NonfungiblePositionManager  NonfungiblePositionManager of uniswapV3
    /// @param _UniswapV3Factory  UniswapV3Factory of uniswapV3
    /// @param _token0  token0 address
    /// @param _token1  token1 address
    /// @param _name   name
    function createVault2(
        uint256 _cap,
        uint256 _miningPerSecond,
        address _NonfungiblePositionManager,
        address _UniswapV3Factory,
        address _token0,
        address _token1,
        string memory _name
    ) external;

    /// @dev set pool information
    /// @param target  target address
    /// @param uniswapInfo [NonfungiblePositionManager,UniswapV3Factory,token0,token1]
    function setPool(address target, address[4] memory uniswapInfo) external;

    /// @dev set pool address with tokenId
    /// @param target  target address
    /// @param tokenId  tokenId
    function setPoolAddressWithTokenId(address target, uint256 tokenId)
        external;

    /// @dev Mining interval setting (seconds)
    /// @param target  target address
    /// @param miningIntervalSeconds the mining interval (sec)
    function setMiningIntervalSeconds(
        address target,
        uint256 miningIntervalSeconds
    ) external;

    /// @dev reset coinage's last mining time variable for tes
    /// @param target  target address
    function resetCoinageTime(address target) external;

    /// @dev set the start time of vault2
    /// @param vault  a vault address
    /// @param startTime  mining start time
    function setStartTimeOfVault2(address vault, uint256 startTime) external;

    /// @dev set mining end time
    /// @param vault  a vault address
    /// @param endTime  mining end time
    function setEndTimeOfVault2(address vault, uint256 endTime) external;
}


// File contracts/interfaces/IStake2Vault.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

//pragma abicoder v2;
//import "../libraries/LibTokenStake1.sol";

interface IStake2Vault {
    /// @dev Sets TOS address
    /// @param _tos  TOS address
    function setTOS(address _tos) external;

    /// @dev Change cap of the vault
    /// @param _cap  allocated reward amount
    function changeCap(uint256 _cap) external;

    /// @dev change name
    /// @param _name   name
    function changeName(string memory _name) external;

    /// @dev set stake address
    /// @param _stakeAddress  stake address
    function setStakeAddress(address _stakeAddress) external;

    /// @dev set mining start time
    /// @param _miningStartTime  mining start time
    function setMiningStartTime(uint256 _miningStartTime) external;

    /// @dev set mining end time
    /// @param _miningEndTime  mining end time
    function setMiningEndTime(uint256 _miningEndTime) external;

    /// @dev set mining amount per second
    /// @param _miningPerSecond  a mining amount per second
    function setMiningAmountPerSecond(uint256 _miningPerSecond) external;

    /// @dev If the vault has more money than the reward to give, the owner can withdraw the remaining amount.
    /// @param to to address
    /// @param _amount the amount of withdrawal
    function withdraw(address to, uint256 _amount) external;

    /// @dev claim function.
    /// @dev sender is a staking contract.
    /// @dev A function that pays the amount(_amount) to _to by the staking contract.
    /// @dev A function that _to claim the amount(_amount) from the staking contract and gets the TOS in the vault.
    /// @param _to a user that received reward
    /// @param _amount the receiving amount
    /// @return true
    function claim(address _to, uint256 _amount) external returns (bool);

    /// @dev  a according to request from(staking contract)  the amount of mining is paid to to.
    /// @param to the address that will receive the reward
    /// @param minableAmount minable amount
    /// @param miningAmount amount mined
    /// @param nonMiningAmount Amount not mined
    function claimMining(
        address to,
        uint256 minableAmount,
        uint256 miningAmount,
        uint256 nonMiningAmount
    ) external returns (bool);

    /// @dev Give the infomation of this vault
    /// @return return1 [tos, stakeAddress]
    /// @return return2 cap
    /// @return return3 stakeType
    /// @return return4 rewardPerBlock
    /// @return return5 name
    function infos()
        external
        view
        returns (
            address[2] memory,
            uint256,
            uint256,
            uint256,
            string memory
        );

    /// @dev Returns Give the TOS balance stored in the vault
    /// @return the balance of TOS in this vault.
    function balanceTOSAvailableAmount() external view returns (uint256);

    /// @dev Give all stakeContracts's addresses in this vault
    /// @return all stakeContracts's addresses
    function stakeAddressesAll() external view returns (address[] memory);
}


// File contracts/stake/Stake2Logic.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;





interface IIStakeUniswapV3 {
    function setPool(address[4] memory uniswapInfo) external;

    function setSaleStartTime(uint256 _saleStartTime) external;

    function setMiningIntervalSeconds(uint256 _intervalSeconds) external;

    function resetCoinageTime() external;

    function setPoolAddress(uint256 tokenId) external;
}

interface IIIStake2Vault {
    function stakeAddress() external view returns (address);
}

/// @title The logic of TOS Plaform
/// @notice Admin can createVault, createStakeContract.
/// User can excute the tokamak staking function of each contract through this logic.

contract Stake2Logic is StakeProxyStorage, AccessibleCommon, IStake2Logic {
    modifier nonZero(uint256 _value) {
        require(_value > 0, "Stake2Logic: zero");
        _;
    }

    modifier nonZeroAddress(address _addr) {
        require(_addr != address(0), "Stake2Logic: zero address");
        _;
    }

    constructor() {}

    /// @dev Set stakeVaultLogic address by _phase
    /// @param _phase the stake type
    /// @param _logic the vault logic address
    function setVaultLogicByPhase(uint256 _phase, address _logic)
        external
        override
        onlyOwner
        nonZeroAddress(address(stakeVaultFactory))
        nonZeroAddress(_logic)
    {
        stakeVaultFactory.setVaultLogicByPhase(_phase, _logic);
    }

    /// @dev create vault2
    /// @param _cap  allocated reward amount
    /// @param _miningPerSecond  the mining per second
    /// @param _NonfungiblePositionManager  NonfungiblePositionManager of uniswapV3
    /// @param _UniswapV3Factory  UniswapV3Factory of uniswapV3
    /// @param _token0  token0 address
    /// @param _token1  token1 address
    /// @param _name   name
    function createVault2(
        uint256 _cap,
        uint256 _miningPerSecond,
        address _NonfungiblePositionManager,
        address _UniswapV3Factory,
        address _token0,
        address _token1,
        string memory _name
    ) external override onlyOwner nonZeroAddress(address(stakeVaultFactory)) {
        uint256 _phase = 2;
        uint256 stakeType = 2;
        bytes32 vaultName = keccak256(abi.encodePacked(_name));
        uint256 cap = _cap;
        uint256 miningPerSecond = _miningPerSecond;

        // console.log("tos %s", tos );
        // console.log("stakeFactory %s", address(stakeFactory) );
        // console.log("miningPerSecond %d , cap %d, stakeType %d ", miningPerSecond, cap , stakeType);
        // console.log("tos %s", tos );

        address vault =
            stakeVaultFactory.create2(
                _phase,
                [tos, address(stakeFactory)],
                [stakeType, cap, miningPerSecond],
                _name,
                address(this)
            );

        require(vault != address(0), "Stake2Logic: vault2 is zero");

        uint256 phase = _phase;
        address[4] memory uniswapInfo =
            [_NonfungiblePositionManager, _UniswapV3Factory, _token0, _token1];

        stakeRegistry.addVault(vault, phase, vaultName);
        emit CreatedVault2(vault, _NonfungiblePositionManager, cap);

        address[4] memory _addr = [tos, address(0), vault, address(0)];
        address _contract =
            stakeFactory.create(
                stakeType,
                _addr,
                address(stakeRegistry),
                [cap, miningPerSecond, 0]
            );
        require(_contract != address(0), "Stake2Logic: vault2 deploy fail");

        IIStakeUniswapV3(_contract).setPool(uniswapInfo);
        IStake2Vault(vault).setStakeAddress(_contract);
        stakeRegistry.addStakeContract(vault, _contract);

        emit CreatedStakeContract2(vault, _contract, phase);
    }

    /// @dev set pool information
    /// @param target  target address
    /// @param uniswapInfo [NonfungiblePositionManager,UniswapV3Factory,token0,token1]
    function setPool(address target, address[4] memory uniswapInfo)
        external
        override
        onlyOwner
        nonZeroAddress(target)
    {
        IIStakeUniswapV3(target).setPool(uniswapInfo);
    }

    /// @dev set pool address with tokenId
    /// @param target  target address
    /// @param tokenId  tokenId
    function setPoolAddressWithTokenId(address target, uint256 tokenId)
        external
        override
        onlyOwner
        nonZeroAddress(target)
        nonZero(tokenId)
    {
        IIStakeUniswapV3(target).setPoolAddress(tokenId);
    }

    /// @dev Mining interval setting (seconds)
    /// @param target  target address
    /// @param miningIntervalSeconds the mining interval (sec)
    function setMiningIntervalSeconds(
        address target,
        uint256 miningIntervalSeconds
    ) external override onlyOwner nonZeroAddress(target) {
        IIStakeUniswapV3(target).setMiningIntervalSeconds(
            miningIntervalSeconds
        );
    }

    /// @dev reset coinage's last mining time variable for tes
    /// @param target  target address
    function resetCoinageTime(address target)
        external
        override
        onlyOwner
        nonZeroAddress(target)
    {
        IIStakeUniswapV3(target).resetCoinageTime();
    }

    /// @dev set the start time of vault2
    /// @param vault  a vault address
    /// @param startTime  mining start time
    function setStartTimeOfVault2(address vault, uint256 startTime)
        external
        override
        onlyOwner
        nonZeroAddress(vault)
    {
        address stakeAddress = IIIStake2Vault(vault).stakeAddress();
        require(
            stakeAddress != address(0),
            "Stake2Logic: stakeAddress is zero"
        );

        IStake2Vault(vault).setMiningStartTime(startTime);
        IIStakeUniswapV3(stakeAddress).setSaleStartTime(startTime);
    }

    /// @dev set mining end time
    /// @param vault  a vault address
    /// @param endTime  mining end time
    function setEndTimeOfVault2(address vault, uint256 endTime)
        external
        override
        onlyOwner
        nonZeroAddress(vault)
    {
        IStake2Vault(vault).setMiningEndTime(endTime);
    }
}


// File contracts/stake/Stake2Vault.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;
pragma abicoder v2;




/// @title TOS Token's Vault - stores the TOS for the period of time
/// @notice A vault is associated with the set of stake contracts.
/// Stake contracts can interact with the vault to claim TOS tokens
contract Stake2Vault is Stake2VaultStorage, IStake2Vault {
    using SafeMath for uint256;

    /// @dev event of according to request from(staking contract)  the amount of mining is paid to to.
    /// @param to the address that will receive the reward
    /// @param minableAmount minable amount
    /// @param miningAmount amount mined
    /// @param nonMiningAmount Amount not mined
    event ClaimedMining(
        address indexed to,
        uint256 minableAmount,
        uint256 miningAmount,
        uint256 nonMiningAmount
    );
    event Claimed(address indexed from, address to, uint256 amount);

    /// @dev constructor of Stake1Vault
    constructor() {}

    /// @dev receive function
    receive() external payable {
        revert("cannot receive Ether");
    }

    /// @dev Sets TOS address
    /// @param _tos  TOS address
    function setTOS(address _tos)
        external
        override
        onlyOwner
        nonZeroAddress(_tos)
    {
        tos = _tos;
    }

    /// @dev Change cap of the vault
    /// @param _cap  allocated reward amount
    function changeCap(uint256 _cap) external override onlyOwner {
        require(_cap > 0 && cap != _cap, "Stake2Vault: changeCap fails");
        cap = _cap;
    }

    /// @dev change name
    /// @param _name   name
    function changeName(string memory _name) external override onlyOwner {
        require(
            keccak256(abi.encodePacked(name)) !=
                keccak256(abi.encodePacked(_name)),
            "Stake2Vault: changeName fails"
        );
        name = _name;
    }

    /// @dev set stake address
    /// @param _stakeAddress  stake address
    function setStakeAddress(address _stakeAddress)
        external
        override
        nonZeroAddress(_stakeAddress)
        onlyOwner
    {
        require(
            stakeAddress != _stakeAddress,
            "Stake2Vault: setStakeAddress fails"
        );
        stakeAddress = _stakeAddress;
    }

    /// @dev set mining amount per second
    /// @param _miningPerSecond  a mining amount per second
    function setMiningAmountPerSecond(uint256 _miningPerSecond)
        external
        override
        onlyOwner
    {
        require(
            _miningPerSecond > 0 && miningPerSecond != _miningPerSecond,
            "Stake2Vault: zero or same _miningPerSecond"
        );
        miningPerSecond = _miningPerSecond;
    }

    /// @dev set mining start time
    /// @param _miningStartTime  mining start time
    function setMiningStartTime(uint256 _miningStartTime)
        external
        override
        onlyOwner
    {
        require(
            _miningStartTime > 0 && miningStartTime != _miningStartTime,
            "Stake2Vault: zero or same _miningStartTime"
        );
        miningStartTime = _miningStartTime;
    }

    /// @dev set mining end time
    /// @param _miningEndTime  mining end time
    function setMiningEndTime(uint256 _miningEndTime)
        external
        override
        onlyOwner
    {
        require(
            _miningEndTime > 0 && miningEndTime != _miningEndTime,
            "Stake2Vault: zero or same _miningEndTime"
        );
        miningEndTime = _miningEndTime;
    }

    /// @dev If the vault has more money than the reward to give, the owner can withdraw the remaining amount.
    /// @param to to address
    /// @param _amount the amount of withdrawal
    function withdraw(address to, uint256 _amount) external override onlyOwner {
        uint256 balanceOf = IERC20(tos).balanceOf(address(this));
        require(balanceOf >= _amount, "Stake2Vault: insuffient");
        require(
            IERC20(tos).transfer(to, _amount),
            "Stake2Vault: fail withdraw"
        );
    }

    /// @dev  a according to request from(staking contract)  the amount of mining is paid to to.
    /// @param to the address that will receive the reward
    /// @param minableAmount minable amount
    /// @param miningAmount amount mined
    /// @param nonMiningAmount Amount not mined
    function claimMining(
        address to,
        uint256 minableAmount,
        uint256 miningAmount,
        uint256 nonMiningAmount
    ) external override nonZero(minableAmount) returns (bool) {
        require(
            miningStartTime < block.timestamp,
            "Stake2Vault: It is not a mining period"
        );
        require(
            stakeAddress == msg.sender,
            "Stake2Vault: sender is not stakeContract"
        );
        require(
            minableAmount == miningAmount.add(nonMiningAmount),
            "Stake2Vault: minable amount is not correct"
        );

        uint256 tosBalance = IERC20(tos).balanceOf(address(this));
        require(tosBalance >= minableAmount, "Stake2Vault: not enough balance");

        miningAmountTotal = miningAmountTotal.add(miningAmount);
        nonMiningAmountTotal = nonMiningAmountTotal.add(nonMiningAmount);
        totalMinedAmount = totalMinedAmount.add(minableAmount);
        require(
            totalMinedAmount <=
                (block.timestamp.sub(miningStartTime)).mul(miningPerSecond),
            "Stake2Vault: Exceeded the set mining amount"
        );

        if (miningAmount > 0)
            require(
                IERC20(tos).transfer(to, miningAmount),
                "Stake2Vault: TOS transfer fail"
            );

        if (nonMiningAmount > 0)
            require(
                ITOS(tos).burn(address(this), nonMiningAmount),
                "Stake2Vault: TOS burn fail"
            );

        emit ClaimedMining(to, minableAmount, miningAmount, nonMiningAmount);
        return true;
    }

    function claim(address _to, uint256 _amount)
        external
        override
        onlyOwner
        nonZero(_amount)
        returns (bool)
    {
        uint256 tosBalance = IERC20(tos).balanceOf(address(this));
        require(tosBalance >= _amount, "Stake2Vault: not enough balance");
        require(
            IERC20(tos).transfer(_to, _amount),
            "Stake2Vault: TOS transfer fail"
        );

        emit Claimed(msg.sender, _to, _amount);
        return true;
    }

    /// @dev Returns Give the TOS balance stored in the vault
    /// @return the balance of TOS in this vault.
    function balanceTOSAvailableAmount()
        external
        view
        override
        returns (uint256)
    {
        return IERC20(tos).balanceOf(address(this));
    }

    /// @dev Give the infomation of this vault
    /// @return return1 [tos, stakeAddress]
    /// @return return2 cap
    /// @return return3 stakeType
    /// @return return4 miningPerSecond
    /// @return return5 name
    function infos()
        external
        view
        override
        returns (
            address[2] memory,
            uint256,
            uint256,
            uint256,
            string memory
        )
    {
        return ([tos, stakeAddress], cap, stakeType, miningPerSecond, name);
    }

    /// @dev Give all stakeContracts's addresses in this vault
    /// @return all stakeContracts's addresses
    function stakeAddressesAll()
        external
        view
        override
        returns (address[] memory)
    {
        address[] memory addr = new address[](1);
        addr[0] = stakeAddress;
        return addr;
    }
}


// File contracts/stake/Stake2VaultUpgrade.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;
pragma abicoder v2;




/// @title TOS Token's Vault - stores the TOS for the period of time
/// @notice A vault is associated with the set of stake contracts.
/// Stake contracts can interact with the vault to claim TOS tokens
contract Stake2VaultUpgrade is Stake2VaultStorage, IStake2Vault {
    using SafeMath for uint256;

    /// @dev event of according to request from(staking contract)  the amount of mining is paid to to.
    /// @param to the address that will receive the reward
    /// @param minableAmount minable amount
    /// @param miningAmount amount mined
    /// @param nonMiningAmount Amount not mined
    event ClaimedMining(
        address indexed to,
        uint256 minableAmount,
        uint256 miningAmount,
        uint256 nonMiningAmount
    );
    event Claimed(address indexed from, address to, uint256 amount);

    /// @dev constructor of Stake1Vault
    constructor() {}

    /// @dev receive function
    receive() external payable {
        revert("cannot receive Ether");
    }

    /// @dev Sets TOS address
    /// @param _tos  TOS address
    function setTOS(address _tos)
        external
        override
        onlyOwner
        nonZeroAddress(_tos)
    {
        tos = _tos;
    }

    /// @dev Change cap of the vault
    /// @param _cap  allocated reward amount
    function changeCap(uint256 _cap) external override onlyOwner {
        require(_cap > 0 && cap != _cap, "Stake2Vault: changeCap fails");
        cap = _cap;
    }

    /// @dev change name
    /// @param _name   name
    function changeName(string memory _name) external override onlyOwner {
        require(
            keccak256(abi.encodePacked(name)) !=
                keccak256(abi.encodePacked(_name)),
            "Stake2Vault: changeName fails"
        );
        name = _name;
    }

    /// @dev set stake address
    /// @param _stakeAddress  stake address
    function setStakeAddress(address _stakeAddress)
        external
        override
        nonZeroAddress(_stakeAddress)
        onlyOwner
    {
        require(
            stakeAddress != _stakeAddress,
            "Stake2Vault: setStakeAddress fails"
        );
        stakeAddress = _stakeAddress;
    }

    /// @dev set mining amount per second
    /// @param _miningPerSecond  a mining amount per second
    function setMiningAmountPerSecond(uint256 _miningPerSecond)
        external
        override
        onlyOwner
    {
        require(
            _miningPerSecond > 0 && miningPerSecond != _miningPerSecond,
            "Stake2Vault: zero or same _miningPerSecond"
        );
        miningPerSecond = _miningPerSecond;
    }

    /// @dev set mining start time
    /// @param _miningStartTime  mining start time
    function setMiningStartTime(uint256 _miningStartTime)
        external
        override
        onlyOwner
    {
        require(
            _miningStartTime > 0 && miningStartTime != _miningStartTime,
            "Stake2Vault: zero or same _miningStartTime"
        );
        miningStartTime = _miningStartTime;
    }

    /// @dev set mining end time
    /// @param _miningEndTime  mining end time
    function setMiningEndTime(uint256 _miningEndTime)
        external
        override
        onlyOwner
    {
        require(
            _miningEndTime > 0 && miningEndTime != _miningEndTime,
            "Stake2Vault: zero or same _miningEndTime"
        );
        miningEndTime = _miningEndTime;
    }

    /// @dev If the vault has more money than the reward to give, the owner can withdraw the remaining amount.
    /// @param to to address
    /// @param _amount the amount of withdrawal
    function withdraw(address to, uint256 _amount) external override onlyOwner {
        uint256 balanceOf = IERC20(tos).balanceOf(address(this));
        require(balanceOf >= _amount, "Stake2Vault: insuffient");
        require(
            IERC20(tos).transfer(to, _amount),
            "Stake2Vault: fail withdraw"
        );
    }

    /// @dev  a according to request from(staking contract)  the amount of mining is paid to to.
    /// @param to the address that will receive the reward
    /// @param minableAmount minable amount
    /// @param miningAmount amount mined
    /// @param nonMiningAmount Amount not mined
    function claimMining(
        address to,
        uint256 minableAmount,
        uint256 miningAmount,
        uint256 nonMiningAmount
    ) external override nonZero(minableAmount) returns (bool) {
        require(
            miningStartTime < block.timestamp,
            "Stake2Vault: It is not a mining period"
        );
        require(
            stakeAddress == msg.sender,
            "Stake2Vault: sender is not stakeContract"
        );
        require(
            minableAmount == miningAmount.add(nonMiningAmount),
            "Stake2Vault: minable amount is not correct"
        );

        uint256 tosBalance = IERC20(tos).balanceOf(address(this));
        require(tosBalance >= minableAmount, "Stake2Vault: not enough balance");

        miningAmountTotal = miningAmountTotal.add(miningAmount);
        nonMiningAmountTotal = nonMiningAmountTotal.add(nonMiningAmount);
        totalMinedAmount = totalMinedAmount.add(minableAmount);

        uint256 curBlockTimestamp = block.timestamp;
        if (curBlockTimestamp > miningEndTime)
            curBlockTimestamp = miningEndTime;

        require(
            totalMinedAmount <=
                (curBlockTimestamp.sub(miningStartTime)).mul(miningPerSecond),
            "Stake2Vault: Exceeded the set mining amount"
        );

        if (miningAmount > 0)
            require(
                IERC20(tos).transfer(to, miningAmount),
                "Stake2Vault: TOS transfer fail"
            );

        if (nonMiningAmount > 0)
            require(
                ITOS(tos).burn(address(this), nonMiningAmount),
                "Stake2Vault: TOS burn fail"
            );

        emit ClaimedMining(to, minableAmount, miningAmount, nonMiningAmount);
        return true;
    }

    function claim(address _to, uint256 _amount)
        external
        override
        onlyOwner
        nonZero(_amount)
        returns (bool)
    {
        uint256 tosBalance = IERC20(tos).balanceOf(address(this));
        require(tosBalance >= _amount, "Stake2Vault: not enough balance");
        require(
            IERC20(tos).transfer(_to, _amount),
            "Stake2Vault: TOS transfer fail"
        );

        emit Claimed(msg.sender, _to, _amount);
        return true;
    }

    /// @dev Returns Give the TOS balance stored in the vault
    /// @return the balance of TOS in this vault.
    function balanceTOSAvailableAmount()
        external
        view
        override
        returns (uint256)
    {
        return IERC20(tos).balanceOf(address(this));
    }

    /// @dev Give the infomation of this vault
    /// @return return1 [tos, stakeAddress]
    /// @return return2 cap
    /// @return return3 stakeType
    /// @return return4 miningPerSecond
    /// @return return5 name
    function infos()
        external
        view
        override
        returns (
            address[2] memory,
            uint256,
            uint256,
            uint256,
            string memory
        )
    {
        return ([tos, stakeAddress], cap, stakeType, miningPerSecond, name);
    }

    /// @dev Give all stakeContracts's addresses in this vault
    /// @return all stakeContracts's addresses
    function stakeAddressesAll()
        external
        view
        override
        returns (address[] memory)
    {
        address[] memory addr = new address[](1);
        addr[0] = stakeAddress;
        return addr;
    }

    function version() external pure returns (string memory) {
        return "upgrade.v1.202108";
    }
}


// File contracts/interfaces/IStake3Logic.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStake3Logic {

    /// @dev event on create vault
    /// @param vault the vault address created
    /// @param paytoken the token used for staking by user
    /// @param cap  allocated reward amount
    event CreatedVault(address indexed vault, address paytoken, uint256 cap);

    /// @dev create vault with particular vault's logic
    /// @param _paytoken the token used for staking by user
    /// @param _cap  allocated reward amount
    /// @param _saleStartBlock  the start block that can stake by user
    /// @param _stakeStartBlock the start block that end staking by user and start that can claim reward by user
    /// @param _phase  phase of TOS platform
    /// @param _vaultName  vault's name's hash
    /// @param _stakeType  stakeContract's type, if 0, StakeTON, else if 1 , StakeSimple , else if 2, StakeDefi
    /// @param _defiAddr  extra defi address , default is zero address
    /// @param _logicIndexInVaultFactory  vaultFactory's logic index
    function createdVaultWithLogicIndex(
        address _paytoken,
        uint256 _cap,
        uint256 _saleStartBlock,
        uint256 _stakeStartBlock,
        uint256 _phase,
        bytes32 _vaultName,
        uint256 _stakeType,
        address _defiAddr,
        uint256 _logicIndexInVaultFactory
    ) external;

}


// File contracts/stake/Stake3Logic.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;







/// @title The logic of TOS Plaform
/// @notice Admin can createVault, createStakeContract.
/// User can excute the tokamak staking function of each contract through this logic.
contract Stake3Logic is StakeProxyStorage, AccessibleCommon, IStake3Logic {
    modifier nonZeroAddress(address _addr) {
        require(_addr != address(0), "Stake3Logic:zero address");
        _;
    }

    constructor() {}

    /// @dev create vault with particular vault's logic
    /// @param _paytoken the token used for staking by user
    /// @param _cap  allocated reward amount
    /// @param _saleStartBlock  the start block that can stake by user
    /// @param _stakeStartBlock the start block that end staking by user and start that can claim reward by user
    /// @param _phase  phase of TOS platform
    /// @param _vaultName  vault's name's hash
    /// @param _stakeType  stakeContract's type, if 0, StakeTON, else if 1 , StakeSimple , else if 2, StakeDefi
    /// @param _defiAddr  extra defi address , default is zero address
    /// @param _logicIndexInVaultFactory  vaultFactory's logic index
    function createdVaultWithLogicIndex(
        address _paytoken,
        uint256 _cap,
        uint256 _saleStartBlock,
        uint256 _stakeStartBlock,
        uint256 _phase,
        bytes32 _vaultName,
        uint256 _stakeType,
        address _defiAddr,
        uint256 _logicIndexInVaultFactory
    ) external override onlyOwner nonZeroAddress(address(stakeVaultFactory)) {
        address vault =
            stakeVaultFactory.create(
                _logicIndexInVaultFactory,
                [tos, _paytoken, address(stakeFactory), _defiAddr],
                [_stakeType, _cap, _saleStartBlock, _stakeStartBlock],
                address(this)
            );
        require(vault != address(0), "Stake3Logic: vault is zero");
        stakeRegistry.addVault(vault, _phase, _vaultName);

        emit CreatedVault(vault, _paytoken, _cap);
    }
}


// File contracts/stake/StakeRegistry.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;



/// @title Stake Registry
/// @notice Manage the vault list by phase. Manage the list of staking contracts in the vault.
contract StakeRegistry is AccessibleCommon, IStakeRegistry {
    bytes32 public constant ZERO_HASH =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    /// @dev TOS address
    address public tos;

    /// @dev TON address in Tokamak
    address public ton;

    /// @dev WTON address in Tokamak
    address public wton;

    /// @dev Depositmanager address in Tokamak
    address public depositManager;

    /// @dev SeigManager address in Tokamak
    address public seigManager;

    /// @dev swapProxy address in Tokamak
    address public swapProxy;

    /// Contracts included in the phase
    mapping(uint256 => address[]) public phases;

    /// Vault address mapping with vault name hash
    mapping(bytes32 => address) public vaults;

    /// Vault name hash mapping with vault address
    mapping(address => bytes32) public vaultNames;

    /// List of staking contracts included in the vault
    mapping(address => address[]) public stakeContractsOfVault;

    /// Vault address of staking contract
    mapping(address => address) public stakeContractVault;

    /// Defi Info
    mapping(bytes32 => LibTokenStake1.DefiInfo) public override defiInfo;

    modifier nonZero(address _addr) {
        require(_addr != address(0), "StakeRegistry: zero address");
        _;
    }

    /// @dev event on add the vault
    /// @param vault the vault address
    /// @param phase the phase of TOS platform
    event AddedVault(address indexed vault, uint256 phase);

    /// @dev event on add the stake contract in vault
    /// @param vault the vault address
    /// @param stakeContract the stake contract address created
    event AddedStakeContract(
        address indexed vault,
        address indexed stakeContract
    );

    /// @dev event on set the addresses related to tokamak
    /// @param ton the TON address
    /// @param wton the WTON address
    /// @param depositManager the DepositManager address
    /// @param seigManager the SeigManager address
    /// @param swapProxy the SwapProxy address
    event SetTokamak(
        address ton,
        address wton,
        address depositManager,
        address seigManager,
        address swapProxy
    );

    /// @dev event on add the information related to defi.
    /// @param nameHash the name hash
    /// @param name the name of defi identify
    /// @param router the entry address
    /// @param ex1 the extra 1 addres
    /// @param ex2 the extra 2 addres
    /// @param fee fee
    /// @param routerV2 the uniswap2 router address
    event AddedDefiInfo(
        bytes32 nameHash,
        string name,
        address router,
        address ex1,
        address ex2,
        uint256 fee,
        address routerV2
    );

    /// @dev constructor of StakeRegistry
    /// @param _tos TOS address
    constructor(address _tos) {
        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, msg.sender);
        tos = _tos;
    }

    /// @dev Set addresses for Tokamak integration
    /// @param _ton TON address
    /// @param _wton WTON address
    /// @param _depositManager DepositManager address
    /// @param _seigManager SeigManager address
    function setTokamak(
        address _ton,
        address _wton,
        address _depositManager,
        address _seigManager,
        address _swapProxy
    )
        external
        override
        onlyOwner
        nonZero(_ton)
        nonZero(_wton)
        nonZero(_depositManager)
        nonZero(_seigManager)
        nonZero(_swapProxy)
    {
        ton = _ton;
        wton = _wton;
        depositManager = _depositManager;
        seigManager = _seigManager;
        swapProxy = _swapProxy;

        emit SetTokamak(ton, wton, depositManager, seigManager, swapProxy);
    }

    /// @dev Add information related to Defi
    /// @param _name name . ex) UNISWAP_V3
    /// @param _router entry point of defi
    /// @param _ex1  additional variable . ex) positionManagerAddress in Uniswap V3
    /// @param _ex2  additional variable . ex) WETH Address in Uniswap V3
    /// @param _fee  fee
    /// @param _routerV2 In case of uniswap, router address of uniswapV2
    function addDefiInfo(
        string calldata _name,
        address _router,
        address _ex1,
        address _ex2,
        uint256 _fee,
        address _routerV2
    ) external override onlyOwner nonZero(_router) {
        bytes32 nameHash = keccak256(abi.encodePacked(_name));
        require(nameHash != ZERO_HASH, "StakeRegistry: nameHash zero");

        LibTokenStake1.DefiInfo storage _defiInfo = defiInfo[nameHash];
        _defiInfo.name = _name;
        _defiInfo.router = _router;
        _defiInfo.ext1 = _ex1;
        _defiInfo.ext2 = _ex2;
        _defiInfo.fee = _fee;
        _defiInfo.routerV2 = _routerV2;

        emit AddedDefiInfo(
            nameHash,
            _name,
            _router,
            _ex1,
            _ex2,
            _fee,
            _routerV2
        );
    }

    /// @dev Add Vault
    /// @dev It is excuted by proxy
    /// @param _vault vault address
    /// @param _phase phase ex) 1,2,3
    /// @param _vaultName  hash of vault's name
    function addVault(
        address _vault,
        uint256 _phase,
        bytes32 _vaultName
    ) external override onlyOwner {
        require(
            vaultNames[_vault] == ZERO_HASH || vaults[_vaultName] == address(0),
            "StakeRegistry: addVault input value is not zero"
        );
        vaults[_vaultName] = _vault;
        vaultNames[_vault] = _vaultName;
        phases[_phase].push(_vault);

        emit AddedVault(_vault, _phase);
    }

    /// @dev Add StakeContract in vault
    /// @dev It is excuted by proxy
    /// @param _vault vault address
    /// @param _stakeContract  StakeContract address
    function addStakeContract(address _vault, address _stakeContract)
        external
        override
        onlyOwner
    {
        require(
            vaultNames[_vault] != ZERO_HASH &&
                stakeContractVault[_stakeContract] == address(0),
            "StakeRegistry: input is zero"
        );
        stakeContractVault[_stakeContract] = _vault;
        stakeContractsOfVault[_vault].push(_stakeContract);

        emit AddedStakeContract(_vault, _stakeContract);
    }

    /// @dev Get addresses for Tokamak interface
    /// @return (ton, wton, depositManager, seigManager)
    function getTokamak()
        external
        view
        override
        returns (
            address,
            address,
            address,
            address,
            address
        )
    {
        return (ton, wton, depositManager, seigManager, swapProxy);
    }

    /// @dev Get indos for UNISWAP_V3 interface
    /// @return (uniswapRouter, npm, wethAddress, fee)
    function getUniswap()
        external
        view
        override
        returns (
            address,
            address,
            address,
            uint256,
            address
        )
    {
        bytes32 nameHash = keccak256(abi.encodePacked("UNISWAP_V3"));
        return (
            defiInfo[nameHash].router,
            defiInfo[nameHash].ext1,
            defiInfo[nameHash].ext2,
            defiInfo[nameHash].fee,
            defiInfo[nameHash].routerV2
        );
    }

    /// @dev Get addresses of vaults of index phase
    /// @param _index the phase number
    /// @return the list of vaults of phase[_index]
    function phasesAll(uint256 _index)
        external
        view
        override
        returns (address[] memory)
    {
        return phases[_index];
    }

    /// @dev Get addresses of staker of _vault
    /// @param _vault the vault's address
    /// @return the list of stakeContracts of vault
    function stakeContractsOfVaultAll(address _vault)
        external
        view
        override
        returns (address[] memory)
    {
        return stakeContractsOfVault[_vault];
    }

    /// @dev Checks if a vault is withing the given phase
    /// @param _phase the phase number
    /// @param _vault the vault's address
    /// @return valid true or false
    function validVault(uint256 _phase, address _vault)
        external
        view
        override
        returns (bool valid)
    {
        require(phases[_phase].length > 0, "StakeRegistry: validVault is fail");

        for (uint256 i = 0; i < phases[_phase].length; i++) {
            if (_vault == phases[_phase][i]) {
                return true;
            }
        }
    }
}


// File contracts/interfaces/IStakeSimple.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStakeSimple {
    /// @dev Stake amount
    /// @param amount  the amount of staked
    function stake(uint256 amount) external payable;

    /// @dev withdraw
    function withdraw() external;

    /// @dev Claim for reward
    function claim() external;

    /// @dev Returns the amount that can be rewarded
    /// @param account  the account that claimed reward
    /// @param specificBlock the block that claimed reward
    /// @return reward the reward amount that can be taken
    function canRewardAmount(address account, uint256 specificBlock)
        external
        view
        returns (uint256);
}


// File contracts/stake/StakeSimple.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.0;








/// @title Simple Stake Contract
/// @notice Stake contracts can interact with the vault to claim tos tokens
contract StakeSimple is Stake1Storage, AccessibleCommon, IStakeSimple {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    modifier lock() {
        require(_lock == 0, "StakeSimple: LOCKED");
        _lock = 1;
        _;
        _lock = 0;
    }

    /// @dev event on staking
    /// @param to the sender
    /// @param amount the amount of staking
    event Staked(address indexed to, uint256 amount);

    /// @dev event on claim
    /// @param to the sender
    /// @param amount the amount of claim
    /// @param claimBlock the block of claim
    event Claimed(address indexed to, uint256 amount, uint256 claimBlock);

    /// @dev event on withdrawal
    /// @param to the sender
    /// @param amount the amount of withdrawal
    event Withdrawal(address indexed to, uint256 amount);

    /// @dev constructor of StakeSimple
    constructor() {}

    /// @dev receive ether
    /// @dev call stake function with msg.value
    receive() external payable {
        stake(msg.value);
    }

    /// @dev Stake amount
    /// @param amount  the amount of staked
    function stake(uint256 amount) public payable override {
        require(
            (paytoken == address(0) && msg.value == amount) ||
                (paytoken != address(0) && amount > 0),
            "StakeSimple: stake zero"
        );
        require(
            block.number >= saleStartBlock && block.number < startBlock,
            "StakeSimple: period is not allowed"
        );

        require(!IIStake1Vault(vault).saleClosed(), "StakeSimple: not end");

        if (paytoken == address(0)) amount = msg.value;
        else require(IERC20(paytoken).balanceOf(msg.sender) >= amount, "lack");

        LibTokenStake1.StakedAmount storage staked = userStaked[msg.sender];
        if (staked.amount == 0) totalStakers = totalStakers.add(1);

        staked.amount = staked.amount.add(amount);
        totalStakedAmount = totalStakedAmount.add(amount);
        if (paytoken != address(0))
            IERC20(paytoken).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );

        emit Staked(msg.sender, amount);
    }

    /// @dev withdraw
    function withdraw() external override {
        require(
            endBlock > 0 && endBlock < block.number,
            "StakeSimple: not end"
        );

        LibTokenStake1.StakedAmount storage staked = userStaked[msg.sender];
        require(!staked.released, "StakeSimple: Already withdraw");
        require(
            staked.releasedAmount <= staked.amount,
            "StakeSimple: Amount wrong"
        );

        staked.released = true;
        staked.releasedBlock = block.number;

        uint256 amount = staked.amount;
        staked.releasedAmount = amount;

        // check if we send in ethers or in tokens
        if (paytoken == address(0)) {
            address payable self = address(uint160(address(this)));
            require(self.balance >= amount, "StakeSimple: insuffient ETH");
            (bool success, ) = msg.sender.call{value: amount}("");
            require(success, "StakeSimple: withdraw failed.");
        } else {
            IERC20(paytoken).safeTransfer(msg.sender, amount);
        }

        emit Withdrawal(msg.sender, amount);
    }

    /// @dev Claim for reward
    function claim() external override lock {
        require(IIStake1Vault(vault).saleClosed(), "StakeSimple: not closed");
        uint256 rewardClaim = 0;

        LibTokenStake1.StakedAmount storage staked = userStaked[msg.sender];
        require(staked.claimedBlock < endBlock, "StakeSimple: claimed");

        rewardClaim = canRewardAmount(msg.sender, block.number);

        require(rewardClaim > 0, "StakeSimple: reward is zero");

        uint256 rewardTotal =
            IIStake1Vault(vault).totalRewardAmount(address(this));
        require(
            rewardClaimedTotal.add(rewardClaim) <= rewardTotal,
            "StakeSimple: total reward exceeds"
        );

        staked.claimedBlock = block.number;
        staked.claimedAmount = staked.claimedAmount.add(rewardClaim);
        rewardClaimedTotal = rewardClaimedTotal.add(rewardClaim);

        require(
            IIStake1Vault(vault).claim(msg.sender, rewardClaim),
            "StakeSimple: fail claim from vault"
        );

        emit Claimed(msg.sender, rewardClaim, block.number);
    }

    /// @dev Returns the amount that can be rewarded
    /// @param account  the account that claimed reward
    /// @param specificBlock the block that claimed reward
    /// @return reward the reward amount that can be taken
    function canRewardAmount(address account, uint256 specificBlock)
        public
        view
        override
        returns (uint256)
    {
        uint256 reward = 0;
        if (specificBlock > endBlock) specificBlock = endBlock;

        if (
            specificBlock < startBlock ||
            userStaked[account].amount == 0 ||
            userStaked[account].claimedBlock > endBlock ||
            userStaked[account].claimedBlock > specificBlock
        ) {
            reward = 0;
        } else {
            uint256 startR = startBlock;
            uint256 endR = endBlock;
            if (startR < userStaked[account].claimedBlock)
                startR = userStaked[account].claimedBlock;
            if (specificBlock < endR) endR = specificBlock;

            uint256[] memory orderedEndBlocks =
                IIStake1Vault(vault).orderedEndBlocksAll();

            if (orderedEndBlocks.length > 0) {
                uint256 _end = 0;
                uint256 _start = startR;
                uint256 _total = 0;
                uint256 blockTotalReward = 0;
                blockTotalReward = IIStake1Vault(vault).blockTotalReward();

                address user = account;
                uint256 amount = userStaked[user].amount;

                for (uint256 i = 0; i < orderedEndBlocks.length; i++) {
                    _end = orderedEndBlocks[i];
                    _total = IIStake1Vault(vault).stakeEndBlockTotal(_end);

                    if (_start > _end) {} else if (endR <= _end) {
                        if (_total > 0) {
                            uint256 _period1 = endR.sub(startR);
                            reward = reward.add(
                                blockTotalReward.mul(_period1).mul(amount).div(
                                    _total
                                )
                            );
                        }
                        break;
                    } else {
                        if (_total > 0) {
                            uint256 _period2 = _end.sub(startR);
                            reward = reward.add(
                                blockTotalReward.mul(_period2).mul(amount).div(
                                    _total
                                )
                            );
                        }
                        startR = _end;
                    }
                }
            }
        }
        return reward;
    }
    /*
    function canRewardAmountTest(address account, uint256 specificBlock)
        public view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 reward = 0;
        uint256 startR = 0;
        uint256 endR = 0;
        uint256 blockTotalReward = 0;
        if(specificBlock > endBlock ) specificBlock = endBlock;

        if (
            specificBlock < startBlock ||
            userStaked[account].amount == 0 ||
            userStaked[account].claimedBlock > endBlock ||
            userStaked[account].claimedBlock > specificBlock
        ) {
            reward = 0;
        } else {
            startR = startBlock;
            endR = endBlock;
            if (startR < userStaked[account].claimedBlock)
                startR = userStaked[account].claimedBlock;
            if (specificBlock < endR) endR = specificBlock;

            uint256[] memory orderedEndBlocks =
                IStake1Vault(vault).orderedEndBlocksAll();

            if (orderedEndBlocks.length > 0) {
                uint256 _end = 0;
                uint256 _start = startR;
                uint256 _total = 0;
                //uint256 blockTotalReward = 0;
                blockTotalReward = IStake1Vault(vault).blockTotalReward();

                address user = account;
                uint256 amount = userStaked[user].amount;

                for (uint256 i = 0; i < orderedEndBlocks.length; i++) {
                    _end = orderedEndBlocks[i];
                    _total = IStake1Vault(vault).stakeEndBlockTotal(_end);

                    if (_start > _end) {

                    } else if (endR <= _end) {
                        reward +=
                            (blockTotalReward *
                                (endR - startR) * amount) /
                            _total;
                        break;
                    } else {
                        reward +=
                            (blockTotalReward *
                                (_end - startR) *
                                amount) /
                            _total;
                        startR = _end;
                    }
                }
            }
        }
        return (reward, startR, endR, blockTotalReward);
    }
    */
}


// File contracts/interfaces/IStakeTON_NEW.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStakeTON_NEW {

    function version() external returns (string memory);

    function getVaultAddress() external returns (address);

}


// File contracts/stake/StakeTON_NEW.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

/// @dev Stake StakeTON_NEW for Testing
contract StakeTON_NEW is StakeTONStorage, AccessibleCommon, IStakeTON_NEW {
    /// @dev constructor of StakeTON
    constructor() {}

    /// @dev This contract cannot stake Ether.
    receive() external payable {
        revert("cannot stake Ether");
    }

    function version() external pure override returns (string memory) {
        return "new.1.0";
    }

    function getVaultAddress() external view override returns (address) {
        return vault;
    }
}


// File @openzeppelin/contracts/introspection/ERC165Checker.sol@v3.3.0

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.2 <0.8.0;

/**
 * @dev Library used to query support of an interface declared via {IERC165}.
 *
 * Note that these functions return the actual result of the query: they do not
 * `revert` if an interface is not supported. It is up to the caller to decide
 * what to do in these cases.
 */
library ERC165Checker {
    // As per the EIP-165 spec, no interface should ever match 0xffffffff
    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;

    /*
     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7
     */
    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;

    /**
     * @dev Returns true if `account` supports the {IERC165} interface,
     */
    function supportsERC165(address account) internal view returns (bool) {
        // Any contract that implements ERC165 must explicitly indicate support of
        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid
        return _supportsERC165Interface(account, _INTERFACE_ID_ERC165) &&
            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);
    }

    /**
     * @dev Returns true if `account` supports the interface defined by
     * `interfaceId`. Support for {IERC165} itself is queried automatically.
     *
     * See {IERC165-supportsInterface}.
     */
    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {
        // query support of both ERC165 as per the spec and support of _interfaceId
        return supportsERC165(account) &&
            _supportsERC165Interface(account, interfaceId);
    }

    /**
     * @dev Returns true if `account` supports all the interfaces defined in
     * `interfaceIds`. Support for {IERC165} itself is queried automatically.
     *
     * Batch-querying can lead to gas savings by skipping repeated checks for
     * {IERC165} support.
     *
     * See {IERC165-supportsInterface}.
     */
    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {
        // query support of ERC165 itself
        if (!supportsERC165(account)) {
            return false;
        }

        // query support of each interface in _interfaceIds
        for (uint256 i = 0; i < interfaceIds.length; i++) {
            if (!_supportsERC165Interface(account, interfaceIds[i])) {
                return false;
            }
        }

        // all interfaces supported
        return true;
    }

    /**
     * @notice Query if a contract implements an interface, does not check ERC165 support
     * @param account The address of the contract to query for support of an interface
     * @param interfaceId The interface identifier, as specified in ERC-165
     * @return true if the contract at account indicates support of the interface with
     * identifier interfaceId, false otherwise
     * @dev Assumes that account contains a contract that supports ERC165, otherwise
     * the behavior of this method is undefined. This precondition can be checked
     * with {supportsERC165}.
     * Interface identification is specified in ERC-165.
     */
    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {
        // success determines whether the staticcall succeeded and result determines
        // whether the contract at account indicates support of _interfaceId
        (bool success, bool result) = _callERC165SupportsInterface(account, interfaceId);

        return (success && result);
    }

    /**
     * @notice Calls the function with selector 0x01ffc9a7 (ERC165) and suppresses throw
     * @param account The address of the contract to query for support of an interface
     * @param interfaceId The interface identifier, as specified in ERC-165
     * @return success true if the STATICCALL succeeded, false otherwise
     * @return result true if the STATICCALL succeeded and the contract at account
     * indicates support of the interface with identifier interfaceId, false otherwise
     */
    function _callERC165SupportsInterface(address account, bytes4 interfaceId)
        private
        view
        returns (bool, bool)
    {
        bytes memory encodedParams = abi.encodeWithSelector(_INTERFACE_ID_ERC165, interfaceId);
        (bool success, bytes memory result) = account.staticcall{ gas: 30000 }(encodedParams);
        if (result.length < 32) return (false, false);
        return (success, abi.decode(result, (bool)));
    }
}


// File contracts/stake/StakeTON.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;
pragma abicoder v2;







/// @title Stake Contract
/// @notice It can be staked in Tokamak. Can be swapped using Uniswap.
/// Stake contracts can interact with the vault to claim tos tokens
contract StakeTON is TokamakStaker, IStakeTON {
    using SafeMath for uint256;

    /// @dev event on staking
    /// @param to the sender
    /// @param amount the amount of staking
    event Staked(address indexed to, uint256 amount);

    /// @dev event on claim
    /// @param to the sender
    /// @param amount the amount of claim
    /// @param claimBlock the block of claim
    event Claimed(address indexed to, uint256 amount, uint256 claimBlock);

    /// @dev event on withdrawal
    /// @param to the sender
    /// @param tonAmount the amount of TON withdrawal
    /// @param tosAmount the amount of TOS withdrawal
    event Withdrawal(address indexed to, uint256 tonAmount, uint256 tosAmount);

    /// @dev constructor of StakeTON
    constructor() {}

    /// @dev This contract cannot stake Ether.
    receive() external payable {
        revert("cannot stake Ether");
    }

    /// @dev withdraw
    function withdraw() external override {
        require(endBlock > 0 && endBlock < block.number, "StakeTON: not end");
        (
            address ton,
            address wton,
            address depositManager,
            address seigManager,

        ) = ITokamakRegistry(stakeRegistry).getTokamak();
        require(
            ton != address(0) &&
                wton != address(0) &&
                depositManager != address(0) &&
                seigManager != address(0),
            "StakeTON: ITokamakRegistry zero"
        );
        if (tokamakLayer2 != address(0)) {
            require(
                IISeigManager(seigManager).stakeOf(
                    tokamakLayer2,
                    address(this)
                ) ==
                    0 &&
                    IIDepositManager(depositManager).pendingUnstaked(
                        tokamakLayer2,
                        address(this)
                    ) ==
                    0,
                "StakeTON: remain amount in tokamak"
            );
        }
        LibTokenStake1.StakedAmount storage staked = userStaked[msg.sender];
        require(!staked.released, "StakeTON: Already withdraw");

        if (!withdrawFlag) {
            withdrawFlag = true;
            if (paytoken == ton) {
                swappedAmountTOS = IIERC20(token).balanceOf(address(this));
                finalBalanceWTON = IIERC20(wton).balanceOf(address(this));
                finalBalanceTON = IIERC20(ton).balanceOf(address(this));
                require(
                    finalBalanceWTON.div(10**9).add(finalBalanceTON) >=
                        totalStakedAmount,
                    "StakeTON: finalBalance is lack"
                );
            }
        }

        uint256 amount = staked.amount;
        require(amount > 0, "StakeTON: Amount wrong");
        staked.releasedBlock = block.number;
        staked.released = true;

        if (paytoken == ton) {
            uint256 tonAmount = 0;
            uint256 wtonAmount = 0;
            uint256 tosAmount = 0;
            if (finalBalanceTON > 0)
                tonAmount = finalBalanceTON.mul(amount).div(totalStakedAmount);
            if (finalBalanceWTON > 0)
                wtonAmount = finalBalanceWTON.mul(amount).div(
                    totalStakedAmount
                );
            if (swappedAmountTOS > 0)
                tosAmount = swappedAmountTOS.mul(amount).div(totalStakedAmount);

            staked.releasedTOSAmount = tosAmount;
            if (wtonAmount > 0)
                staked.releasedAmount = wtonAmount.div(10**9).add(tonAmount);
            else staked.releasedAmount = tonAmount;

            tonWithdraw(ton, wton, tonAmount, wtonAmount, tosAmount);
        } else if (paytoken == address(0)) {
            require(staked.releasedAmount <= amount, "StakeTON: Amount wrong");
            staked.releasedAmount = amount;
            address payable self = address(uint160(address(this)));
            require(self.balance >= amount, "StakeTON: insuffient ETH");
            (bool success, ) = msg.sender.call{value: amount}("");
            require(success, "StakeTON: withdraw failed.");
        } else {
            require(staked.releasedAmount <= amount, "StakeTON: Amount wrong");
            staked.releasedAmount = amount;
            require(
                IIERC20(paytoken).transfer(msg.sender, amount),
                "StakeTON: transfer fail"
            );
        }

        emit Withdrawal(
            msg.sender,
            staked.releasedAmount,
            staked.releasedTOSAmount
        );
    }

    /// @dev withdraw TON
    /// @param ton  TON address
    /// @param wton  WTON address
    /// @param tonAmount  the amount of TON to be withdrawn to msg.sender
    /// @param wtonAmount  the amount of WTON to be withdrawn to msg.sender
    /// @param tosAmount  the amount of TOS to be withdrawn to msg.sender
    function tonWithdraw(
        address ton,
        address wton,
        uint256 tonAmount,
        uint256 wtonAmount,
        uint256 tosAmount
    ) internal {
        if (tonAmount > 0) {
            require(
                IIERC20(ton).balanceOf(address(this)) >= tonAmount,
                "StakeTON: ton balance is lack"
            );

            require(
                IIERC20(ton).transfer(msg.sender, tonAmount),
                "StakeTON: transfer ton fail"
            );
        }
        if (wtonAmount > 0) {
            require(
                IIERC20(wton).balanceOf(address(this)) >= wtonAmount,
                "StakeTON: wton balance is lack"
            );
            require(
                IWTON(wton).swapToTONAndTransfer(msg.sender, wtonAmount),
                "StakeTON: transfer wton fail"
            );
        }
        if (tosAmount > 0) {
            require(
                IIERC20(token).balanceOf(address(this)) >= tosAmount,
                "StakeTON: tos balance is lack"
            );
            require(
                IIERC20(token).transfer(msg.sender, tosAmount),
                "StakeTON: transfer tos fail"
            );
        }
    }

    /// @dev Claim for reward
    function claim() external override lock {
        require(IIStake1Vault(vault).saleClosed(), "StakeTON: not closed");
        uint256 rewardClaim = 0;

        LibTokenStake1.StakedAmount storage staked = userStaked[msg.sender];
        require(staked.claimedBlock < endBlock, "StakeTON: claimed");

        rewardClaim = canRewardAmount(msg.sender, block.number);

        require(rewardClaim > 0, "StakeTON: reward is zero");

        uint256 rewardTotal =
            IIStake1Vault(vault).totalRewardAmount(address(this));
        require(
            rewardClaimedTotal.add(rewardClaim) <= rewardTotal,
            "StakeTON: total reward exceeds"
        );

        staked.claimedBlock = block.number;
        staked.claimedAmount = staked.claimedAmount.add(rewardClaim);
        rewardClaimedTotal = rewardClaimedTotal.add(rewardClaim);

        require(
            IIStake1Vault(vault).claim(msg.sender, rewardClaim),
            "StakeTON: fail claim from vault"
        );

        emit Claimed(msg.sender, rewardClaim, block.number);
    }

    /// @dev Returns the amount that can be rewarded
    /// @param account  the account that claimed reward
    /// @param specificBlock the block that claimed reward
    /// @return reward the reward amount that can be taken
    function canRewardAmount(address account, uint256 specificBlock)
        public
        view
        override
        returns (uint256)
    {
        uint256 reward = 0;
        if (specificBlock > endBlock) specificBlock = endBlock;

        if (
            specificBlock < startBlock ||
            userStaked[account].amount == 0 ||
            userStaked[account].claimedBlock > endBlock ||
            userStaked[account].claimedBlock > specificBlock
        ) {
            reward = 0;
        } else {
            uint256 startR = startBlock;
            uint256 endR = endBlock;
            if (startR < userStaked[account].claimedBlock)
                startR = userStaked[account].claimedBlock;
            if (specificBlock < endR) endR = specificBlock;

            uint256[] memory orderedEndBlocks =
                IIStake1Vault(vault).orderedEndBlocksAll();

            if (orderedEndBlocks.length > 0) {
                uint256 _end = 0;
                uint256 _start = startR;
                uint256 _total = 0;
                uint256 blockTotalReward = 0;
                blockTotalReward = IIStake1Vault(vault).blockTotalReward();

                address user = account;
                uint256 amount = userStaked[user].amount;

                for (uint256 i = 0; i < orderedEndBlocks.length; i++) {
                    _end = orderedEndBlocks[i];
                    _total = IIStake1Vault(vault).stakeEndBlockTotal(_end);

                    if (_start > _end) {} else if (endR <= _end) {
                        if (_total > 0) {
                            uint256 _period1 = endR.sub(startR);
                            reward = reward.add(
                                blockTotalReward.mul(_period1).mul(amount).div(
                                    _total
                                )
                            );
                        }
                        break;
                    } else {
                        if (_total > 0) {
                            uint256 _period2 = _end.sub(startR);
                            reward = reward.add(
                                blockTotalReward.mul(_period2).mul(amount).div(
                                    _total
                                )
                            );
                        }
                        startR = _end;
                    }
                }
            }
        }
        return reward;
    }
    /*
    function canRewardAmountTest(address account, uint256 specificBlock)
        public view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 reward = 0;
        uint256 startR = 0;
        uint256 endR = 0;
        uint256 blockTotalReward = 0;
        if(specificBlock > endBlock ) specificBlock = endBlock;

        if (
            specificBlock < startBlock ||
            userStaked[account].amount == 0 ||
            userStaked[account].claimedBlock > endBlock ||
            userStaked[account].claimedBlock > specificBlock
        ) {
            reward = 0;
        } else {
            startR = startBlock;
            endR = endBlock;
            if (startR < userStaked[account].claimedBlock)
                startR = userStaked[account].claimedBlock;
            if (specificBlock < endR) endR = specificBlock;

            uint256[] memory orderedEndBlocks =
                IIStake1Vault(vault).orderedEndBlocksAll();

            if (orderedEndBlocks.length > 0) {
                uint256 _end = 0;
                uint256 _start = startR;
                uint256 _total = 0;
                //uint256 blockTotalReward = 0;
                blockTotalReward = IIStake1Vault(vault).blockTotalReward();

                address user = account;
                uint256 amount = userStaked[user].amount;

                for (uint256 i = 0; i < orderedEndBlocks.length; i++) {
                    _end = orderedEndBlocks[i];
                    _total = IIStake1Vault(vault).stakeEndBlockTotal(_end);

                    if (_start > _end) {

                    } else if (endR <= _end) {
                        reward +=
                            (blockTotalReward *
                                (endR - startR) * amount) /
                            _total;
                        break;
                    } else {
                        reward +=
                            (blockTotalReward *
                                (_end - startR) *
                                amount) /
                            _total;
                        startR = _end;
                    }
                }
            }
        }
        return (reward, startR, endR, blockTotalReward);
    }
    */
}


// File contracts/interfaces/ITokamakStakerUpgrade.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface ITokamakStakerUpgrade {

    /// @dev the total staked amount
    function tokamakLayer2() external view returns (address);

    /// @dev the total staked amount
    function totalStakedAmount() external view returns (uint256);

    /// @dev the staking start block, once staking starts, users can no longer apply for staking.
    function startBlock() external view returns (uint256);

    /// @dev the staking end block.
    function endBlock() external view returns (uint256);

    /// @dev Change the TON holded in contract have to WTON, or change WTON to TON.
    /// @param amount the amount to be changed
    /// @param toWTON if it's true, TON->WTON , else WTON->TON
    function swapTONtoWTON(uint256 amount, bool toWTON) external;

    /// @dev  staking the staked TON in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    /// @param stakeAmount the amount that stake to layer2
    function tokamakStaking(address _layer2, uint256 stakeAmount) external;

    /// @dev  request unstaking the wtonAmount in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    /// @param wtonAmount the amount requested to unstaking
    function tokamakRequestUnStaking(address _layer2, uint256 wtonAmount)
        external;

    /// @dev  request unstaking the wtonAmount in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    function tokamakRequestUnStakingAll(address _layer2) external;

    /// @dev process unstaking in layer2 in tokamak
    /// @param _layer2 the layer2 address in tokamak
    function tokamakProcessUnStaking(address _layer2) external;

    /// @dev exchange holded WTON to TOS using uniswap-v3
    /// @param _amountIn the input amount
    /// @param _amountOutMinimum the minimun output amount
    /// @param _deadline deadline
    /// @param _sqrtPriceLimitX96 sqrtPriceLimitX96
    /// @param _kind the function type, if 0, use exactInputSingle function, else if, use exactInput function
    function exchangeWTONtoTOS(
        uint256 _amountIn,
        uint256 _amountOutMinimum,
        uint256 _deadline,
        uint160 _sqrtPriceLimitX96,
        uint256 _kind
    ) external returns (uint256 amountOut);

    function canTokamakRequestUnStaking(address _layer2)
        external
        view
        returns (uint256 canUnStakingAmount);

    function canTokamakRequestUnStakingAll(address _layer2)
        external
        view
        returns (bool can);

    function canTokamakRequestUnStakingAllBlock(address _layer2)
        external
        view
        returns (uint256 _block);

    function canTokamakProcessUnStakingCount(address _layer2)
        external
        view
        returns (uint256 count, uint256 amount);
}


// File contracts/stake/StakeTONControl.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;
pragma abicoder v2;






contract StakeTONControl is AccessibleCommon {
    using SafeMath for uint256;

    address public ton;
    address public wton;
    address public tos;
    address public depositManager;
    address public seigManager;
    address public layer2;
    uint256 public countStakeTons;
    mapping(uint256 => address) public stakeTons;

    modifier nonZeroAddress(address _addr) {
        require(_addr != address(0), "TokamakStaker: zero address");
        _;
    }
    modifier avaiableIndex(uint256 _index) {
        require(_index > 0, "StakeTONControl: can't use zero index");
        require(_index <= countStakeTons, "StakeTONControl: exceeded maxIndex");
        _;
    }

    constructor() {
        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function setInfo(
        address _ton,
        address _wton,
        address _tos,
        address _depositManager,
        address _seigManager,
        address _layer2,
        uint256 _countStakeTons
    ) external onlyOwner {
        ton = _ton;
        wton = _wton;
        tos = _tos;
        depositManager = _depositManager;
        seigManager = _seigManager;
        layer2 = _layer2;
        countStakeTons = _countStakeTons;
    }

    function deleteStakeTon(uint256 _index)
        external
        onlyOwner
        avaiableIndex(_index)
    {
        delete stakeTons[_index];
    }

    function addStakeTon(uint256 _index, address addr)
        external
        onlyOwner
        avaiableIndex(_index)
    {
        stakeTons[_index] = addr;
    }

    function addStakeTons(address[] calldata _addr) external onlyOwner {
        require(_addr.length > 0, "StakeTONControl: zero length");
        require(
            _addr.length == countStakeTons,
            "StakeTONControl: diff countStakeTons"
        );

        for (uint256 i = 1; i <= _addr.length; i++) {
            stakeTons[i] = _addr[i - 1];
        }
    }

    function canSwappedWTON(uint256 _index)
        public
        view
        nonZeroAddress(depositManager)
        nonZeroAddress(seigManager)
        nonZeroAddress(layer2)
        returns (uint256)
    {
        if (stakeTons[_index] == address(0)) return 0;
        uint256 endBlock = ITokamakStakerUpgrade(stakeTons[_index]).endBlock();

        if (block.number < endBlock) {
            uint256 _amountWTON = IIERC20(wton).balanceOf(stakeTons[_index]);
            uint256 _amountTON = IIERC20(ton).balanceOf(stakeTons[_index]);
            uint256 totalStakedAmount =
                ITokamakStakerUpgrade(stakeTons[_index]).totalStakedAmount();

            uint256 stakeOf = 0;

            stakeOf = IISeigManager(seigManager).stakeOf(
                layer2,
                stakeTons[_index]
            );
            stakeOf = stakeOf.add(
                IIIDepositManager(depositManager).pendingUnstaked(
                    layer2,
                    stakeTons[_index]
                )
            );
            uint256 holdAmount = _amountWTON;
            if (_amountTON > 0)
                holdAmount = holdAmount.add(_amountTON.mul(10**9));

            uint256 totalHoldAmount = holdAmount.add(stakeOf);

            if (totalHoldAmount.sub(100) > totalStakedAmount.mul(10**9)) {
                if (stakeOf.add(100) > totalStakedAmount.mul(10**9))
                    return holdAmount;
                else {
                    uint256 amount =
                        holdAmount.sub(
                            totalStakedAmount.mul(10**9).sub(stakeOf).sub(100)
                        );
                    return amount;
                }
            } else {
                return 0;
            }
        } else return 0;
    }

    function withdrawLayer2(uint256 _index) public nonZeroAddress(layer2) {
        require(
            stakeTons[_index] != address(0),
            "StakeTONControl: zero stakeTons"
        );

        (uint256 count, uint256 amount) =
            ITokamakStakerUpgrade(stakeTons[_index])
                .canTokamakProcessUnStakingCount(layer2);

        if (count > 0 && amount > 0)
            ITokamakStakerUpgrade(stakeTons[_index]).tokamakProcessUnStaking(
                layer2
            );
    }

    function swapTONtoTOS(uint256 _index, uint256 _amountOut) public  avaiableIndex(_index) {
        uint256 amountIn = canSwappedWTON(_index);
        if (amountIn > 0) {
            uint256 deadline = block.timestamp + 1000;
            ITokamakStakerUpgrade(stakeTons[_index]).exchangeWTONtoTOS(
                amountIn,
                _amountOut,
                deadline,
                0,
                0
            );
        }
    }

    function withdrawLayer2AndSwapTOS(uint256 _index, uint256 _amountOut)
        public
        nonZeroAddress(layer2)
    {
        withdrawLayer2(_index);
        swapTONtoTOS(_index, _amountOut);
    }

    function withdrawLayer2All() public nonZeroAddress(layer2)  {
        (bool can, bool[] memory canProcessUnStaking) = canWithdrawLayer2All();
        require(can, "StakeTONControl: no available withdraw from layer2");
        for (uint256 i = 1; i <= countStakeTons; i++) {
            if(canProcessUnStaking[i-1]) withdrawLayer2(i);
        }
    }

    function SwapAll(uint256[] memory amountOuts) public {
        require(amountOuts.length == countStakeTons, "StakeTONControl: diff length");
        for (uint256 i = 1; i <= countStakeTons; i++) {
            swapTONtoTOS(i, amountOuts[i-1]);
        }
    }

    function withdrawLayer2AllAndSwapAll(uint256[] memory amountOuts) external nonZeroAddress(layer2)  {

        withdrawLayer2All();
        SwapAll(amountOuts);
    }


    function canWithdrawLayer2All()
        public
        view
        nonZeroAddress(layer2)
        returns (bool can, bool[] memory canProcessUnStaking)
    {
        can = false;
        canProcessUnStaking = new bool[](countStakeTons);
        for (uint256 i = 1; i <= countStakeTons; i++) {
            if(ITokamakStakerUpgrade(stakeTons[i]).tokamakLayer2() == layer2){
                (uint256 count, uint256 amount) = ITokamakStakerUpgrade(stakeTons[i]).canTokamakProcessUnStakingCount(layer2);
                if (count > 0 && amount > 0) {
                    if(!can) can = true;
                    canProcessUnStaking[i-1] = true;
                } else {
                    canProcessUnStaking[i-1] = false;
                }
            }else{
                canProcessUnStaking[i-1] = false;
            }
        }
    }
}


// File contracts/stake/StakeTONProxy2.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;
pragma abicoder v2;







/// @title Proxy for Stake contracts in Phase 1
contract StakeTONProxy2 is StakeTONStorage, AccessibleCommon, ProxyBase {
    mapping(uint256 => address) public proxyImplementation;
    mapping(address => bool) public aliveImplementation;
    mapping(bytes4 => address) public selectorImplementation;

    modifier lock() {
        require(_lock == 0, "StakeTONProxy2: LOCKED");
        _lock = 1;
        _;
        _lock = 0;
    }

    constructor() {}

    /// @dev view implementation address of the proxy[index]
    /// @param _index index of proxy
    /// @return address of the implementation
    function implementation2(uint256 _index) external view returns (address) {
        return _implementation2(_index);
    }

    /// @dev set the implementation address and status of the proxy[index]
    /// @param newImplementation Address of the new implementation.
    /// @param _index index
    /// @param _alive _alive
    function setImplementation2(
        address newImplementation,
        uint256 _index,
        bool _alive
    ) external onlyOwner {
        _setImplementation2(newImplementation, _index, _alive);
    }

    /// @dev set alive status of implementation
    /// @param newImplementation Address of the new implementation.
    /// @param _alive alive status
    function setAliveImplementation2(address newImplementation, bool _alive)
        public
        onlyOwner
    {
        _setAliveImplementation2(newImplementation, _alive);
    }

    /// @dev set selectors of Implementation
    /// @param _selectors being added selectors
    /// @param _imp implementation address
    function setSelectorImplementations2(
        bytes4[] calldata _selectors,
        address _imp
    ) public onlyOwner {
        require(
            _selectors.length > 0,
            "StakeTONProxy2: _selectors's size is zero"
        );
        require(aliveImplementation[_imp], "StakeTONProxy2: _imp is not alive");

        for (uint256 i = 0; i < _selectors.length; i++) {
            require(
                selectorImplementation[_selectors[i]] != _imp,
                "StakeTONProxy2: same imp"
            );
            selectorImplementation[_selectors[i]] = _imp;
        }
    }

    /// @dev set the implementation address and status of the proxy[index]
    /// @param newImplementation Address of the new implementation.
    /// @param _index index of proxy
    /// @param _alive alive status
    function _setImplementation2(
        address newImplementation,
        uint256 _index,
        bool _alive
    ) internal {
        require(
            Address.isContract(newImplementation),
            "StakeTONProxy2: Cannot set a proxy implementation to a non-contract address"
        );
        if (_alive) proxyImplementation[_index] = newImplementation;
        _setAliveImplementation2(newImplementation, _alive);
    }

    /// @dev set alive status of implementation
    /// @param newImplementation Address of the new implementation.
    /// @param _alive alive status
    function _setAliveImplementation2(address newImplementation, bool _alive)
        internal
    {
        aliveImplementation[newImplementation] = _alive;
    }

    /// @dev view implementation address of the proxy[index]
    /// @param _index index of proxy
    /// @return impl address of the implementation
    function _implementation2(uint256 _index)
        internal
        view
        returns (address impl)
    {
        return proxyImplementation[_index];
    }

    /// @dev view implementation address of selector of function
    /// @param _selector selector of function
    /// @return impl address of the implementation
    function getSelectorImplementation2(bytes4 _selector)
        public
        view
        returns (address impl)
    {
        if (selectorImplementation[_selector] == address(0))
            return proxyImplementation[0];
        else if (aliveImplementation[selectorImplementation[_selector]])
            return selectorImplementation[_selector];
        else return proxyImplementation[0];
    }

    /// @dev receive ether
    receive() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    fallback() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    function _fallback() internal {
        address _impl = getSelectorImplementation2(msg.sig);
        require(
            _impl != address(0) && !pauseProxy,
            "StakeTONProxy2: impl OR proxy is false"
        );

        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }
}


// File contracts/stake/StakeTONUnstaking.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;
pragma abicoder v2;



contract StakeTONUnstaking is AccessibleCommon {
    using SafeMath for uint256;

    address public ton;
    address public wton;
    address public tos;
    address public depositManager;
    address public seigManager;
    address public layer2;
    uint256 public countStakeTons;
    mapping(uint256 => address) public stakeTons;

    modifier nonZeroAddress(address _addr) {
        require(_addr != address(0), "StakeTONUnstaking: zero address");
        _;
    }
    modifier avaiableIndex(uint256 _index) {
        require(_index > 0, "StakeTONUnstaking: can't use zero index");
        require(_index <= countStakeTons, "StakeTONUnstaking: exceeded maxIndex");
        _;
    }

    constructor() {
        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function setInfo(
        address _ton,
        address _wton,
        address _tos,
        address _depositManager,
        address _seigManager,
        address _layer2,
        uint256 _countStakeTons
    ) external onlyOwner {
        ton = _ton;
        wton = _wton;
        tos = _tos;
        depositManager = _depositManager;
        seigManager = _seigManager;
        layer2 = _layer2;
        countStakeTons = _countStakeTons;
    }

    function deleteStakeTon(uint256 _index)
        external
        onlyOwner
        avaiableIndex(_index)
    {
        delete stakeTons[_index];
    }

    function addStakeTon(uint256 _index, address addr)
        external
        onlyOwner
        avaiableIndex(_index)
    {
        stakeTons[_index] = addr;
    }

    function addStakeTons(address[] calldata _addr) external onlyOwner {
        require(_addr.length > 0, "StakeTONUnstaking: zero length");
        require(
            _addr.length == countStakeTons,
            "StakeTONUnstaking: diff countStakeTons"
        );

        for (uint256 i = 1; i <= _addr.length; i++) {
            stakeTons[i] = _addr[i - 1];
        }
    }


    function requestUnstakingLayer2All() public nonZeroAddress(layer2)  {
        (bool can, bool[] memory canRequest, bool[] memory canRequestAll) = canRequestUnstakingLayer2All();
        require(can, "StakeTONUnstaking: no available unstaking from layer2");
        for (uint256 i = 1; i <= countStakeTons; i++) {

            if(canRequestAll[i-1]) {
                ITokamakStakerUpgrade(stakeTons[i]).tokamakRequestUnStakingAll(
                    layer2
                );
            } else if(canRequest[i-1] ) {
                ITokamakStakerUpgrade(stakeTons[i]).tokamakRequestUnStaking(
                    layer2,
                    1
                );
            }
        }
    }


    function canRequestUnstakingLayer2All()
        public
        view
        nonZeroAddress(layer2)
        returns (bool can, bool[] memory canRequestUnStaking, bool[] memory canRequestUnStakingAll)
    {
        can = false;
        canRequestUnStaking = new bool[](countStakeTons);
        canRequestUnStakingAll = new bool[](countStakeTons);

        for (uint256 i = 1; i <= countStakeTons; i++) {

            if(ITokamakStakerUpgrade(stakeTons[i]).tokamakLayer2() == layer2){

                (uint256 canUnStakingAmount) = ITokamakStakerUpgrade(stakeTons[i]).canTokamakRequestUnStaking(layer2);
                (bool canUnStaking) = ITokamakStakerUpgrade(stakeTons[i]).canTokamakRequestUnStakingAll(layer2);

                if(canUnStakingAmount > 0 || canUnStaking ) {
                    if(!can) can = true;
                    if(canUnStaking) canRequestUnStakingAll[i-1] = true;
                    else canRequestUnStaking[i-1] = true;
                }

            }
        }
    }
}


// File contracts/stake/StakeTONUpgrade.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;
pragma abicoder v2;







/// @title Stake Contract
/// @notice It can be staked in Tokamak. Can be swapped using Uniswap.
/// Stake contracts can interact with the vault to claim tos tokens
contract StakeTONUpgrade is TokamakStakeUpgrade, IStakeTON {
    using SafeMath for uint256;

    /// @dev event on staking
    /// @param to the sender
    /// @param amount the amount of staking
    event Staked(address indexed to, uint256 amount);

    /// @dev event on claim
    /// @param to the sender
    /// @param amount the amount of claim
    /// @param claimBlock the block of claim
    event Claimed(address indexed to, uint256 amount, uint256 claimBlock);

    /// @dev event on withdrawal
    /// @param to the sender
    /// @param tonAmount the amount of TON withdrawal
    /// @param tosAmount the amount of TOS withdrawal
    event Withdrawal(address indexed to, uint256 tonAmount, uint256 tosAmount);

    /// @dev constructor of StakeTON
    constructor() {}

    /// @dev This contract cannot stake Ether.
    receive() external payable {
        revert("cannot stake Ether");
    }

    /// @dev withdraw
    function withdraw() external override {
        require(endBlock > 0 && endBlock < block.number, "StakeTON: not end");
        (
            address ton,
            address wton,
            address depositManager,
            address seigManager,

        ) = ITokamakRegistry1(stakeRegistry).getTokamak();
        require(
            ton != address(0) &&
                wton != address(0) &&
                depositManager != address(0) &&
                seigManager != address(0),
            "StakeTON: ITokamakRegistry zero"
        );
        if (tokamakLayer2 != address(0)) {
            require(
                IISeigManager(seigManager).stakeOf(
                    tokamakLayer2,
                    address(this)
                ) ==
                    0 &&
                    IIDepositManager(depositManager).pendingUnstaked(
                        tokamakLayer2,
                        address(this)
                    ) ==
                    0,
                "StakeTON: remain amount in tokamak"
            );
        }
        LibTokenStake1.StakedAmount storage staked = userStaked[msg.sender];
        require(!staked.released, "StakeTON: Already withdraw");

        if (!withdrawFlag) {
            withdrawFlag = true;
            if (paytoken == ton) {
                swappedAmountTOS = IIERC20(token).balanceOf(address(this));
                finalBalanceWTON = IIERC20(wton).balanceOf(address(this));
                finalBalanceTON = IIERC20(ton).balanceOf(address(this));
                require(
                    finalBalanceWTON.div(10**9).add(finalBalanceTON) >=
                        totalStakedAmount,
                    "StakeTON: finalBalance is lack"
                );
            }
        }

        uint256 amount = staked.amount;
        require(amount > 0, "StakeTON: Amount wrong");
        staked.releasedBlock = block.number;
        staked.released = true;

        if (paytoken == ton) {
            uint256 tonAmount = 0;
            uint256 wtonAmount = 0;
            uint256 tosAmount = 0;
            if (finalBalanceTON > 0)
                tonAmount = finalBalanceTON.mul(amount).div(totalStakedAmount);
            if (finalBalanceWTON > 0)
                wtonAmount = finalBalanceWTON.mul(amount).div(
                    totalStakedAmount
                );
            if (swappedAmountTOS > 0)
                tosAmount = swappedAmountTOS.mul(amount).div(totalStakedAmount);

            staked.releasedTOSAmount = tosAmount;
            if (wtonAmount > 0)
                staked.releasedAmount = wtonAmount.div(10**9).add(tonAmount);
            else staked.releasedAmount = tonAmount;

            tonWithdraw(ton, wton, tonAmount, wtonAmount, tosAmount);
        } else if (paytoken == address(0)) {
            require(staked.releasedAmount <= amount, "StakeTON: Amount wrong");
            staked.releasedAmount = amount;
            address payable self = address(uint160(address(this)));
            require(self.balance >= amount, "StakeTON: insuffient ETH");
            (bool success, ) = msg.sender.call{value: amount}("");
            require(success, "StakeTON: withdraw failed.");
        } else {
            require(staked.releasedAmount <= amount, "StakeTON: Amount wrong");
            staked.releasedAmount = amount;
            require(
                IIERC20(paytoken).transfer(msg.sender, amount),
                "StakeTON: transfer fail"
            );
        }

        emit Withdrawal(
            msg.sender,
            staked.releasedAmount,
            staked.releasedTOSAmount
        );
    }

    /// @dev withdraw TON
    /// @param ton  TON address
    /// @param wton  WTON address
    /// @param tonAmount  the amount of TON to be withdrawn to msg.sender
    /// @param wtonAmount  the amount of WTON to be withdrawn to msg.sender
    /// @param tosAmount  the amount of TOS to be withdrawn to msg.sender
    function tonWithdraw(
        address ton,
        address wton,
        uint256 tonAmount,
        uint256 wtonAmount,
        uint256 tosAmount
    ) internal {
        if (tonAmount > 0) {
            require(
                IIERC20(ton).balanceOf(address(this)) >= tonAmount,
                "StakeTON: ton balance is lack"
            );

            require(
                IIERC20(ton).transfer(msg.sender, tonAmount),
                "StakeTON: transfer ton fail"
            );
        }
        if (wtonAmount > 0) {
            require(
                IIERC20(wton).balanceOf(address(this)) >= wtonAmount,
                "StakeTON: wton balance is lack"
            );
            require(
                IWTON(wton).swapToTONAndTransfer(msg.sender, wtonAmount),
                "StakeTON: transfer wton fail"
            );
        }
        if (tosAmount > 0) {
            require(
                IIERC20(token).balanceOf(address(this)) >= tosAmount,
                "StakeTON: tos balance is lack"
            );
            require(
                IIERC20(token).transfer(msg.sender, tosAmount),
                "StakeTON: transfer tos fail"
            );
        }
    }

    /// @dev Claim for reward
    function claim() external override lock {
        require(IIStake1Vault(vault).saleClosed(), "StakeTON: not closed");
        uint256 rewardClaim = 0;

        LibTokenStake1.StakedAmount storage staked = userStaked[msg.sender];
        require(staked.claimedBlock < endBlock, "StakeTON: claimed");

        rewardClaim = canRewardAmount(msg.sender, block.number);

        require(rewardClaim > 0, "StakeTON: reward is zero");

        uint256 rewardTotal =
            IIStake1Vault(vault).totalRewardAmount(address(this));
        require(
            rewardClaimedTotal.add(rewardClaim) <= rewardTotal,
            "StakeTON: total reward exceeds"
        );

        staked.claimedBlock = block.number;
        staked.claimedAmount = staked.claimedAmount.add(rewardClaim);
        rewardClaimedTotal = rewardClaimedTotal.add(rewardClaim);

        require(
            IIStake1Vault(vault).claim(msg.sender, rewardClaim),
            "StakeTON: fail claim from vault"
        );

        emit Claimed(msg.sender, rewardClaim, block.number);
    }

    /// @dev Returns the amount that can be rewarded
    /// @param account  the account that claimed reward
    /// @param specificBlock the block that claimed reward
    /// @return reward the reward amount that can be taken
    function canRewardAmount(address account, uint256 specificBlock)
        public
        view
        override
        returns (uint256)
    {
        uint256 reward = 0;
        if (specificBlock > endBlock) specificBlock = endBlock;

        if (
            specificBlock < startBlock ||
            userStaked[account].amount == 0 ||
            userStaked[account].claimedBlock > endBlock ||
            userStaked[account].claimedBlock > specificBlock
        ) {
            reward = 0;
        } else {
            uint256 startR = startBlock;
            uint256 endR = endBlock;
            if (startR < userStaked[account].claimedBlock)
                startR = userStaked[account].claimedBlock;
            if (specificBlock < endR) endR = specificBlock;

            uint256[] memory orderedEndBlocks =
                IIStake1Vault(vault).orderedEndBlocksAll();

            if (orderedEndBlocks.length > 0) {
                uint256 _end = 0;
                uint256 _start = startR;
                uint256 _total = 0;
                uint256 blockTotalReward = 0;
                blockTotalReward = IIStake1Vault(vault).blockTotalReward();

                address user = account;
                uint256 amount = userStaked[user].amount;

                for (uint256 i = 0; i < orderedEndBlocks.length; i++) {
                    _end = orderedEndBlocks[i];
                    _total = IIStake1Vault(vault).stakeEndBlockTotal(_end);

                    if (_start > _end) {} else if (endR <= _end) {
                        if (_total > 0) {
                            uint256 _period1 = endR.sub(startR);
                            reward = reward.add(
                                blockTotalReward.mul(_period1).mul(amount).div(
                                    _total
                                )
                            );
                        }
                        break;
                    } else {
                        if (_total > 0) {
                            uint256 _period2 = _end.sub(startR);
                            reward = reward.add(
                                blockTotalReward.mul(_period2).mul(amount).div(
                                    _total
                                )
                            );
                        }
                        startR = _end;
                    }
                }
            }
        }
        return reward;
    }
    /*
    function canRewardAmountTest(address account, uint256 specificBlock)
        public view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 reward = 0;
        uint256 startR = 0;
        uint256 endR = 0;
        uint256 blockTotalReward = 0;
        if(specificBlock > endBlock ) specificBlock = endBlock;

        if (
            specificBlock < startBlock ||
            userStaked[account].amount == 0 ||
            userStaked[account].claimedBlock > endBlock ||
            userStaked[account].claimedBlock > specificBlock
        ) {
            reward = 0;
        } else {
            startR = startBlock;
            endR = endBlock;
            if (startR < userStaked[account].claimedBlock)
                startR = userStaked[account].claimedBlock;
            if (specificBlock < endR) endR = specificBlock;

            uint256[] memory orderedEndBlocks =
                IIStake1Vault(vault).orderedEndBlocksAll();

            if (orderedEndBlocks.length > 0) {
                uint256 _end = 0;
                uint256 _start = startR;
                uint256 _total = 0;
                //uint256 blockTotalReward = 0;
                blockTotalReward = IIStake1Vault(vault).blockTotalReward();

                address user = account;
                uint256 amount = userStaked[user].amount;

                for (uint256 i = 0; i < orderedEndBlocks.length; i++) {
                    _end = orderedEndBlocks[i];
                    _total = IIStake1Vault(vault).stakeEndBlockTotal(_end);

                    if (_start > _end) {

                    } else if (endR <= _end) {
                        reward +=
                            (blockTotalReward *
                                (endR - startR) * amount) /
                            _total;
                        break;
                    } else {
                        reward +=
                            (blockTotalReward *
                                (_end - startR) *
                                amount) /
                            _total;
                        startR = _end;
                    }
                }
            }
        }
        return (reward, startR, endR, blockTotalReward);
    }
    */
}


// File contracts/stake/StakeTONUpgrade2.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;
pragma abicoder v2;





// import {
//     ERC165Checker
// } from "@openzeppelin/contracts/introspection/ERC165Checker.sol";
// import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";

/// @title Stake Contract
/// @notice It can be staked in Tokamak. Can be swapped using Uniswap.
/// Stake contracts can interact with the vault to claim tos tokens
contract StakeTONUpgrade2 is TokamakStakeUpgrade2, IStakeTON {
    using SafeMath for uint256;

    /// @dev event on staking
    /// @param to the sender
    /// @param amount the amount of staking
    event Staked(address indexed to, uint256 amount);

    /// @dev event on claim
    /// @param to the sender
    /// @param amount the amount of claim
    /// @param claimBlock the block of claim
    event Claimed(address indexed to, uint256 amount, uint256 claimBlock);

    /// @dev event on withdrawal
    /// @param to the sender
    /// @param tonAmount the amount of TON withdrawal
    /// @param tosAmount the amount of TOS withdrawal
    event Withdrawal(address indexed to, uint256 tonAmount, uint256 tosAmount);

    /// @dev constructor of StakeTON
    constructor() {}

    /// @dev This contract cannot stake Ether.
    receive() external payable {
        revert("cannot stake Ether");
    }

    /// @dev withdraw
    function withdraw() external override {
        require(endBlock > 0 && endBlock < block.number, "StakeTON: not end");
        (
            address ton,
            address wton,
            address depositManager,
            address seigManager,

        ) = ITokamakRegistry2(stakeRegistry).getTokamak();
        require(
            ton != address(0) &&
                wton != address(0) &&
                depositManager != address(0) &&
                seigManager != address(0),
            "StakeTON: ITokamakRegistry zero"
        );
        if (tokamakLayer2 != address(0)) {
            require(
                IISeigManager(seigManager).stakeOf(
                    tokamakLayer2,
                    address(this)
                ) ==
                    0 &&
                    IIIDepositManager(depositManager).pendingUnstaked(
                        tokamakLayer2,
                        address(this)
                    ) ==
                    0,
                "StakeTON: remain amount in tokamak"
            );
        }
        LibTokenStake1.StakedAmount storage staked = userStaked[msg.sender];
        require(!staked.released, "StakeTON: Already withdraw");

        if (!withdrawFlag) {
            withdrawFlag = true;
            if (paytoken == ton) {
                swappedAmountTOS = IIERC20(token).balanceOf(address(this));
                finalBalanceWTON = IIERC20(wton).balanceOf(address(this));
                finalBalanceTON = IIERC20(ton).balanceOf(address(this));
                require(
                    finalBalanceWTON.div(10**9).add(finalBalanceTON) >=
                        totalStakedAmount,
                    "StakeTON: finalBalance is lack"
                );
            }
        }

        uint256 amount = staked.amount;
        require(amount > 0, "StakeTON: Amount wrong");
        staked.releasedBlock = block.number;
        staked.released = true;

        if (paytoken == ton) {
            uint256 tonAmount = 0;
            uint256 wtonAmount = 0;
            uint256 tosAmount = 0;
            if (finalBalanceTON > 0)
                tonAmount = finalBalanceTON.mul(amount).div(totalStakedAmount);
            if (finalBalanceWTON > 0)
                wtonAmount = finalBalanceWTON.mul(amount).div(
                    totalStakedAmount
                );
            if (swappedAmountTOS > 0)
                tosAmount = swappedAmountTOS.mul(amount).div(totalStakedAmount);

            staked.releasedTOSAmount = tosAmount;
            if (wtonAmount > 0)
                staked.releasedAmount = wtonAmount.div(10**9).add(tonAmount);
            else staked.releasedAmount = tonAmount;

            tonWithdraw(ton, wton, tonAmount, wtonAmount, tosAmount);
        } else if (paytoken == address(0)) {
            require(staked.releasedAmount <= amount, "StakeTON: Amount wrong");
            staked.releasedAmount = amount;
            address payable self = address(uint160(address(this)));
            require(self.balance >= amount, "StakeTON: insuffient ETH");
            (bool success, ) = msg.sender.call{value: amount}("");
            require(success, "StakeTON: withdraw failed.");
        } else {
            require(staked.releasedAmount <= amount, "StakeTON: Amount wrong");
            staked.releasedAmount = amount;
            require(
                IIERC20(paytoken).transfer(msg.sender, amount),
                "StakeTON: transfer fail"
            );
        }

        emit Withdrawal(
            msg.sender,
            staked.releasedAmount,
            staked.releasedTOSAmount
        );
    }

    /// @dev withdraw TON
    /// @param ton  TON address
    /// @param wton  WTON address
    /// @param tonAmount  the amount of TON to be withdrawn to msg.sender
    /// @param wtonAmount  the amount of WTON to be withdrawn to msg.sender
    /// @param tosAmount  the amount of TOS to be withdrawn to msg.sender
    function tonWithdraw(
        address ton,
        address wton,
        uint256 tonAmount,
        uint256 wtonAmount,
        uint256 tosAmount
    ) internal {
        if (tonAmount > 0) {
            require(
                IIERC20(ton).balanceOf(address(this)) >= tonAmount,
                "StakeTON: ton balance is lack"
            );

            require(
                IIERC20(ton).transfer(msg.sender, tonAmount),
                "StakeTON: transfer ton fail"
            );
        }
        if (wtonAmount > 0) {
            require(
                IIERC20(wton).balanceOf(address(this)) >= wtonAmount,
                "StakeTON: wton balance is lack"
            );
            require(
                IWTON(wton).swapToTONAndTransfer(msg.sender, wtonAmount),
                "StakeTON: transfer wton fail"
            );
        }
        if (tosAmount > 0) {
            require(
                IIERC20(token).balanceOf(address(this)) >= tosAmount,
                "StakeTON: tos balance is lack"
            );
            require(
                IIERC20(token).transfer(msg.sender, tosAmount),
                "StakeTON: transfer tos fail"
            );
        }
    }

    /// @dev Claim for reward
    function claim() external override lock {
        require(IIStake1Vault(vault).saleClosed(), "StakeTON: not closed");
        uint256 rewardClaim = 0;

        LibTokenStake1.StakedAmount storage staked = userStaked[msg.sender];
        require(
            staked.amount > 0 && staked.claimedBlock < endBlock,
            "StakeTON: claimed"
        );

        rewardClaim = canRewardAmount(msg.sender, block.number);

        require(rewardClaim > 0, "StakeTON: reward is zero");

        uint256 rewardTotal =
            IIStake1Vault(vault).totalRewardAmount(address(this));
        require(
            rewardClaimedTotal.add(rewardClaim) <= rewardTotal,
            "StakeTON: total reward exceeds"
        );

        staked.claimedBlock = block.number;
        staked.claimedAmount = staked.claimedAmount.add(rewardClaim);
        rewardClaimedTotal = rewardClaimedTotal.add(rewardClaim);

        require(
            IIStake1Vault(vault).claim(msg.sender, rewardClaim),
            "StakeTON: fail claim from vault"
        );

        emit Claimed(msg.sender, rewardClaim, block.number);
    }

    /// @dev Returns the amount that can be rewarded
    /// @param account  the account that claimed reward
    /// @param specificBlock the block that claimed reward
    /// @return reward the reward amount that can be taken
    function canRewardAmount(address account, uint256 specificBlock)
        public
        view
        override
        returns (uint256)
    {
        uint256 reward = 0;
        if (specificBlock > endBlock) specificBlock = endBlock;

        if (
            specificBlock < startBlock ||
            userStaked[account].amount == 0 ||
            userStaked[account].claimedBlock > endBlock ||
            userStaked[account].claimedBlock > specificBlock
        ) {
            reward = 0;
        } else {
            uint256 startR = startBlock;
            uint256 endR = endBlock;
            if (startR < userStaked[account].claimedBlock)
                startR = userStaked[account].claimedBlock;
            if (specificBlock < endR) endR = specificBlock;

            uint256[] memory orderedEndBlocks =
                IIStake1Vault(vault).orderedEndBlocksAll();

            if (orderedEndBlocks.length > 0) {
                uint256 _end = 0;
                uint256 _start = startR;
                uint256 _total = 0;
                uint256 blockTotalReward = 0;
                blockTotalReward = IIStake1Vault(vault).blockTotalReward();

                address user = account;
                uint256 amount = userStaked[user].amount;

                for (uint256 i = 0; i < orderedEndBlocks.length; i++) {
                    _end = orderedEndBlocks[i];
                    _total = IIStake1Vault(vault).stakeEndBlockTotal(_end);

                    if (_start > _end) {} else if (endR <= _end) {
                        if (_total > 0) {
                            uint256 _period1 = endR.sub(startR);
                            reward = reward.add(
                                blockTotalReward.mul(_period1).mul(amount).div(
                                    _total
                                )
                            );
                        }
                        break;
                    } else {
                        if (_total > 0) {
                            uint256 _period2 = _end.sub(startR);
                            reward = reward.add(
                                blockTotalReward.mul(_period2).mul(amount).div(
                                    _total
                                )
                            );
                        }
                        startR = _end;
                    }
                }
            }
        }
        return reward;
    }
}


// File contracts/stake/StakeTONUpgrade3.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;
pragma abicoder v2;







interface ITokamakRegistry3 {
    function getTokamak()
        external
        view
        returns (
            address,
            address,
            address,
            address,
            address
        );

    function defiInfo(bytes32)
        external
        view
        returns (
            string memory,
            address,
            address,
            address,
            uint256,
            address
        );
}

interface ITOS3 {
    function balanceOf(address owner) external view returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);

    function burn(address from, uint256 amount) external returns (bool);

    //function isBurner(address account) external view returns (bool);

    function hasRole(bytes32 role, address account) external view returns (bool) ;

}

contract StakeTONUpgrade3 is StakeTONStorage, AccessibleCommon {
    using SafeMath for uint256;

    modifier lock() {
        require(_lock == 0, "StakeTONUpgrade3: LOCKED");
        _lock = 1;
        _;
        _lock = 0;
    }

    /// @dev event on withdrawal
    /// @param to the sender
    /// @param tonAmount the amount of TON withdrawal
    /// @param tosAmount the amount of TOS withdrawal
    event Withdrawal(address indexed to, uint256 tonAmount, uint256 tosAmount);
    event TonWithdrawal(
        address indexed to,
        uint256 tonAmount,
        uint256 wtonAmount,
        uint256 tosAmount,
        uint256 tosBurnAmount
    );

    /// @dev constructor of StakeTON
    constructor() {}

    /// @dev This contract cannot stake Ether.
    receive() external payable {
        revert("cannot stake Ether");
    }

    /// @dev withdraw
    function withdraw() external {
        require(
            endBlock > 0 && endBlock < block.number,
            "StakeTONUpgrade3: not end"
        );

        (
            address ton,
            address wton,
            address depositManager,
            address seigManager,
        ) = ITokamakRegistry3(stakeRegistry).getTokamak();

        (, , , , uint256 _burnPercent, ) =
            ITokamakRegistry3(stakeRegistry).defiInfo(
                keccak256("PHASE1.SWAPTOS.BURNPERCENT")
            );

        require(
            ton != address(0) &&
                wton != address(0) &&
                depositManager != address(0) &&
                seigManager != address(0),
            "StakeTONUpgrade3: ITokamakRegistry zero"
        );
        if (tokamakLayer2 != address(0)) {
            require(
                IISeigManager(seigManager).stakeOf(
                    tokamakLayer2,
                    address(this)
                ) ==
                    0 &&
                    IIIDepositManager(depositManager).pendingUnstaked(
                        tokamakLayer2,
                        address(this)
                    ) ==
                    0,
                "StakeTONUpgrade3: remain amount in tokamak"
            );
        }
        LibTokenStake1.StakedAmount storage staked = userStaked[msg.sender];
        require(!staked.released, "StakeTONUpgrade3: Already withdraw");

        if (!withdrawFlag) {
            withdrawFlag = true;
            if (paytoken == ton) {
                swappedAmountTOS = ITOS3(token).balanceOf(address(this));
                finalBalanceWTON = ITOS3(wton).balanceOf(address(this));
                finalBalanceTON = ITOS3(ton).balanceOf(address(this));
                require(
                    finalBalanceWTON.div(10**9).add(finalBalanceTON) >=
                        totalStakedAmount,
                    "StakeTONUpgrade3: finalBalance is lack"
                );
            }
        }

        uint256 amount = staked.amount;
        require(amount > 0, "StakeTONUpgrade3: Amount wrong");
        staked.releasedBlock = block.number;
        staked.released = true;
        totalStakers = totalStakers.sub(1);

        if (paytoken == ton) {
            uint256 tonAmount = 0;
            uint256 wtonAmount = 0;
            uint256 tosAmount = 0;
            uint256 tosBurnAmount = 0;

            if (finalBalanceTON > 0)
                tonAmount = finalBalanceTON.mul(amount).div(totalStakedAmount);
            if (finalBalanceWTON > 0)
                wtonAmount = finalBalanceWTON.mul(amount).div(
                    totalStakedAmount
                );
            if (swappedAmountTOS > 0) {
                tosAmount = swappedAmountTOS.mul(amount).div(totalStakedAmount);
                if (tosAmount > 0 && _burnPercent > 0 && _burnPercent <= 100) {
                    tosBurnAmount = tosAmount.mul(_burnPercent).div(100);
                    tosAmount = tosAmount.sub(tosBurnAmount);
                }
            }

            staked.releasedTOSAmount = tosAmount;
            if (wtonAmount > 0)
                staked.releasedAmount = wtonAmount.div(10**9).add(tonAmount);
            else staked.releasedAmount = tonAmount;

            tonWithdraw(
                ton,
                wton,
                tonAmount,
                wtonAmount,
                tosAmount,
                tosBurnAmount
            );

        } else if (paytoken == address(0)) {
            require(
                staked.releasedAmount <= amount,
                "StakeTONUpgrade3: Amount wrong"
            );
            staked.releasedAmount = amount;
            address payable self = address(uint160(address(this)));
            require(self.balance >= amount, "StakeTONUpgrade3: insuffient ETH");
            (bool success, ) = msg.sender.call{value: amount}("");
            require(success, "StakeTONUpgrade3: withdraw failed.");
        } else {
            require(
                staked.releasedAmount <= amount,
                "StakeTONUpgrade3: Amount wrong"
            );
            staked.releasedAmount = amount;
            require(
                ITOS3(paytoken).transfer(msg.sender, amount),
                "StakeTONUpgrade3: transfer fail"
            );
        }

        emit Withdrawal(
            msg.sender,
            staked.releasedAmount,
            staked.releasedTOSAmount
        );
    }

    /// @dev withdraw TON
    /// @param ton  TON address
    /// @param wton  WTON address
    /// @param tonAmount  the amount of TON to be withdrawn to msg.sender
    /// @param wtonAmount  the amount of WTON to be withdrawn to msg.sender
    /// @param tosAmount  the amount of TOS to be withdrawn to msg.sender
    function tonWithdraw(
        address ton,
        address wton,
        uint256 tonAmount,
        uint256 wtonAmount,
        uint256 tosAmount,
        uint256 tosBurnAmount
    ) internal {
        if (tonAmount > 0) {
            require(
                ITOS3(ton).balanceOf(address(this)) >= tonAmount,
                "StakeTONUpgrade3: ton balance is lack"
            );

            require(
                ITOS3(ton).transfer(msg.sender, tonAmount),
                "StakeTONUpgrade3: transfer ton fail"
            );
        }
        if (wtonAmount > 0) {
            require(
                ITOS3(wton).balanceOf(address(this)) >= wtonAmount,
                "StakeTONUpgrade3: wton balance is lack"
            );
            require(
                IWTON(wton).swapToTONAndTransfer(msg.sender, wtonAmount),
                "StakeTONUpgrade3: transfer wton fail"
            );
        }
        if (tosAmount > 0) {
            require(
                ITOS3(token).balanceOf(address(this)) >= tosAmount,
                "StakeTONUpgrade3: tos balance is lack"
            );
            require(
                ITOS3(token).transfer(msg.sender, tosAmount),
                "StakeTONUpgrade3: transfer tos fail"
            );
        }
        if (tosBurnAmount > 0) {
            // require(
            //     ITOS3(token).isBurner(address(this)),
            //     "StakeTONUpgrade3: not burner"
            // );
            require(
                ITOS3(token).hasRole(keccak256("BURNER"), address(this)),
                "StakeTONUpgrade3: not burner"
            );
            require(
                ITOS3(token).burn(address(this), tosBurnAmount),
                "StakeTONUpgrade3: tos burn fail"
            );
        }

        emit TonWithdrawal(
            msg.sender,
            tonAmount,
            wtonAmount,
            tosAmount,
            tosBurnAmount
        );
    }

    function version() external pure returns (string memory) {
        return "phase1.upgrade.v3";
    }


}


// File contracts/interfaces/IIStake2Vault.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

//pragma abicoder v2;
//import "../libraries/LibTokenStake1.sol";

interface IIStake2Vault {
    /// @dev  of according to request from(staking contract)  the amount of mining is paid to to.
    /// @param to the address that will receive the reward
    /// @param minableAmount minable amount
    /// @param miningAmount amount mined
    /// @param nonMiningAmount Amount not mined
    function claimMining(
        address to,
        uint256 minableAmount,
        uint256 miningAmount,
        uint256 nonMiningAmount
    ) external returns (bool);

    /// @dev mining per second
    function miningPerSecond() external view returns (uint256);

    /// @dev mining start time
    function miningStartTime() external view returns (uint256);

    /// @dev mining end time
    function miningEndTime() external view returns (uint256);
}


// File contracts/libraries/SafeMath32.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

/**
 * @title SafeMath32
 * @dev SafeMath library implemented for uint32
 */
library SafeMath32 {
    function mul(uint32 a, uint32 b) internal pure returns (uint32) {
        if (a == 0) {
            return 0;
        }
        uint32 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint32 a, uint32 b) internal pure returns (uint32) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint32 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }

    function sub(uint32 a, uint32 b) internal pure returns (uint32) {
        assert(b <= a);
        return a - b;
    }

    function add(uint32 a, uint32 b) internal pure returns (uint32) {
        uint32 c = a + b;
        assert(c >= a);
        return c;
    }
}


// File contracts/stake/StakeUniswapV3.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

//import "@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol";
//import "@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol";

//import "../interfaces/IStakeRegistry.sol";








/// @title StakeUniswapV3
/// @notice Uniswap V3 Contract for staking LP and mining TOS
contract StakeUniswapV3 is
    StakeUniswapV3Storage,
    AccessibleCommon,
    IStakeUniswapV3,
    DSMath
{
    using SafeMath for uint256;
    using SafeMath32 for uint32;

    struct PositionInfo {
        // the amount of liquidity owned by this position
        uint128 liquidity;
        // fee growth per unit of liquidity as of the last update to liquidity or fees owed
        uint256 feeGrowthInside0LastX128;
        uint256 feeGrowthInside1LastX128;
        // the fees owed to the position owner in token0/token1
        uint128 tokensOwed0;
        uint128 tokensOwed1;
    }

    struct Slot0 {
        // the current price
        uint160 sqrtPriceX96;
        // the current tick
        int24 tick;
        // the most-recently updated index of the observations array
        uint16 observationIndex;
        // the current maximum number of observations that are being stored
        uint16 observationCardinality;
        // the next maximum number of observations to store, triggered in observations.write
        uint16 observationCardinalityNext;
        // the current protocol fee as a percentage of the swap fee taken on withdrawal
        // represented as an integer denominator (1/x)%
        uint8 feeProtocol;
        // whether the pool is locked
        bool unlocked;
    }

    /// @dev event on staking
    /// @param to the sender
    /// @param poolAddress the pool address of uniswapV3
    /// @param tokenId the uniswapV3 Lp token
    /// @param amount the amount of staking
    event Staked(
        address indexed to,
        address indexed poolAddress,
        uint256 tokenId,
        uint256 amount
    );

    /// @dev event on claim
    /// @param to the sender
    /// @param poolAddress the pool address of uniswapV3
    /// @param tokenId the uniswapV3 Lp token
    /// @param miningAmount the amount of mining
    /// @param nonMiningAmount the amount of non-mining
    event Claimed(
        address indexed to,
        address poolAddress,
        uint256 tokenId,
        uint256 miningAmount,
        uint256 nonMiningAmount
    );

    /// @dev event on withdrawal
    /// @param to the sender
    /// @param tokenId the uniswapV3 Lp token
    /// @param miningAmount the amount of mining
    /// @param nonMiningAmount the amount of non-mining
    event WithdrawalToken(
        address indexed to,
        uint256 tokenId,
        uint256 miningAmount,
        uint256 nonMiningAmount
    );

    /// @dev event on mining in coinage
    /// @param curTime the current time
    /// @param miningInterval mining period (sec)
    /// @param miningAmount the mining amount
    /// @param prevTotalSupply Total amount of coinage before mining
    /// @param afterTotalSupply Total amount of coinage after being mined
    /// @param factor coinage's Factor
    event MinedCoinage(
        uint256 curTime,
        uint256 miningInterval,
        uint256 miningAmount,
        uint256 prevTotalSupply,
        uint256 afterTotalSupply,
        uint256 factor
    );

    /// @dev event on burning in coinage
    /// @param curTime the current time
    /// @param tokenId the token id
    /// @param burningAmount the buring amount
    /// @param prevTotalSupply Total amount of coinage before mining
    /// @param afterTotalSupply Total amount of coinage after being mined
    event BurnedCoinage(
        uint256 curTime,
        uint256 tokenId,
        uint256 burningAmount,
        uint256 prevTotalSupply,
        uint256 afterTotalSupply
    );

    /// @dev constructor of StakeCoinage
    constructor() {
        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, msg.sender);

        miningIntervalSeconds = 15;
    }

    /// @dev receive ether - revert
    receive() external payable {
        revert();
    }

    /// @dev Mining interval setting (seconds)
    /// @param _intervalSeconds the mining interval (sec)
    function setMiningIntervalSeconds(uint256 _intervalSeconds)
        external
        onlyOwner
    {
        miningIntervalSeconds = _intervalSeconds;
    }

    /// @dev reset coinage's last mining time variable for tes
    function resetCoinageTime() external onlyOwner {
        coinageLastMintBlockTimetamp = 0;
    }

    /// @dev set sale start time
    /// @param _saleStartTime sale start time
    function setSaleStartTime(uint256 _saleStartTime) external onlyOwner {
        require(
            _saleStartTime > 0 && saleStartTime != _saleStartTime,
            "StakeUniswapV3: zero or same _saleStartTime"
        );
        saleStartTime = _saleStartTime;
    }

    /// @dev calculate the factor of coinage
    /// @param source tsource
    /// @param target target
    /// @param oldFactor oldFactor
    function _calcNewFactor(
        uint256 source,
        uint256 target,
        uint256 oldFactor
    ) internal pure returns (uint256) {
        return rdiv(rmul(target, oldFactor), source);
    }

    /// @dev delete user's token storage of index place
    /// @param _owner tokenId's owner
    /// @param tokenId tokenId
    /// @param _index owner's tokenId's index
    function deleteUserToken(
        address _owner,
        uint256 tokenId,
        uint256 _index
    ) internal {
        uint256 _tokenid = userStakedTokenIds[_owner][_index];
        require(_tokenid == tokenId, "StakeUniswapV3: mismatch token");
        uint256 lastIndex = (userStakedTokenIds[_owner].length).sub(1);
        if (tokenId > 0 && _tokenid == tokenId) {
            if (_index < lastIndex) {
                uint256 tokenId_lastIndex =
                    userStakedTokenIds[_owner][lastIndex];
                userStakedTokenIds[_owner][_index] = tokenId_lastIndex;
                depositTokens[tokenId_lastIndex].idIndex = _index;
            }
            userStakedTokenIds[_owner].pop();
        }
    }

    /// @dev mining on coinage, Mining conditions :  the sale start time must pass,
    /// the stake start time must pass, the vault mining start time (sale start time) passes,
    /// the mining interval passes, and the current total amount is not zero,
    function miningCoinage() public lock {
        if (saleStartTime == 0 || saleStartTime > block.timestamp) return;
        if (stakeStartTime == 0 || stakeStartTime > block.timestamp) return;
        if (
            IIStake2Vault(vault).miningStartTime() > block.timestamp ||
            IIStake2Vault(vault).miningEndTime() < block.timestamp
        ) return;

        if (coinageLastMintBlockTimetamp == 0)
            coinageLastMintBlockTimetamp = stakeStartTime;

        if (
            block.timestamp >
            (coinageLastMintBlockTimetamp.add(miningIntervalSeconds))
        ) {
            uint256 miningInterval =
                block.timestamp.sub(coinageLastMintBlockTimetamp);
            uint256 miningAmount =
                miningInterval.mul(IIStake2Vault(vault).miningPerSecond());
            uint256 prevTotalSupply =
                IAutoRefactorCoinageWithTokenId(coinage).totalSupply();

            if (miningAmount > 0 && prevTotalSupply > 0) {
                uint256 afterTotalSupply =
                    prevTotalSupply.add(miningAmount.mul(10**9));
                uint256 factor =
                    IAutoRefactorCoinageWithTokenId(coinage).setFactor(
                        _calcNewFactor(
                            prevTotalSupply,
                            afterTotalSupply,
                            IAutoRefactorCoinageWithTokenId(coinage).factor()
                        )
                    );
                coinageLastMintBlockTimetamp = block.timestamp;

                emit MinedCoinage(
                    block.timestamp,
                    miningInterval,
                    miningAmount,
                    prevTotalSupply,
                    afterTotalSupply,
                    factor
                );
            }
        }
    }

    /// @dev view mining information of tokenId
    /// @param tokenId  tokenId
    function getMiningTokenId(uint256 tokenId)
        public
        view
        override
        nonZeroAddress(poolAddress)
        returns (
            uint256 miningAmount,
            uint256 nonMiningAmount,
            uint256 minableAmount,
            uint160 secondsInside,
            uint256 secondsInsideDiff256,
            uint256 liquidity,
            uint256 balanceOfTokenIdRay,
            uint256 minableAmountRay,
            uint256 secondsInside256,
            uint256 secondsAbsolute256
        )
    {
        if (
            stakeStartTime < block.timestamp && stakeStartTime < block.timestamp
        ) {
            LibUniswapV3Stake.StakeLiquidity storage _depositTokens =
                depositTokens[tokenId];
            liquidity = _depositTokens.liquidity;

            uint32 secondsAbsolute = 0;
            balanceOfTokenIdRay = IAutoRefactorCoinageWithTokenId(coinage)
                .balanceOf(tokenId);

            if (_depositTokens.liquidity > 0 && balanceOfTokenIdRay > 0) {
                if (balanceOfTokenIdRay > liquidity.mul(10**9)) {
                    minableAmountRay = balanceOfTokenIdRay.sub(
                        liquidity.mul(10**9)
                    );
                    minableAmount = minableAmountRay.div(10**9);
                }
                if (minableAmount > 0) {
                    (, , secondsInside) = IUniswapV3Pool(poolAddress)
                        .snapshotCumulativesInside(
                        _depositTokens.tickLower,
                        _depositTokens.tickUpper
                    );
                    secondsInside256 = uint256(secondsInside);

                    if (_depositTokens.claimedTime > 0)
                        secondsAbsolute = uint32(block.timestamp).sub(
                            _depositTokens.claimedTime
                        );
                    else
                        secondsAbsolute = uint32(block.timestamp).sub(
                            _depositTokens.startTime
                        );
                    secondsAbsolute256 = uint256(secondsAbsolute);

                    if (secondsAbsolute > 0) {
                        if (_depositTokens.secondsInsideLast > 0) {
                            secondsInsideDiff256 = secondsInside256.sub(
                                uint256(_depositTokens.secondsInsideLast)
                            );
                        } else {
                            secondsInsideDiff256 = secondsInside256.sub(
                                uint256(_depositTokens.secondsInsideInitial)
                            );
                        }

                        if (
                            secondsInsideDiff256 < secondsAbsolute256 &&
                            secondsInsideDiff256 > 0
                        ) {
                            miningAmount = minableAmount
                                .mul(secondsInsideDiff256)
                                .div(secondsAbsolute256);
                            nonMiningAmount = minableAmount.sub(miningAmount);
                        } else if(secondsInsideDiff256 > 0){
                            miningAmount = minableAmount;
                        } else {
                            nonMiningAmount = minableAmount;
                        }
                    }
                }
            }
        }
    }

    /// @dev With the given tokenId, information is retrieved from nonfungiblePositionManager,
    ///      and the pool address is calculated and set.
    /// @param tokenId  tokenId
    function setPoolAddress(uint256 tokenId)
        external
        onlyOwner
        nonZeroAddress(token)
        nonZeroAddress(vault)
        nonZeroAddress(stakeRegistry)
        nonZeroAddress(poolToken0)
        nonZeroAddress(poolToken1)
        nonZeroAddress(address(nonfungiblePositionManager))
        nonZeroAddress(uniswapV3FactoryAddress)
    {
        require(poolAddress == address(0), "StakeUniswapV3: already set");
        (, , address token0, address token1, uint24 fee, , , , , , , ) =
            nonfungiblePositionManager.positions(tokenId);

        require(
            (token0 == poolToken0 && token1 == poolToken1) ||
                (token0 == poolToken1 && token1 == poolToken0),
            "StakeUniswapV3: different token"
        );
        poolToken0 = token0;
        poolToken1 = token1;

        poolAddress = PoolAddress.computeAddress(
            uniswapV3FactoryAddress,
            PoolAddress.PoolKey({token0: token0, token1: token1, fee: fee})
        );
        poolFee = fee;
    }

    /// @dev stake tokenId of UniswapV3
    /// @param tokenId  tokenId
    /// @param deadline the deadline that valid the owner's signature
    /// @param v the owner's signature - v
    /// @param r the owner's signature - r
    /// @param s the owner's signature - s
    function stakePermit(
        uint256 tokenId,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    )
        external
        override
        nonZeroAddress(token)
        nonZeroAddress(vault)
        nonZeroAddress(stakeRegistry)
        nonZeroAddress(poolToken0)
        nonZeroAddress(poolToken1)
        nonZeroAddress(address(nonfungiblePositionManager))
        nonZeroAddress(uniswapV3FactoryAddress)
    {
        require(
            saleStartTime < block.timestamp,
            "StakeUniswapV3: before start"
        );

        require(
            block.timestamp < IIStake2Vault(vault).miningEndTime(),
            "StakeUniswapV3: end mining"
        );

        require(
            nonfungiblePositionManager.ownerOf(tokenId) == msg.sender,
            "StakeUniswapV3: not owner"
        );

        nonfungiblePositionManager.permit(
            address(this),
            tokenId,
            deadline,
            v,
            r,
            s
        );

        _stake(tokenId);
    }

    /// @dev stake tokenId of UniswapV3
    /// @param tokenId  tokenId
    function stake(uint256 tokenId)
        external
        override
        nonZeroAddress(token)
        nonZeroAddress(vault)
        nonZeroAddress(stakeRegistry)
        nonZeroAddress(poolToken0)
        nonZeroAddress(poolToken1)
        nonZeroAddress(address(nonfungiblePositionManager))
        nonZeroAddress(uniswapV3FactoryAddress)
    {
        require(
            saleStartTime < block.timestamp,
            "StakeUniswapV3: before start"
        );
        require(
            block.timestamp < IIStake2Vault(vault).miningEndTime(),
            "StakeUniswapV3: end mining"
        );
        require(
            nonfungiblePositionManager.ownerOf(tokenId) == msg.sender,
            "StakeUniswapV3: not owner"
        );

        _stake(tokenId);
    }

    /// @dev stake tokenId of UniswapV3
    /// @param tokenId  tokenId
    function _stake(uint256 tokenId) internal {
        LibUniswapV3Stake.StakeLiquidity storage _depositTokens =
            depositTokens[tokenId];

        require(
            _depositTokens.owner == address(0),
            "StakeUniswapV3: Already staked"
        );

        uint256 _tokenId = tokenId;
        (
            ,
            ,
            address token0,
            address token1,
            uint24 fee,
            int24 tickLower,
            int24 tickUpper,
            uint128 liquidity,
            ,
            ,
            ,

        ) = nonfungiblePositionManager.positions(_tokenId);

        require(
            (token0 == poolToken0 && token1 == poolToken1) ||
                (token0 == poolToken1 && token1 == poolToken0),
            "StakeUniswapV3: different token"
        );

        require(liquidity > 0, "StakeUniswapV3: zero liquidity");

        if (poolAddress == address(0)) {
            poolAddress = PoolAddress.computeAddress(
                uniswapV3FactoryAddress,
                PoolAddress.PoolKey({token0: token0, token1: token1, fee: fee})
            );
        }

        require(poolAddress != address(0), "StakeUniswapV3: zero poolAddress");

        (, int24 tick, , , , , bool unlocked) =
            IUniswapV3Pool(poolAddress).slot0();
        require(unlocked, "StakeUniswapV3: unlocked pool");
        require(
            tickLower < tick && tick < tickUpper,
            "StakeUniswapV3: out of tick range"
        );

        (, , uint32 secondsInside) =
            IUniswapV3Pool(poolAddress).snapshotCumulativesInside(
                tickLower,
                tickUpper
            );

        uint256 tokenId_ = _tokenId;

        // initial start time
        if (stakeStartTime == 0) stakeStartTime = block.timestamp;

        _depositTokens.owner = msg.sender;
        _depositTokens.idIndex = userStakedTokenIds[msg.sender].length;
        _depositTokens.liquidity = liquidity;
        _depositTokens.tickLower = tickLower;
        _depositTokens.tickUpper = tickUpper;
        _depositTokens.startTime = uint32(block.timestamp);
        _depositTokens.claimedTime = 0;
        _depositTokens.secondsInsideInitial = secondsInside;
        _depositTokens.secondsInsideLast = 0;

        nonfungiblePositionManager.transferFrom(
            msg.sender,
            address(this),
            tokenId_
        );

        // save tokenid
        userStakedTokenIds[msg.sender].push(tokenId_);

        totalStakedAmount = totalStakedAmount.add(liquidity);
        totalTokens = totalTokens.add(1);

        LibUniswapV3Stake.StakedTotalTokenAmount storage _userTotalStaked =
            userTotalStaked[msg.sender];
        if (!_userTotalStaked.staked) totalStakers = totalStakers.add(1);
        _userTotalStaked.staked = true;
        _userTotalStaked.totalDepositAmount = _userTotalStaked
            .totalDepositAmount
            .add(liquidity);

        LibUniswapV3Stake.StakedTokenAmount storage _stakedCoinageTokens =
            stakedCoinageTokens[tokenId_];
        _stakedCoinageTokens.amount = liquidity;
        _stakedCoinageTokens.startTime = uint32(block.timestamp);

        //mint coinage of user amount
        IAutoRefactorCoinageWithTokenId(coinage).mint(
            msg.sender,
            tokenId_,
            uint256(liquidity).mul(10**9)
        );

        miningCoinage();

        emit Staked(msg.sender, poolAddress, tokenId_, liquidity);
    }

    /// @dev The amount mined with the deposited liquidity is claimed and taken.
    ///      The amount of mining taken is changed in proportion to the amount of time liquidity
    ///       has been provided since recent mining
    /// @param tokenId  tokenId
    function claim(uint256 tokenId) external override {
        LibUniswapV3Stake.StakeLiquidity storage _depositTokens =
            depositTokens[tokenId];

        require(
            _depositTokens.owner == msg.sender,
            "StakeUniswapV3: not staker"
        );

        require(
            _depositTokens.claimedTime <
                uint32(block.timestamp.sub(miningIntervalSeconds)),
            "StakeUniswapV3: already claimed"
        );

        require(_depositTokens.claimLock == false, "StakeUniswapV3: claiming");
        _depositTokens.claimLock = true;

        miningCoinage();

        (
            uint256 miningAmount,
            uint256 nonMiningAmount,
            uint256 minableAmount,
            uint160 secondsInside,
            ,
            ,
            ,
            uint256 minableAmountRay,
            ,

        ) = getMiningTokenId(tokenId);

        require(miningAmount > 0, "StakeUniswapV3: zero miningAmount");

        _depositTokens.claimedTime = uint32(block.timestamp);
        _depositTokens.secondsInsideLast = secondsInside;

        IAutoRefactorCoinageWithTokenId(coinage).burn(
            msg.sender,
            tokenId,
            minableAmountRay
        );

        // storage  stakedCoinageTokens
        LibUniswapV3Stake.StakedTokenAmount storage _stakedCoinageTokens =
            stakedCoinageTokens[tokenId];
        _stakedCoinageTokens.claimedTime = uint32(block.timestamp);
        _stakedCoinageTokens.claimedAmount = _stakedCoinageTokens
            .claimedAmount
            .add(miningAmount);
        _stakedCoinageTokens.nonMiningAmount = _stakedCoinageTokens
            .nonMiningAmount
            .add(nonMiningAmount);

        // storage  StakedTotalTokenAmount
        LibUniswapV3Stake.StakedTotalTokenAmount storage _userTotalStaked =
            userTotalStaked[msg.sender];
        _userTotalStaked.totalMiningAmount = _userTotalStaked
            .totalMiningAmount
            .add(miningAmount);
        _userTotalStaked.totalNonMiningAmount = _userTotalStaked
            .totalNonMiningAmount
            .add(nonMiningAmount);

        // total
        miningAmountTotal = miningAmountTotal.add(miningAmount);
        nonMiningAmountTotal = nonMiningAmountTotal.add(nonMiningAmount);

        require(
            IIStake2Vault(vault).claimMining(
                msg.sender,
                minableAmount,
                miningAmount,
                nonMiningAmount
            )
        );

        _depositTokens.claimLock = false;
        emit Claimed(
            msg.sender,
            poolAddress,
            tokenId,
            miningAmount,
            nonMiningAmount
        );
    }

    /// @dev withdraw the deposited token.
    ///      The amount mined with the deposited liquidity is claimed and taken.
    ///      The amount of mining taken is changed in proportion to the amount of time liquidity
    ///      has been provided since recent mining
    /// @param tokenId  tokenId
    function withdraw(uint256 tokenId) external override {
        LibUniswapV3Stake.StakeLiquidity storage _depositTokens =
            depositTokens[tokenId];
        require(
            _depositTokens.owner == msg.sender,
            "StakeUniswapV3: not staker"
        );

        require(
            _depositTokens.withdraw == false,
            "StakeUniswapV3: withdrawing"
        );
        _depositTokens.withdraw = true;

        miningCoinage();

        if (totalStakedAmount >= _depositTokens.liquidity)
            totalStakedAmount = totalStakedAmount.sub(_depositTokens.liquidity);

        if (totalTokens > 0) totalTokens = totalTokens.sub(1);

        (
            uint256 miningAmount,
            uint256 nonMiningAmount,
            uint256 minableAmount,
            ,
            ,
            ,
            ,
            ,
            ,

        ) = getMiningTokenId(tokenId);

        IAutoRefactorCoinageWithTokenId(coinage).burnTokenId(
            msg.sender,
            tokenId
        );

        // storage  StakedTotalTokenAmount
        LibUniswapV3Stake.StakedTotalTokenAmount storage _userTotalStaked =
            userTotalStaked[msg.sender];
        _userTotalStaked.totalDepositAmount = _userTotalStaked
            .totalDepositAmount
            .sub(_depositTokens.liquidity);
        _userTotalStaked.totalMiningAmount = _userTotalStaked
            .totalMiningAmount
            .add(miningAmount);
        _userTotalStaked.totalNonMiningAmount = _userTotalStaked
            .totalNonMiningAmount
            .add(nonMiningAmount);

        // total
        miningAmountTotal = miningAmountTotal.add(miningAmount);
        nonMiningAmountTotal = nonMiningAmountTotal.add(nonMiningAmount);

        deleteUserToken(_depositTokens.owner, tokenId, _depositTokens.idIndex);

        delete depositTokens[tokenId];
        delete stakedCoinageTokens[tokenId];

        if (_userTotalStaked.totalDepositAmount == 0) {
            totalStakers = totalStakers.sub(1);
            delete userTotalStaked[msg.sender];
        }

        if (minableAmount > 0)
            require(
                IIStake2Vault(vault).claimMining(
                    msg.sender,
                    minableAmount,
                    miningAmount,
                    nonMiningAmount
                )
            );

        nonfungiblePositionManager.safeTransferFrom(
            address(this),
            msg.sender,
            tokenId
        );

        emit WithdrawalToken(
            msg.sender,
            tokenId,
            miningAmount,
            nonMiningAmount
        );
    }

    /// @dev Get the list of staked tokens of the user
    /// @param user  user address
    function getUserStakedTokenIds(address user)
        external
        view
        override
        returns (uint256[] memory ids)
    {
        return userStakedTokenIds[user];
    }

    /// @dev tokenId's deposited information
    /// @param tokenId   tokenId
    /// @return _poolAddress   poolAddress
    /// @return tick tick,
    /// @return liquidity liquidity,
    /// @return args liquidity,  startTime, claimedTime, startBlock, claimedBlock, claimedAmount
    /// @return secondsPL secondsPerLiquidityInsideInitialX128, secondsPerLiquidityInsideX128Las
    function getDepositToken(uint256 tokenId)
        external
        view
        override
        returns (
            address _poolAddress,
            int24[2] memory tick,
            uint128 liquidity,
            uint256[5] memory args,
            uint160[2] memory secondsPL
        )
    {
        LibUniswapV3Stake.StakeLiquidity memory _depositTokens =
            depositTokens[tokenId];
        LibUniswapV3Stake.StakedTokenAmount memory _stakedCoinageTokens =
            stakedCoinageTokens[tokenId];

        return (
            poolAddress,
            [_depositTokens.tickLower, _depositTokens.tickUpper],
            _depositTokens.liquidity,
            [
                _depositTokens.startTime,
                _depositTokens.claimedTime,
                _stakedCoinageTokens.startTime,
                _stakedCoinageTokens.claimedTime,
                _stakedCoinageTokens.claimedAmount
            ],
            [
                _depositTokens.secondsInsideInitial,
                _depositTokens.secondsInsideLast
            ]
        );
    }

    /// @dev user's staked total infos
    /// @param user  user address
    /// @return totalDepositAmount  total deposited amount
    /// @return totalMiningAmount total mining amount ,
    /// @return totalNonMiningAmount total non-mining amount,
    function getUserStakedTotal(address user)
        external
        view
        override
        returns (
            uint256 totalDepositAmount,
            uint256 totalMiningAmount,
            uint256 totalNonMiningAmount
        )
    {
        return (
            userTotalStaked[user].totalDepositAmount,
            userTotalStaked[user].totalMiningAmount,
            userTotalStaked[user].totalNonMiningAmount
        );
    }

    /// @dev totalSupply of coinage
    function totalSupplyCoinage() external view returns (uint256) {
        return IAutoRefactorCoinageWithTokenId(coinage).totalSupply();
    }

    /// @dev balanceOf of tokenId's coinage
    function balanceOfCoinage(uint256 tokenId) external view returns (uint256) {
        return IAutoRefactorCoinageWithTokenId(coinage).balanceOf(tokenId);
    }

    /// @dev Give the infomation of this stakeContracts
    /// @return return1  [token, vault, stakeRegistry, coinage]
    /// @return return2  [poolToken0, poolToken1, nonfungiblePositionManager, uniswapV3FactoryAddress]
    /// @return return3  [totalStakers, totalStakedAmount, miningAmountTotal,nonMiningAmountTotal]
    function infos()
        external
        view
        override
        returns (
            address[4] memory,
            address[4] memory,
            uint256[4] memory
        )
    {
        return (
            [token, vault, stakeRegistry, coinage],
            [
                poolToken0,
                poolToken1,
                address(nonfungiblePositionManager),
                uniswapV3FactoryAddress
            ],
            [
                totalStakers,
                totalStakedAmount,
                miningAmountTotal,
                nonMiningAmountTotal
            ]
        );
    }

    /*
    /// @dev pool's infos
    /// @return factory  pool's factory address
    /// @return token0  token0 address
    /// @return token1  token1 address
    /// @return fee  fee
    /// @return tickSpacing  tickSpacing
    /// @return maxLiquidityPerTick  maxLiquidityPerTick
    /// @return liquidity  pool's liquidity
    function poolInfos()
        external
        view
        override
        nonZeroAddress(poolAddress)
        returns (
            address factory,
            address token0,
            address token1,
            uint24 fee,
            int24 tickSpacing,
            uint128 maxLiquidityPerTick,
            uint128 liquidity
        )
    {
        liquidity = IUniswapV3Pool(poolAddress).liquidity();
        factory = IUniswapV3Pool(poolAddress).factory();
        token0 = IUniswapV3Pool(poolAddress).token0();
        token1 = IUniswapV3Pool(poolAddress).token1();
        fee = IUniswapV3Pool(poolAddress).fee();
        tickSpacing = IUniswapV3Pool(poolAddress).tickSpacing();
        maxLiquidityPerTick = IUniswapV3Pool(poolAddress).maxLiquidityPerTick();
    }
    */
    /*
    /// @dev key's info
    /// @param key hash(owner, tickLower, tickUpper)
    /// @return _liquidity  key's liquidity
    /// @return feeGrowthInside0LastX128  key's feeGrowthInside0LastX128
    /// @return feeGrowthInside1LastX128  key's feeGrowthInside1LastX128
    /// @return tokensOwed0  key's tokensOwed0
    /// @return tokensOwed1  key's tokensOwed1
    function poolPositions(bytes32 key)
        external
        view
        override
        nonZeroAddress(poolAddress)
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        )
    {
        (
            _liquidity,
            feeGrowthInside0LastX128,
            feeGrowthInside1LastX128,
            tokensOwed0,
            tokensOwed1
        ) = IUniswapV3Pool(poolAddress).positions(key);
    }
    */

    /// @dev pool's slot0 (current position)
    /// @return sqrtPriceX96  The current price of the pool as a sqrt(token1/token0) Q64.96 value
    /// @return tick  The current tick of the pool
    /// @return observationIndex  The index of the last oracle observation that was written,
    /// @return observationCardinality  The current maximum number of observations stored in the pool,
    /// @return observationCardinalityNext  The next maximum number of observations, to be updated when the observation.
    /// @return feeProtocol  The protocol fee for both tokens of the pool
    /// @return unlocked  Whether the pool is currently locked to reentrancy
    function poolSlot0()
        external
        view
        override
        nonZeroAddress(poolAddress)
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        )
    {
        (
            sqrtPriceX96,
            tick,
            observationIndex,
            observationCardinality,
            observationCardinalityNext,
            feeProtocol,
            unlocked
        ) = IUniswapV3Pool(poolAddress).slot0();
    }

    /*
    /// @dev _tokenId's position
    /// @param _tokenId  tokenId
    /// @return nonce  the nonce for permits
    /// @return operator  the address that is approved for spending this token
    /// @return token0  The address of the token0 for pool
    /// @return token1  The address of the token1 for pool
    /// @return fee  The fee associated with the pool
    /// @return tickLower  The lower end of the tick range for the position
    /// @return tickUpper  The higher end of the tick range for the position
    /// @return liquidity  The liquidity of the position
    /// @return feeGrowthInside0LastX128  The fee growth of token0 as of the last action on the individual position
    /// @return feeGrowthInside1LastX128  The fee growth of token1 as of the last action on the individual position
    /// @return tokensOwed0  The uncollected amount of token0 owed to the position as of the last computation
    /// @return tokensOwed1  The uncollected amount of token1 owed to the position as of the last computation
    function npmPositions(uint256 _tokenId)
        external
        view
        override
        nonZeroAddress(address(nonfungiblePositionManager))
        returns (
            uint96 nonce,
            address operator,
            address token0,
            address token1,
            uint24 fee,
            int24 tickLower,
            int24 tickUpper,
            uint128 liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        )
    {
        return nonfungiblePositionManager.positions(_tokenId);
    }
    */
    /*
    /// @dev snapshotCumulativesInside
    /// @param tickLower  The lower tick of the range
    /// @param tickUpper  The upper tick of the range
    /// @return tickCumulativeInside  The snapshot of the tick accumulator for the range
    /// @return secondsPerLiquidityInsideX128  The snapshot of seconds per liquidity for the range
    /// @return secondsInside  The snapshot of seconds per liquidity for the range
    /// @return curTimestamps  current Timestamps
    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)
        external
        view
        override
        nonZeroAddress(poolAddress)
        returns (
            int56 tickCumulativeInside,
            uint160 secondsPerLiquidityInsideX128,
            uint32 secondsInside,
            uint32 curTimestamps
        )
    {
        tickCumulativeInside;
        secondsPerLiquidityInsideX128;
        secondsInside;
        curTimestamps = uint32(block.timestamp);

        (
            tickCumulativeInside,
            secondsPerLiquidityInsideX128,
            secondsInside
        ) = IUniswapV3Pool(poolAddress).snapshotCumulativesInside(
            tickLower,
            tickUpper
        );
    }
    */
    /// @dev mining end time
    /// @return endTime mining end time
    function miningEndTime()
        external
        view
        override
        nonZeroAddress(vault)
        returns (uint256)
    {
        return IIStake2Vault(vault).miningEndTime();
    }

    /// @dev get price
    /// @param decimals pool's token1's decimals (ex. 1e18)
    /// @return price price
    function getPrice(uint256 decimals)
        external
        view
        override
        nonZeroAddress(poolAddress)
        returns (uint256 price)
    {
        (uint160 sqrtPriceX96, , , , , , ) =
            IUniswapV3Pool(poolAddress).slot0();

        return
            uint256(sqrtPriceX96).mul(uint256(sqrtPriceX96)).mul(decimals) >>
            (96 * 2);
    }

    /// @dev Liquidity provision time (seconds) at a specific point in time since the token was recently mined
    /// @param tokenId token id
    /// @param expectBlocktimestamp The specific time you want to know (It must be greater than the last mining time.) set it to the current time.
    /// @return secondsAbsolute Absolute duration (in seconds) from the latest mining to the time of expectTime
    /// @return secondsInsideDiff256 The time (in seconds) that the token ID provided liquidity from the last claim (or staking time) to the present time.
    /// @return expectTime time used in the calculation
    function currentliquidityTokenId(
        uint256 tokenId,
        uint256 expectBlocktimestamp
    )
        public
        view
        override
        nonZeroAddress(poolAddress)
        returns (
            uint256 secondsAbsolute,
            uint256 secondsInsideDiff256,
            uint256 expectTime
        )
    {
        secondsAbsolute = 0;
        secondsInsideDiff256 = 0;
        expectTime = 0;

        if (
            stakeStartTime > 0 &&
            expectBlocktimestamp > coinageLastMintBlockTimetamp
        ) {
            expectTime = expectBlocktimestamp;

            LibUniswapV3Stake.StakeLiquidity storage _depositTokens =
                depositTokens[tokenId];
            (, , uint160 secondsInside) =
                IUniswapV3Pool(poolAddress).snapshotCumulativesInside(
                    _depositTokens.tickLower,
                    _depositTokens.tickUpper
                );

            if (
                expectTime > _depositTokens.claimedTime &&
                expectTime > _depositTokens.startTime
            ) {
                if (_depositTokens.claimedTime > 0) {
                    secondsAbsolute = expectTime.sub(
                        (uint256)(_depositTokens.claimedTime)
                    );
                } else {
                    secondsAbsolute = expectTime.sub(
                        (uint256)(_depositTokens.startTime)
                    );
                }

                if (secondsAbsolute > 0) {
                    if (_depositTokens.secondsInsideLast > 0) {
                        secondsInsideDiff256 = uint256(secondsInside).sub(
                            uint256(_depositTokens.secondsInsideLast)
                        );
                    } else {
                        secondsInsideDiff256 = uint256(secondsInside).sub(
                            uint256(_depositTokens.secondsInsideInitial)
                        );
                    }
                }
            }
        }
    }

    /// @dev Coinage balance information that tokens can receive in the future
    /// @param tokenId token id
    /// @param expectBlocktimestamp The specific time you want to know (It must be greater than the last mining time.)
    /// @return currentTotalCoinage Current Coinage Total Balance
    /// @return afterTotalCoinage Total balance of Coinage at a future point in time
    /// @return afterBalanceTokenId The total balance of the coin age of the token at a future time
    /// @return expectTime future time
    /// @return addIntervalTime Duration (in seconds) between the future time and the recent mining time
    function currentCoinageBalanceTokenId(
        uint256 tokenId,
        uint256 expectBlocktimestamp
    )
        public
        view
        override
        nonZeroAddress(poolAddress)
        returns (
            uint256 currentTotalCoinage,
            uint256 afterTotalCoinage,
            uint256 afterBalanceTokenId,
            uint256 expectTime,
            uint256 addIntervalTime
        )
    {
        currentTotalCoinage = 0;
        afterTotalCoinage = 0;
        afterBalanceTokenId = 0;
        expectTime = 0;
        addIntervalTime = 0;

        if (
            stakeStartTime > 0 &&
            expectBlocktimestamp > coinageLastMintBlockTimetamp
        ) {
            expectTime = expectBlocktimestamp;

            uint256 miningEndTime_ = IIStake2Vault(vault).miningEndTime();
            if (expectTime > miningEndTime_) expectTime = miningEndTime_;

            currentTotalCoinage = IAutoRefactorCoinageWithTokenId(coinage)
                .totalSupply();
            (uint256 balance, uint256 refactoredCount, uint256 remain) =
                IAutoRefactorCoinageWithTokenId(coinage).balancesTokenId(
                    tokenId
                );

            uint256 coinageLastMintTime = coinageLastMintBlockTimetamp;
            if (coinageLastMintTime == 0) coinageLastMintTime = stakeStartTime;

            addIntervalTime = expectTime.sub(coinageLastMintTime);
            if (
                miningIntervalSeconds > 0 &&
                addIntervalTime > miningIntervalSeconds
            ) addIntervalTime = addIntervalTime.sub(miningIntervalSeconds);

            if (addIntervalTime > 0) {
                uint256 miningPerSecond_ =
                    IIStake2Vault(vault).miningPerSecond();
                uint256 addAmountCoinage =
                    addIntervalTime.mul(miningPerSecond_);
                afterTotalCoinage = currentTotalCoinage.add(
                    addAmountCoinage.mul(10**9)
                );
                uint256 factor_ =
                    IAutoRefactorCoinageWithTokenId(coinage).factor();
                uint256 infactor =
                    _calcNewFactor(
                        currentTotalCoinage,
                        afterTotalCoinage,
                        factor_
                    );

                uint256 count = 0;
                uint256 f = infactor;
                for (; f >= 10**28; f = f.div(2)) {
                    count = count.add(1);
                }
                uint256 afterBalanceTokenId_ =
                    applyCoinageFactor(balance, refactoredCount, f, count);

                afterBalanceTokenId = afterBalanceTokenId_.add(remain);
            }
        }
    }

    /// @dev Estimated additional claimable amount on a specific time
    /// @param tokenId token id
    /// @param expectBlocktimestamp The specific time you want to know (It must be greater than the last mining time.)
    /// @return miningAmount Amount you can claim
    /// @return nonMiningAmount The amount that burn without receiving a claim
    /// @return minableAmount Total amount of mining allocated at the time of claim
    /// @return minableAmountRay Total amount of mining allocated at the time of claim (ray unit)
    /// @return expectTime time used in the calculation
    function expectedPlusClaimableAmount(
        uint256 tokenId,
        uint256 expectBlocktimestamp
    )
        external
        view
        override
        nonZeroAddress(poolAddress)
        returns (
            uint256 miningAmount,
            uint256 nonMiningAmount,
            uint256 minableAmount,
            uint256 minableAmountRay,
            uint256 expectTime
        )
    {
        miningAmount = 0;
        nonMiningAmount = 0;
        minableAmount = 0;
        minableAmountRay = 0;
        expectTime = 0;

        if (
            stakeStartTime > 0 &&
            expectBlocktimestamp > coinageLastMintBlockTimetamp
        ) {
            expectTime = expectBlocktimestamp;
            uint256 afterBalanceTokenId = 0;
            uint256 secondsAbsolute = 0;
            uint256 secondsInsideDiff256 = 0;

            uint256 currentBalanceOfTokenId =
                IAutoRefactorCoinageWithTokenId(coinage).balanceOf(tokenId);

            (secondsAbsolute, secondsInsideDiff256, ) = currentliquidityTokenId(
                tokenId,
                expectTime
            );

            (, , afterBalanceTokenId, , ) = currentCoinageBalanceTokenId(
                tokenId,
                expectTime
            );

            if (
                currentBalanceOfTokenId > 0 &&
                afterBalanceTokenId > currentBalanceOfTokenId
            ) {
                minableAmountRay = afterBalanceTokenId.sub(
                    currentBalanceOfTokenId
                );
                minableAmount = minableAmountRay.div(10**9);
            }
            if (minableAmount > 0 && secondsAbsolute > 0 && secondsInsideDiff256 > 0 ) {
                if (
                    secondsInsideDiff256 < secondsAbsolute &&
                    secondsInsideDiff256 > 0
                ) {
                    miningAmount = minableAmount.mul(secondsInsideDiff256).div(
                        secondsAbsolute
                    );
                    nonMiningAmount = minableAmount.sub(miningAmount);
                } else {
                    miningAmount = minableAmount;
                }
            } else if(secondsInsideDiff256 == 0){
                nonMiningAmount = minableAmount;
            }
        }
    }

    function applyCoinageFactor(
        uint256 v,
        uint256 refactoredCount,
        uint256 _factor,
        uint256 refactorCount
    ) internal pure returns (uint256) {
        if (v == 0) {
            return 0;
        }

        v = rmul2(v, _factor);

        for (uint256 i = refactoredCount; i < refactorCount; i++) {
            v = v * (2);
        }

        return v;
    }
}


// File contracts/interfaces/IStakeUniswapV3Proxy2.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStakeUniswapV3Proxy2 {

    /// @dev view implementation address of the proxy[index]
    /// @param _index index of proxy
    /// @return address of the implementation
    function implementation2(uint256 _index) external view returns (address);

    /// @dev set the implementation address and status of the proxy[index]
    /// @param newImplementation Address of the new implementation.
    /// @param _index index of proxy
    /// @param _alive alive status
    function setImplementation2(
        address newImplementation,
        uint256 _index,
        bool _alive
    ) external;

    /// @dev set alive status of implementation
    /// @param newImplementation Address of the new implementation.
    /// @param _alive alive status
    function setAliveImplementation2(address newImplementation, bool _alive)
        external;

    /// @dev set selectors of Implementation
    /// @param _selectors being added selectors
    /// @param _imp implementation address
    function setSelectorImplementations2(
        bytes4[] calldata _selectors,
        address _imp
    ) external;

    /// @dev set the implementation address and status of the proxy[index]
    /// @param _selector the selector of function
    function getSelectorImplementation2(bytes4 _selector)
        external
        view
        returns (address impl);
}


// File contracts/stake/StakeUniswapV3Proxy2.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;






/// @title Proxy for stake based coinage contract
contract StakeUniswapV3Proxy2 is
    StakeUniswapV3Storage,
    AccessibleCommon,
    ProxyBase,
    CoinageFactorySLOT,
    IStakeUniswapV3Proxy2
{
    mapping(uint256 => address) public proxyImplementation;
    mapping(address => bool) public aliveImplementation;
    mapping(bytes4 => address) public selectorImplementation;

    constructor() {
    }

    /// @dev view implementation address of the proxy[index]
    /// @param _index index of proxy
    /// @return address of the implementation
    function implementation2(uint256 _index)
        external
        view
        override
        returns (address)
    {
        return _implementation2(_index);
    }

    /// @dev set the implementation address and status of the proxy[index]
    /// @param newImplementation Address of the new implementation.
    /// @param _index index
    /// @param _alive _alive
    function setImplementation2(
        address newImplementation,
        uint256 _index,
        bool _alive
    ) external override onlyOwner {
        _setImplementation2(newImplementation, _index, _alive);
    }

    /// @dev set alive status of implementation
    /// @param newImplementation Address of the new implementation.
    /// @param _alive alive status
    function setAliveImplementation2(address newImplementation, bool _alive)
        public
        override
        onlyOwner
    {
        _setAliveImplementation2(newImplementation, _alive);
    }

    /// @dev set selectors of Implementation
    /// @param _selectors being added selectors
    /// @param _imp implementation address
    function setSelectorImplementations2(
        bytes4[] calldata _selectors,
        address _imp
    ) public override onlyOwner {
        require(
            _selectors.length > 0,
            "Stake1Proxy: _selectors's size is zero"
        );
        require(aliveImplementation[_imp], "StakeUniswapV3Proxy2: _imp is not alive");

        for (uint256 i = 0; i < _selectors.length; i++) {
            require(
                selectorImplementation[_selectors[i]] != _imp,
                "StakeUniswapV3Proxy2: same imp"
            );
            selectorImplementation[_selectors[i]] = _imp;
        }
    }

    /// @dev set the implementation address and status of the proxy[index]
    /// @param newImplementation Address of the new implementation.
    /// @param _index index of proxy
    /// @param _alive alive status
    function _setImplementation2(
        address newImplementation,
        uint256 _index,
        bool _alive
    ) internal {
        require(
            Address.isContract(newImplementation),
            "StakeUniswapV3Proxy2: Cannot set a proxy implementation to a non-contract address"
        );
        if (_alive) proxyImplementation[_index] = newImplementation;
        _setAliveImplementation2(newImplementation, _alive);
    }

    /// @dev set alive status of implementation
    /// @param newImplementation Address of the new implementation.
    /// @param _alive alive status
    function _setAliveImplementation2(address newImplementation, bool _alive)
        internal
    {
        aliveImplementation[newImplementation] = _alive;
    }

    /// @dev view implementation address of the proxy[index]
    /// @param _index index of proxy
    /// @return impl address of the implementation
    function _implementation2(uint256 _index)
        internal
        view
        returns (address impl)
    {
        return proxyImplementation[_index];
    }

    /// @dev view implementation address of selector of function
    /// @param _selector selector of function
    /// @return impl address of the implementation
    function getSelectorImplementation2(bytes4 _selector)
        public
        view
        override
        returns (address impl)
    {
        if (selectorImplementation[_selector] == address(0))
            return proxyImplementation[0];
        else if (aliveImplementation[selectorImplementation[_selector]])
            return selectorImplementation[_selector];
        else return proxyImplementation[0];
    }

    /// @dev receive ether
    receive() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    fallback() external payable {
        _fallback();
    }

    /// @dev fallback function , execute on undefined function call
    function _fallback() internal {
        address _impl = getSelectorImplementation2(msg.sig);
        require(_impl != address(0) && !pauseProxy, "StakeUniswapV3Proxy2: impl OR proxy is false");

        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }
}


// File contracts/interfaces/IIStakeUniswapV3.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IIStakeUniswapV3 {

    /// @dev stake tokenId of UniswapV3
    /// @param tokenId  tokenId
    /// @param deadline the deadline that valid the owner's signature
    /// @param v the owner's signature - v
    /// @param r the owner's signature - r
    /// @param s the owner's signature - s
    function stakePermit(
        uint256 tokenId,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /// @dev stake tokenId of UniswapV3
    /// @param tokenId  tokenId
    function stake(uint256 tokenId) external;

    /// @dev view mining information of tokenId
    /// @param tokenId  tokenId
    function getMiningTokenId(uint256 tokenId)
        external
        returns (
            uint256 miningAmount,
            uint256 nonMiningAmount,
            uint256 minableAmount,
            uint160 secondsInside,
            uint256 secondsInsideDiff256,
            uint256 liquidity,
            uint256 balanceOfTokenIdRay,
            uint256 minableAmountRay,
            uint256 secondsInside256,
            uint256 secondsAbsolute256
        );


}


// File contracts/stake/StakeUniswapV3Upgrade.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;
pragma abicoder v2;




//import "../interfaces/IStakeRegistry.sol";








/// @title StakeUniswapV3Upgrade
/// @notice Uniswap V3 Contract for staking LP and mining TOS
contract StakeUniswapV3Upgrade is
    StakeUniswapV3Storage,
    AccessibleCommon,
    IIStakeUniswapV3,
    DSMath
{
    using SafeMath for uint256;
    using SafeMath32 for uint32;

    /// @dev event on staking
    /// @param to the sender
    /// @param poolAddress the pool address of uniswapV3
    /// @param tokenId the uniswapV3 Lp token
    /// @param amount the amount of staking
    event Staked(
        address indexed to,
        address indexed poolAddress,
        uint256 tokenId,
        uint256 amount
    );

    /// @dev event on mining in coinage
    /// @param curTime the current time
    /// @param miningInterval mining period (sec)
    /// @param miningAmount the mining amount
    /// @param prevTotalSupply Total amount of coinage before mining
    /// @param afterTotalSupply Total amount of coinage after being mined
    /// @param factor coinage's Factor
    event MinedCoinage(
        uint256 curTime,
        uint256 miningInterval,
        uint256 miningAmount,
        uint256 prevTotalSupply,
        uint256 afterTotalSupply,
        uint256 factor
    );

    event MintAndStaked(
        address indexed to,
        address indexed poolAddress,
        uint256 tokenId,
        uint256 liquidity,
        uint256 amount0,
        uint256 amount1
    );

    /// @dev constructor of StakeCoinage
    constructor() {
        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, msg.sender);

    }

    /// @dev receive ether - revert
    receive() external payable {
        revert();
    }


    /// @dev calculate the factor of coinage
    /// @param source tsource
    /// @param target target
    /// @param oldFactor oldFactor
    function _calcNewFactor(
        uint256 source,
        uint256 target,
        uint256 oldFactor
    ) internal pure returns (uint256) {
        return rdiv(rmul(target, oldFactor), source);
    }

    /// @dev delete user's token storage of index place
    /// @param _owner tokenId's owner
    /// @param tokenId tokenId
    /// @param _index owner's tokenId's index
    function deleteUserToken(
        address _owner,
        uint256 tokenId,
        uint256 _index
    ) internal {
        uint256 _tokenid = userStakedTokenIds[_owner][_index];
        require(_tokenid == tokenId, "StakeUniswapV3Upgrade: mismatch token");
        uint256 lastIndex = (userStakedTokenIds[_owner].length).sub(1);
        if (tokenId > 0 && _tokenid == tokenId) {
            if (_index < lastIndex) {
                uint256 tokenId_lastIndex =
                    userStakedTokenIds[_owner][lastIndex];
                userStakedTokenIds[_owner][_index] = tokenId_lastIndex;
                depositTokens[tokenId_lastIndex].idIndex = _index;
            }
            userStakedTokenIds[_owner].pop();
        }
    }

    /// @dev mining on coinage, Mining conditions :  the sale start time must pass,
    /// the stake start time must pass, the vault mining start time (sale start time) passes,
    /// the mining interval passes, and the current total amount is not zero,
    function miningCoinage() public lock {
        if (saleStartTime == 0 || saleStartTime > block.timestamp) return;
        if (stakeStartTime == 0 || stakeStartTime > block.timestamp) return;

        uint256 _miningEndTime = IIStake2Vault(vault).miningEndTime();

        uint256 curBlocktimestamp = block.timestamp;
        if (curBlocktimestamp > _miningEndTime)
            curBlocktimestamp = _miningEndTime;

        if (
            IIStake2Vault(vault).miningStartTime() > block.timestamp ||
            (coinageLastMintBlockTimetamp > 0 &&
                IIStake2Vault(vault).miningEndTime() <=
                coinageLastMintBlockTimetamp)
        ) return;

        if (coinageLastMintBlockTimetamp == 0)
            coinageLastMintBlockTimetamp = stakeStartTime;

        if (
            curBlocktimestamp >
            (coinageLastMintBlockTimetamp.add(miningIntervalSeconds))
        ) {
            uint256 miningInterval =
                curBlocktimestamp.sub(coinageLastMintBlockTimetamp);
            uint256 miningAmount =
                miningInterval.mul(IIStake2Vault(vault).miningPerSecond());
            uint256 prevTotalSupply =
                IAutoRefactorCoinageWithTokenId(coinage).totalSupply();

            if (miningAmount > 0 && prevTotalSupply > 0) {
                uint256 afterTotalSupply =
                    prevTotalSupply.add(miningAmount.mul(10**9));
                uint256 factor =
                    IAutoRefactorCoinageWithTokenId(coinage).setFactor(
                        _calcNewFactor(
                            prevTotalSupply,
                            afterTotalSupply,
                            IAutoRefactorCoinageWithTokenId(coinage).factor()
                        )
                    );
                coinageLastMintBlockTimetamp = curBlocktimestamp;

                emit MinedCoinage(
                    block.timestamp,
                    miningInterval,
                    miningAmount,
                    prevTotalSupply,
                    afterTotalSupply,
                    factor
                );
            }
        }
    }

    /// @dev view mining information of tokenId
    /// @param tokenId  tokenId
    function getMiningTokenId(uint256 tokenId)
        public
        view
        override
        nonZeroAddress(poolAddress)
        returns (
            uint256 miningAmount,
            uint256 nonMiningAmount,
            uint256 minableAmount,
            uint160 secondsInside,
            uint256 secondsInsideDiff256,
            uint256 liquidity,
            uint256 balanceOfTokenIdRay,
            uint256 minableAmountRay,
            uint256 secondsInside256,
            uint256 secondsAbsolute256
        )
    {
        if (
            stakeStartTime < block.timestamp && stakeStartTime < block.timestamp
        ) {
            LibUniswapV3Stake.StakeLiquidity storage _depositTokens =
                depositTokens[tokenId];
            liquidity = _depositTokens.liquidity;

            uint32 secondsAbsolute = 0;
            balanceOfTokenIdRay = IAutoRefactorCoinageWithTokenId(coinage)
                .balanceOf(tokenId);

            uint256 curBlockTimestamp = block.timestamp;
            //uint256 _miningEndTime = IIStake2Vault(vault).miningEndTime();
            if (curBlockTimestamp > IIStake2Vault(vault).miningEndTime())
                curBlockTimestamp = IIStake2Vault(vault).miningEndTime();

            if (_depositTokens.liquidity > 0 && balanceOfTokenIdRay > 0) {
                uint256 _minableAmount = 0;
                if (balanceOfTokenIdRay > liquidity.mul(10**9)) {
                    minableAmountRay = balanceOfTokenIdRay.sub(
                        liquidity.mul(10**9)
                    );
                    _minableAmount = minableAmountRay.div(10**9);
                }
                if (_minableAmount > 0) {
                    (, , secondsInside) = IUniswapV3Pool(poolAddress)
                        .snapshotCumulativesInside(
                        _depositTokens.tickLower,
                        _depositTokens.tickUpper
                    );
                    secondsInside256 = uint256(secondsInside);

                    if (_depositTokens.claimedTime > 0)
                        secondsAbsolute = uint32(curBlockTimestamp).sub(
                            _depositTokens.claimedTime
                        );
                    else
                        secondsAbsolute = uint32(curBlockTimestamp).sub(
                            _depositTokens.startTime
                        );
                    secondsAbsolute256 = uint256(secondsAbsolute);

                    if (secondsAbsolute > 0) {
                        if (_depositTokens.secondsInsideLast > 0) {
                            // unit32 문제로 더 작은 수가 나올수있다.
                            if(secondsInside < _depositTokens.secondsInsideLast){
                               secondsInsideDiff256 = secondsInside256.add(
                                   uint256(type(uint32).max).sub(uint256(_depositTokens.secondsInsideLast))
                                   );
                            } else {
                                secondsInsideDiff256 = secondsInside256.sub(
                                    uint256(_depositTokens.secondsInsideLast)
                                );
                            }
                        } else {
                            // unit32 문제로 더 작은 수가 나올수있다.
                            if(secondsInside < _depositTokens.secondsInsideInitial){
                                secondsInsideDiff256 = secondsInside256.add(
                                    uint256(type(uint32).max).sub(uint256(_depositTokens.secondsInsideInitial))
                                    );
                            } else {
                                 secondsInsideDiff256 = secondsInside256.sub(
                                    uint256(_depositTokens.secondsInsideInitial)
                                );
                            }
                        }

                        minableAmount = _minableAmount;
                        if (
                            secondsInsideDiff256 < secondsAbsolute256 &&
                            secondsInsideDiff256 > 0
                        ) {
                            miningAmount = _minableAmount
                                .mul(secondsInsideDiff256)
                                .div(secondsAbsolute256);
                        } else if (secondsInsideDiff256 > 0) {
                            miningAmount = _minableAmount;
                        }

                        nonMiningAmount = minableAmount.sub(miningAmount);
                    }
                }
            }
        }
    }

    /// @dev stake tokenId of UniswapV3
    /// @param tokenId  tokenId
    /// @param deadline the deadline that valid the owner's signature
    /// @param v the owner's signature - v
    /// @param r the owner's signature - r
    /// @param s the owner's signature - s
    function stakePermit(
        uint256 tokenId,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    )
        external
        override
        nonZeroAddress(token)
        nonZeroAddress(vault)
        nonZeroAddress(stakeRegistry)
        nonZeroAddress(poolToken0)
        nonZeroAddress(poolToken1)
        nonZeroAddress(address(nonfungiblePositionManager))
        nonZeroAddress(uniswapV3FactoryAddress)
    {
        require(
            saleStartTime < block.timestamp,
            "StakeUniswapV3Upgrade: before start"
        );

        require(
            block.timestamp < IIStake2Vault(vault).miningEndTime(),
            "StakeUniswapV3Upgrade: end mining"
        );

        require(
            nonfungiblePositionManager.ownerOf(tokenId) == msg.sender,
            "StakeUniswapV3Upgrade: not owner"
        );

        nonfungiblePositionManager.permit(
            address(this),
            tokenId,
            deadline,
            v,
            r,
            s
        );

        _stake(tokenId);
    }

    /// @dev stake tokenId of UniswapV3
    /// @param tokenId  tokenId
    function stake(uint256 tokenId)
        external
        override
        nonZeroAddress(token)
        nonZeroAddress(vault)
        nonZeroAddress(stakeRegistry)
        nonZeroAddress(poolToken0)
        nonZeroAddress(poolToken1)
        nonZeroAddress(address(nonfungiblePositionManager))
        nonZeroAddress(uniswapV3FactoryAddress)
        nonZeroAddress(poolAddress)
    {
        require(
            saleStartTime < block.timestamp,
            "StakeUniswapV3Upgrade: before start"
        );
        require(
            block.timestamp < IIStake2Vault(vault).miningEndTime(),
            "StakeUniswapV3Upgrade: end mining"
        );
        require(
            nonfungiblePositionManager.ownerOf(tokenId) == msg.sender,
            "StakeUniswapV3Upgrade: not owner"
        );

        _stake(tokenId);
    }

    /// @dev stake tokenId of UniswapV3
    /// @param tokenId  tokenId
    function _stake(uint256 tokenId) internal {
        LibUniswapV3Stake.StakeLiquidity storage _depositTokens =
            depositTokens[tokenId];

        require(
            _depositTokens.owner == address(0),
            "StakeUniswapV3Upgrade: Already staked"
        );

        uint256 _tokenId = tokenId;
        (
            ,
            ,
            address token0,
            address token1,
            uint24 fee,
            int24 tickLower,
            int24 tickUpper,
            uint128 liquidity,
            ,
            ,
            ,

        ) = nonfungiblePositionManager.positions(_tokenId);

        require(
            (token0 == poolToken0 && token1 == poolToken1) ||
                (token0 == poolToken1 && token1 == poolToken0),
            "StakeUniswapV3Upgrade: different token"
        );

        require(liquidity > 0, "StakeUniswapV3Upgrade: zero liquidity");

        if (poolAddress == address(0)) {
            poolAddress = PoolAddress.computeAddress(
                uniswapV3FactoryAddress,
                PoolAddress.PoolKey({token0: token0, token1: token1, fee: fee})
            );
        }

        require(poolAddress != address(0), "StakeUniswapV3Upgrade: zero poolAddress");

        require(
            checkCurrentPosition(tickLower, tickUpper),
            "StakeUniswapV3Upgrade: locked or out of range"
        );

        (, , uint32 secondsInside) =
            IUniswapV3Pool(poolAddress).snapshotCumulativesInside(
                tickLower,
                tickUpper
            );

        uint256 tokenId_ = _tokenId;

        // initial start time
        if (stakeStartTime == 0) stakeStartTime = block.timestamp;

        _depositTokens.owner = msg.sender;
        _depositTokens.idIndex = userStakedTokenIds[msg.sender].length;
        _depositTokens.liquidity = liquidity;
        _depositTokens.tickLower = tickLower;
        _depositTokens.tickUpper = tickUpper;
        _depositTokens.startTime = uint32(block.timestamp);
        _depositTokens.claimedTime = 0;
        _depositTokens.secondsInsideInitial = secondsInside;
        _depositTokens.secondsInsideLast = 0;

        nonfungiblePositionManager.transferFrom(
            msg.sender,
            address(this),
            tokenId_
        );

        // save tokenid
        userStakedTokenIds[msg.sender].push(tokenId_);

        totalStakedAmount = totalStakedAmount.add(liquidity);
        totalTokens = totalTokens.add(1);

        LibUniswapV3Stake.StakedTotalTokenAmount storage _userTotalStaked =
            userTotalStaked[msg.sender];
        if (!_userTotalStaked.staked) totalStakers = totalStakers.add(1);
        _userTotalStaked.staked = true;
        _userTotalStaked.totalDepositAmount = _userTotalStaked
            .totalDepositAmount
            .add(liquidity);

        LibUniswapV3Stake.StakedTokenAmount storage _stakedCoinageTokens =
            stakedCoinageTokens[tokenId_];
        _stakedCoinageTokens.amount = liquidity;
        _stakedCoinageTokens.startTime = uint32(block.timestamp);

        //mint coinage of user amount
        IAutoRefactorCoinageWithTokenId(coinage).mint(
            msg.sender,
            tokenId_,
            uint256(liquidity).mul(10**9)
        );

        miningCoinage();

        emit Staked(msg.sender, poolAddress, tokenId_, liquidity);
    }

    function checkCurrentPosition(int24 tickLower, int24 tickUpper)
        internal
        view
        returns (bool)
    {
        (, int24 tick, , , , , bool unlocked) =
            IUniswapV3Pool(poolAddress).slot0();
        if (unlocked && tickLower < tick && tick < tickUpper) return true;
        else return false;
    }

    function mint(int24 tickLower, int24 tickUpper,
        uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min,
        uint256 deadline)
        external
    {
        require(
            saleStartTime < block.timestamp,
            "StakeUniswapV3Upgrade: before start"
        );

        require(
            block.timestamp < IIStake2Vault(vault).miningEndTime(),
            "StakeUniswapV3Upgrade: end mining"
        );

        require(
            poolToken0 != address(0) && poolToken1 != address(0),
            "StakeUniswapV3Upgrade: zeroAddress token"
        );
        require(
            checkCurrentPosition(tickLower, tickUpper),
            "StakeUniswapV3Upgrade: out of range"
        );

        require(
            amount0Desired > 0 ||  amount1Desired > 0,
            "StakeUniswapV3Upgrade: liquidity zero"
        );

        if(amount0Desired > 0 ){
             TransferHelper.safeTransferFrom(
                poolToken0,
                msg.sender,
                address(this),
                amount0Desired
            );
        }
        if(amount1Desired > 0 ){
            TransferHelper.safeTransferFrom(
                poolToken1,
                msg.sender,
                address(this),
                amount1Desired
            );
        }

        (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1) =
            nonfungiblePositionManager.mint(
                INonfungiblePositionManager.MintParams({
                    token0: poolToken0,
                    token1: poolToken1,
                    fee: uint24(poolFee),
                    tickLower: tickLower,
                    tickUpper: tickUpper,
                    amount0Desired: amount0Desired,
                    amount1Desired: amount1Desired,
                    amount0Min: amount0Min,
                    amount1Min: amount1Min,
                    recipient: address(this),
                    deadline: deadline
                })
            );

        require(nonfungiblePositionManager.ownerOf(tokenId) == address(this), "StakeUniswapV3Upgrade: owner wrong");

        if(amount0 < amount0Desired) {
            TransferHelper.safeTransfer(
                poolToken0,
                msg.sender,
                amount0Desired.sub(amount0)
            );
        }
        if(amount1 < amount1Desired) {
            TransferHelper.safeTransfer(
                poolToken1,
                msg.sender,
                amount1Desired.sub(amount1)
            );
        }

        require(
            tokenId > 0 && liquidity > 0,
            "StakeUniswapV3Upgrade: zero tokenId or liquidity"
        );

        LibUniswapV3Stake.StakeLiquidity storage _depositTokens =
            depositTokens[tokenId];
        require(
            _depositTokens.owner == address(0),
            "StakeUniswapV3Upgrade: already staked"
        );
        _depositTokens.owner = msg.sender;

        (, , uint32 secondsInside) =
            IUniswapV3Pool(poolAddress).snapshotCumulativesInside(
                tickLower,
                tickUpper
            );

        _depositTokens.idIndex = userStakedTokenIds[msg.sender].length;
        _depositTokens.liquidity = liquidity;
        _depositTokens.tickLower = tickLower;
        _depositTokens.tickUpper = tickUpper;
        _depositTokens.startTime = uint32(block.timestamp);
        _depositTokens.claimedTime = 0;
        _depositTokens.secondsInsideInitial = secondsInside;
        _depositTokens.secondsInsideLast = 0;

        userStakedTokenIds[msg.sender].push(tokenId);

        totalStakedAmount = totalStakedAmount.add(liquidity);
        totalTokens = totalTokens.add(1);

        LibUniswapV3Stake.StakedTotalTokenAmount storage _userTotalStaked =
            userTotalStaked[msg.sender];

        if (!_userTotalStaked.staked) {
            totalStakers = totalStakers.add(1);
            _userTotalStaked.staked = true;
        }

        _userTotalStaked.totalDepositAmount = _userTotalStaked
            .totalDepositAmount
            .add(liquidity);

        LibUniswapV3Stake.StakedTokenAmount storage _stakedCoinageTokens =
            stakedCoinageTokens[tokenId];
        _stakedCoinageTokens.amount = liquidity;
        _stakedCoinageTokens.startTime = uint32(block.timestamp);

        //mint coinage of user amount
        IAutoRefactorCoinageWithTokenId(coinage).mint(
            msg.sender,
            tokenId,
            uint256(liquidity).mul(10**9)
        );

        miningCoinage();

        emit MintAndStaked(msg.sender, poolAddress, tokenId, liquidity, amount0, amount1);
    }

}


// File contracts/stake/StakeUniswapV3Upgrade1.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;
pragma abicoder v2;




//import "../interfaces/IStakeRegistry.sol";
//import "../interfaces/IStakeUniswapV3.sol";







//import "hardhat/console.sol";

/// @title StakeUniswapV3
/// @notice Uniswap V3 Contract for staking LP and mining TOS
contract StakeUniswapV3Upgrade1 is
    StakeUniswapV3Storage,
    AccessibleCommon,
    DSMath
{
    using SafeMath for uint256;
    using SafeMath32 for uint32;

    event MinedCoinage(
        uint256 curTime,
        uint256 miningInterval,
        uint256 miningAmount,
        uint256 prevTotalSupply,
        uint256 afterTotalSupply,
        uint256 factor
    );

    event IncreasedLiquidity(
        address indexed sender,
        uint256 indexed tokenId,
        uint128 liquidity,
        uint256 amount0,
        uint256 amount1
    );

    event Collected(
        address indexed sender,
        uint256 indexed tokenId,
        uint256 amount0,
        uint256 amount1
    );

    event DecreasedLiquidity(
        address indexed sender,
        uint256 indexed tokenId,
        uint128 liquidity,
        uint256 amount0,
        uint256 amount1
    );

    event WithdrawalToken(
        address indexed sender,
        uint256 indexed tokenId,
        uint256 miningAmount,
        uint256 nonMiningAmount
    );

    event Claimed(
        address indexed sender,
        uint256 indexed tokenId,
        address poolAddress,
        uint256 miningAmount,
        uint256 nonMiningAmount
    );

    /// @dev constructor of StakeCoinage
    constructor() {
        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setupRole(ADMIN_ROLE, msg.sender);

    }

    /// @dev receive ether - revert
    receive() external payable {
        revert();
    }

    /// @dev mining on coinage, Mining conditions :  the sale start time must pass,
    /// the stake start time must pass, the vault mining start time (sale start time) passes,
    /// the mining interval passes, and the current total amount is not zero,
    function miningCoinage() public lock {
        if (saleStartTime == 0 || saleStartTime > block.timestamp) return;
        if (stakeStartTime == 0 || stakeStartTime > block.timestamp) return;

        uint256 _miningEndTime = IIStake2Vault(vault).miningEndTime();

        uint256 curBlocktimestamp = block.timestamp;
        if (curBlocktimestamp > _miningEndTime)
            curBlocktimestamp = _miningEndTime;

        if (
            IIStake2Vault(vault).miningStartTime() > block.timestamp ||
            (coinageLastMintBlockTimetamp > 0 &&
                IIStake2Vault(vault).miningEndTime() <=
                coinageLastMintBlockTimetamp)
        ) return;

        if (coinageLastMintBlockTimetamp == 0)
            coinageLastMintBlockTimetamp = stakeStartTime;

        if (
            curBlocktimestamp >
            (coinageLastMintBlockTimetamp.add(miningIntervalSeconds))
        ) {
            uint256 miningInterval =
                curBlocktimestamp.sub(coinageLastMintBlockTimetamp);
            uint256 miningAmount =
                miningInterval.mul(IIStake2Vault(vault).miningPerSecond());
            uint256 prevTotalSupply =
                IAutoRefactorCoinageWithTokenId(coinage).totalSupply();

            if (miningAmount > 0 && prevTotalSupply > 0) {
                uint256 afterTotalSupply =
                    prevTotalSupply.add(miningAmount.mul(10**9));
                uint256 factor =
                    IAutoRefactorCoinageWithTokenId(coinage).setFactor(
                        _calcNewFactor(
                            prevTotalSupply,
                            afterTotalSupply,
                            IAutoRefactorCoinageWithTokenId(coinage).factor()
                        )
                    );
                coinageLastMintBlockTimetamp = curBlocktimestamp;

                emit MinedCoinage(
                    block.timestamp,
                    miningInterval,
                    miningAmount,
                    prevTotalSupply,
                    afterTotalSupply,
                    factor
                );
            }
        }
    }

    function _calcNewFactor(
        uint256 source,
        uint256 target,
        uint256 oldFactor
    ) internal pure returns (uint256) {
        return rdiv(rmul(target, oldFactor), source);
    }

    function checkCurrentPosition(int24 tickLower, int24 tickUpper)
        internal
        view
        returns (bool)
    {
        (, int24 tick, , , , , ) = IUniswapV3Pool(poolAddress).slot0();
        if (tickLower < tick && tick < tickUpper) return true;
        else return false;
    }

    function safeApproveAll(address[] calldata tokens, uint256[] calldata totals) external returns (bool) {
        require(tokens.length == totals.length, "StakeUniswapV3Upgrade1: diff length");

        for(uint256 i=0; i < tokens.length; i++){
            if(tokens[i] != address(0) && totals[i] > 0 ){
                TransferHelper.safeApprove(
                    tokens[i],
                    address(nonfungiblePositionManager),
                    totals[i]
                );
            }
        }
        return true;
    }

    function increaseLiquidity(uint256 tokenId,
            uint256 amount0Desired,
            uint256 amount1Desired,
            uint256 amount0Min,
            uint256 amount1Min,
            uint256 deadline)
        external
        payable
        returns (bool)
    {

        LibUniswapV3Stake.StakeLiquidity storage _depositTokens =
            depositTokens[tokenId];
        require(
            msg.sender == _depositTokens.owner,
            "StakeUniswapV3Upgrade1: not owner"
        );
        require(
            !_depositTokens.claimLock && !_depositTokens.withdraw,
            "StakeUniswapV3Upgrade1: in process"
        );
        require(
            poolToken0 != address(0) && poolToken1 != address(0),
            "StakeUniswapV3Upgrade1: zeroAddress token"
        );
        require(
            checkCurrentPosition(
                _depositTokens.tickLower,
                _depositTokens.tickUpper
            ),
            "StakeUniswapV3Upgrade1: out of range"
        );

        _depositTokens.claimLock = true;

        miningCoinage();

        TransferHelper.safeTransferFrom(
            poolToken0,
            msg.sender,
            address(this),
            amount0Desired
        );
        TransferHelper.safeTransferFrom(
            poolToken1,
            msg.sender,
            address(this),
            amount1Desired
        );

        (uint128 liquidity, uint256 amount0, uint256 amount1) =
            nonfungiblePositionManager.increaseLiquidity(
                INonfungiblePositionManager.IncreaseLiquidityParams({
                    tokenId: tokenId,
                    amount0Desired: amount0Desired,
                    amount1Desired: amount1Desired,
                    amount0Min: amount0Min,
                    amount1Min: amount1Min,
                    deadline: deadline
                })
            );
        (, , , , , int24 tickLower, int24 tickUpper, , , , , ) =
            nonfungiblePositionManager.positions(tokenId);
        _depositTokens.liquidity += liquidity;
        _depositTokens.tickLower = tickLower;
        _depositTokens.tickUpper = tickUpper;

        totalStakedAmount = totalStakedAmount.add(uint256(liquidity));

        uint256 tokenId_ = tokenId;

        LibUniswapV3Stake.StakedTotalTokenAmount storage _userTotalStaked =
            userTotalStaked[msg.sender];
        _userTotalStaked.totalDepositAmount = _userTotalStaked
            .totalDepositAmount
            .add(uint256(liquidity));
        LibUniswapV3Stake.StakedTokenAmount storage _stakedCoinageTokens =
            stakedCoinageTokens[tokenId_];
        _stakedCoinageTokens.amount = _stakedCoinageTokens.amount.add(
            uint256(liquidity)
        );

        //mint coinage of user amount
        IAutoRefactorCoinageWithTokenId(coinage).mint(
            msg.sender,
            tokenId_,
            uint256(liquidity).mul(10**9)
        );

        _depositTokens.claimLock = false;

        emit IncreasedLiquidity(
            msg.sender,
            tokenId_,
            liquidity,
            amount0,
            amount1
        );
        return true;
    }

    function collect(uint256 tokenId, uint128 amount0Max, uint128 amount1Max) public returns (bool) {

        LibUniswapV3Stake.StakeLiquidity storage _depositTokens =
            depositTokens[tokenId];
        require(
            msg.sender == _depositTokens.owner,
            "StakeUniswapV3Upgrade1: not owner"
        );
        require(
            !_depositTokens.claimLock && !_depositTokens.withdraw,
            "StakeUniswapV3Upgrade1: in process"
        );
        require(
            poolToken0 != address(0) && poolToken1 != address(0),
            "StakeUniswapV3Upgrade1: zeroAddress token"
        );
        (, , , , , , , , , , uint128 tokensOwed0, uint128 tokensOwed1) =
            nonfungiblePositionManager.positions(tokenId);

        require(
            amount0Max <= tokensOwed0 && amount1Max <= tokensOwed1,
            "StakeUniswapV3Upgrade1: tokensOwed is insufficient"
        );

        require(
            amount0Max > 0 || amount1Max > 0,
            "StakeUniswapV3Upgrade1: zero amount"
        );

        _depositTokens.claimLock = true;

        (uint256 amount0, uint256 amount1) =
            nonfungiblePositionManager.collect(
                INonfungiblePositionManager.CollectParams({
                    tokenId: tokenId,
                    recipient: _depositTokens.owner,
                    amount0Max: amount0Max,
                    amount1Max: amount1Max
                })
            );

        _depositTokens.claimLock = false;
        emit Collected(msg.sender, tokenId, amount0, amount1);
        return true;
    }

    function decreaseLiquidity(uint256 tokenId,
            uint128 paramliquidity,
            uint256 amount0Min,
            uint256 amount1Min,
            uint256 deadline)
        external
        payable
        returns (bool ret)
    {

        LibUniswapV3Stake.StakeLiquidity storage _depositTokens =
            depositTokens[tokenId];
        require(
            msg.sender == _depositTokens.owner,
            "StakeUniswapV3Upgrade1: not owner"
        );
        require(
            _depositTokens.liquidity > paramliquidity,
            "StakeUniswapV3Upgrade1: insufficient liquidity"
        );
        require(
            !_depositTokens.claimLock && !_depositTokens.withdraw,
            "StakeUniswapV3Upgrade1: in process"
        );
        require(
            checkCurrentPosition(
                _depositTokens.tickLower,
                _depositTokens.tickUpper
            ),
            "StakeUniswapV3Upgrade1: out of range"
        );

        _depositTokens.claimLock = true;
        ret = true;

        //uint128 positionLiquidity = liquidity;
        miningCoinage();
        (uint256 amount0, uint256 amount1) =
            nonfungiblePositionManager.decreaseLiquidity(
                INonfungiblePositionManager.DecreaseLiquidityParams({
                    tokenId: tokenId,
                    liquidity: paramliquidity,
                    amount0Min: amount0Min,
                    amount1Min: amount1Min,
                    deadline: deadline
                })
            );
        (
            ,
            ,
            ,
            ,
            ,
            int24 tickLower,
            int24 tickUpper,
            uint128 liquidity,
            ,
            ,
            ,

        ) = nonfungiblePositionManager.positions(tokenId);
        _depositTokens.tickLower = tickLower;
        _depositTokens.tickUpper = tickUpper;

        uint256 tokenId_ = tokenId;
        //_depositTokens.liquidity -= positionLiquidity;
        uint128 diffLiquidity = _depositTokens.liquidity - liquidity;
        _depositTokens.liquidity = liquidity;

        totalStakedAmount = totalStakedAmount.sub(uint256(diffLiquidity));

        LibUniswapV3Stake.StakedTotalTokenAmount storage _userTotalStaked =
            userTotalStaked[msg.sender];
        _userTotalStaked.totalDepositAmount = _userTotalStaked
            .totalDepositAmount
            .sub(uint256(diffLiquidity));
        LibUniswapV3Stake.StakedTokenAmount storage _stakedCoinageTokens =
            stakedCoinageTokens[tokenId_];
        _stakedCoinageTokens.amount = _stakedCoinageTokens.amount.sub(
            uint256(diffLiquidity)
        );

        uint256 amount0_ = amount0;
        uint256 amount1_ = amount1;

        //mint coinage of user amount
        IAutoRefactorCoinageWithTokenId(coinage).burn(
            msg.sender,
            tokenId_,
            uint256(diffLiquidity).mul(10**9)
        );

        _depositTokens.claimLock = false;
        emit DecreasedLiquidity(
            msg.sender,
            tokenId_,
            diffLiquidity,
            amount0_,
            amount1_
        );
    }

    function withdraw(uint256 tokenId) external returns (bool) {

        LibUniswapV3Stake.StakeLiquidity storage _depositTokens =
            depositTokens[tokenId];
        require(
            _depositTokens.owner == msg.sender,
            "StakeUniswapV3Upgrade1: not staker"
        );

        require(
            _depositTokens.withdraw == false,
            "StakeUniswapV3Upgrade1: withdrawing"
        );
        _depositTokens.withdraw = true;

        miningCoinage();

        if (totalStakedAmount >= _depositTokens.liquidity)
            totalStakedAmount = totalStakedAmount.sub(_depositTokens.liquidity);

        if (totalTokens > 0) totalTokens = totalTokens.sub(1);

        (
            uint256 miningAmount,
            uint256 nonMiningAmount,
            uint256 minableAmount,
            ,
            ,
            ,
            ,
            ,
            ,

        ) = getMiningTokenId(tokenId);

        IAutoRefactorCoinageWithTokenId(coinage).burnTokenId(
            msg.sender,
            tokenId
        );

        // storage  StakedTotalTokenAmount
        LibUniswapV3Stake.StakedTotalTokenAmount storage _userTotalStaked =
            userTotalStaked[msg.sender];
        _userTotalStaked.totalDepositAmount = _userTotalStaked
            .totalDepositAmount
            .sub(_depositTokens.liquidity);
        _userTotalStaked.totalMiningAmount = _userTotalStaked
            .totalMiningAmount
            .add(miningAmount);
        _userTotalStaked.totalNonMiningAmount = _userTotalStaked
            .totalNonMiningAmount
            .add(nonMiningAmount);

        // total
        miningAmountTotal = miningAmountTotal.add(miningAmount);
        nonMiningAmountTotal = nonMiningAmountTotal.add(nonMiningAmount);

        deleteUserToken(_depositTokens.owner, tokenId, _depositTokens.idIndex);

        delete depositTokens[tokenId];
        delete stakedCoinageTokens[tokenId];

        if (_userTotalStaked.totalDepositAmount == 0) {
            totalStakers = totalStakers.sub(1);
            delete userTotalStaked[msg.sender];
        }

        if (minableAmount > 0) {
            require(
                IIStake2Vault(vault).claimMining(
                    msg.sender,
                    minableAmount,
                    miningAmount,
                    nonMiningAmount
                ),
                "fail claimMining"
            );
        }

        nonfungiblePositionManager.safeTransferFrom(
            address(this),
            msg.sender,
            tokenId
        );

        emit WithdrawalToken(
            msg.sender,
            tokenId,
            miningAmount,
            nonMiningAmount
        );
        return true;
    }

    /// @dev delete user's token storage of index place
    /// @param _owner tokenId's owner
    /// @param tokenId tokenId
    /// @param _index owner's tokenId's index
    function deleteUserToken(
        address _owner,
        uint256 tokenId,
        uint256 _index
    ) internal {
        uint256 _tokenid = userStakedTokenIds[_owner][_index];
        require(_tokenid == tokenId, "StakeUniswapV3Upgrade1: mismatch token");
        uint256 lastIndex = (userStakedTokenIds[_owner].length).sub(1);
        if (tokenId > 0 && _tokenid == tokenId) {
            if (_index < lastIndex) {
                uint256 tokenId_lastIndex =
                    userStakedTokenIds[_owner][lastIndex];
                userStakedTokenIds[_owner][_index] = tokenId_lastIndex;
                depositTokens[tokenId_lastIndex].idIndex = _index;
            }
            userStakedTokenIds[_owner].pop();
        }
    }

    /// @dev view mining information of tokenId
    /// @param tokenId  tokenId
    function getMiningTokenId(uint256 tokenId)
        public
        view
        returns (
            uint256 miningAmount,
            uint256 nonMiningAmount,
            uint256 minableAmount,
            uint160 secondsInside,
            uint256 secondsInsideDiff256,
            uint256 liquidity,
            uint256 balanceOfTokenIdRay,
            uint256 minableAmountRay,
            uint256 secondsInside256,
            uint256 secondsAbsolute256
        )
    {
        if (
            stakeStartTime < block.timestamp && stakeStartTime < block.timestamp
        ) {
            LibUniswapV3Stake.StakeLiquidity storage _depositTokens =
                depositTokens[tokenId];
            liquidity = _depositTokens.liquidity;

            uint32 secondsAbsolute = 0;
            balanceOfTokenIdRay = IAutoRefactorCoinageWithTokenId(coinage)
                .balanceOf(tokenId);

            uint256 curBlockTimestamp = block.timestamp;
            uint256 _miningEndTime = IIStake2Vault(vault).miningEndTime();
            if (curBlockTimestamp > _miningEndTime)
                curBlockTimestamp = _miningEndTime;

            if (_depositTokens.liquidity > 0 && balanceOfTokenIdRay > 0) {
                if (balanceOfTokenIdRay > liquidity.mul(10**9)) {
                    minableAmountRay = balanceOfTokenIdRay.sub(
                        liquidity.mul(10**9)
                    );
                    minableAmount = minableAmountRay.div(10**9);
                }
                if (minableAmount > 0) {
                    (, , secondsInside) = IUniswapV3Pool(poolAddress)
                        .snapshotCumulativesInside(
                        _depositTokens.tickLower,
                        _depositTokens.tickUpper
                    );
                    secondsInside256 = uint256(secondsInside);

                    if (_depositTokens.claimedTime > 0)
                        secondsAbsolute = uint32(curBlockTimestamp).sub(
                            _depositTokens.claimedTime
                        );
                    else
                        secondsAbsolute = uint32(curBlockTimestamp).sub(
                            _depositTokens.startTime
                        );
                    secondsAbsolute256 = uint256(secondsAbsolute);

                    if (secondsAbsolute > 0) {
                        if (_depositTokens.secondsInsideLast > 0) {
                            // unit32 문제로 더 작은 수가 나올수있다.
                            if(secondsInside < _depositTokens.secondsInsideLast){
                               secondsInsideDiff256 = secondsInside256.add(
                                   uint256(type(uint32).max).sub(uint256(_depositTokens.secondsInsideLast))
                                   );
                            } else {
                                secondsInsideDiff256 = secondsInside256.sub(
                                    uint256(_depositTokens.secondsInsideLast)
                                );
                            }
                        } else {
                            // unit32 문제로 더 작은 수가 나올수있다.
                            if(secondsInside < _depositTokens.secondsInsideInitial){
                                secondsInsideDiff256 = secondsInside256.add(
                                    uint256(type(uint32).max).sub(uint256(_depositTokens.secondsInsideInitial))
                                    );
                            } else {
                                secondsInsideDiff256 = secondsInside256.sub(
                                    uint256(_depositTokens.secondsInsideInitial)
                                );
                            }
                        }

                        if (
                            secondsInsideDiff256 < secondsAbsolute256 &&
                            secondsInsideDiff256 > 0
                        ) {
                            miningAmount = minableAmount
                                .mul(secondsInsideDiff256)
                                .div(secondsAbsolute256);
                            nonMiningAmount = minableAmount.sub(miningAmount);
                        } else if (secondsInsideDiff256 > 0) {
                            miningAmount = minableAmount;
                            nonMiningAmount = 0;
                        } else {
                            nonMiningAmount = minableAmount;
                            miningAmount = 0;
                        }

                    }
                }
            }
        }
    }

    function claim(uint256 tokenId) public returns (bool) {

        LibUniswapV3Stake.StakeLiquidity storage _depositTokens =
            depositTokens[tokenId];

        require(
            _depositTokens.owner == msg.sender,
            "StakeUniswapV3Upgrade1: not staker"
        );

        require(
            _depositTokens.claimedTime <
                uint32(block.timestamp.sub(miningIntervalSeconds)),
            "StakeUniswapV3Upgrade1: already claimed"
        );

        require(
            _depositTokens.claimLock == false,
            "StakeUniswapV3Upgrade1: claiming"
        );
        _depositTokens.claimLock = true;

        miningCoinage();

        (
            uint256 miningAmount,
            uint256 nonMiningAmount,
            uint256 minableAmount,
            uint160 secondsInside,
            ,
            ,
            ,
            uint256 minableAmountRay,
            ,

        ) = getMiningTokenId(tokenId);

        require(miningAmount > 0, "StakeUniswapV3Upgrade1: zero miningAmount");

        _depositTokens.claimedTime = uint32(block.timestamp);
        _depositTokens.secondsInsideLast = secondsInside;

        IAutoRefactorCoinageWithTokenId(coinage).burn(
            msg.sender,
            tokenId,
            minableAmountRay
        );

        // storage  stakedCoinageTokens
        LibUniswapV3Stake.StakedTokenAmount storage _stakedCoinageTokens =
            stakedCoinageTokens[tokenId];
        _stakedCoinageTokens.claimedTime = uint32(block.timestamp);
        _stakedCoinageTokens.claimedAmount = _stakedCoinageTokens
            .claimedAmount
            .add(miningAmount);
        _stakedCoinageTokens.nonMiningAmount = _stakedCoinageTokens
            .nonMiningAmount
            .add(nonMiningAmount);

        // storage  StakedTotalTokenAmount
        LibUniswapV3Stake.StakedTotalTokenAmount storage _userTotalStaked =
            userTotalStaked[msg.sender];
        _userTotalStaked.totalMiningAmount = _userTotalStaked
            .totalMiningAmount
            .add(miningAmount);
        _userTotalStaked.totalNonMiningAmount = _userTotalStaked
            .totalNonMiningAmount
            .add(nonMiningAmount);

        // total
        miningAmountTotal = miningAmountTotal.add(miningAmount);
        nonMiningAmountTotal = nonMiningAmountTotal.add(nonMiningAmount);

        require(
            IIStake2Vault(vault).claimMining(
                msg.sender,
                minableAmount,
                miningAmount,
                nonMiningAmount
            )
        );

        _depositTokens.claimLock = false;

        emit Claimed(
            msg.sender,
            tokenId,
            poolAddress,
            miningAmount,
            nonMiningAmount
        );
        return true;
    }

    function claimAndCollect(uint256 tokenId, uint128 amount0Max, uint128 amount1Max) external returns (bool) {

        require(
            claim(tokenId),
            "StakeUniswapV3Upgrade1: fail claim"
        );
        require(collect(tokenId, amount0Max, amount1Max), "StakeUniswapV3Upgrade1: fail collect");
        return true;
    }
}


// File contracts/tokens/TOS.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;




/// @title the platform token. TOS token

contract TOS is ERC20, AccessiblePlusCommon, ITOS {
    bytes32 public override DOMAIN_SEPARATOR;
    mapping(address => uint256) public override nonces;

    /// @dev Value is equal to keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
    bytes32 public constant PERMIT_TYPEHASH =
        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    /// @dev constructor of TOS, ERC20 Token
    constructor(
        string memory name_,
        string memory symbol_,
        string memory version_
    ) ERC20(name_, symbol_) {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }

        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')
                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,
                keccak256(bytes(name_)),
                keccak256(bytes(version_)),
                chainId,
                address(this)
            )
        );

        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setRoleAdmin(BURNER_ROLE, ADMIN_ROLE);
        _setRoleAdmin(MINTER_ROLE, ADMIN_ROLE);

        _setupRole(ADMIN_ROLE, msg.sender);
        _setupRole(BURNER_ROLE, msg.sender);
        _setupRole(MINTER_ROLE, msg.sender);
    }

    /// @dev Issue a token.
    /// @param to  who takes the issue
    /// @param amount the amount to issue
    function mint(address to, uint256 amount)
        external
        override
        onlyMinter
        returns (bool)
    {
        _mint(to, amount);
        return true;
    }

    /// @dev burn a token.
    /// @param from Whose tokens are burned
    /// @param amount the amount to burn
    function burn(address from, uint256 amount)
        external
        override
        onlyBurner
        returns (bool)
    {
        _burn(from, amount);
        return true;
    }

    /// @dev Authorizes the owner's token to be used by the spender as much as the value.
    /// @dev The signature must have the owner's signature.
    /// @param owner the token's owner
    /// @param spender the account that spend owner's token
    /// @param value the amount to be approve to spend
    /// @param deadline the deadline that valid the owner's signature
    /// @param v the owner's signature - v
    /// @param r the owner's signature - r
    /// @param s the owner's signature - s
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        require(deadline >= block.timestamp, "TOS: permit EXPIRED");

        bytes32 digest =
            hashPermit(owner, spender, value, deadline, nonces[owner]++);

        require(owner != spender, "TOS: approval to current owner");

        // if (Address.isContract(owner)) {
        //     require(IERC1271(owner).isValidSignature(digest, abi.encodePacked(r, s, v)) == 0x1626ba7e, 'Unauthorized');
        // } else {
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0), "TOS: Invalid signature");
        console.log("address: %s", recoveredAddress);
        require(recoveredAddress == owner, "TOS: Unauthorized");
        // }
        _approve(owner, spender, value);
    }

    /// @dev verify the signature
    /// @param owner the token's owner
    /// @param spender the account that spend owner's token
    /// @param value the amount to be approve to spend
    /// @param deadline the deadline that valid the owner's signature
    /// @param _nounce the _nounce
    /// @param sigR the owner's signature - r
    /// @param sigS the owner's signature - s
    /// @param sigV the owner's signature - v
    function verify(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint256 _nounce,
        bytes32 sigR,
        bytes32 sigS,
        uint8 sigV
    ) external view override returns (bool) {
        return
            owner ==
            ecrecover(
                hashPermit(owner, spender, value, deadline, _nounce),
                sigV,
                sigR,
                sigS
            );
    }

    /// @dev the hash of Permit
    /// @param owner the token's owner
    /// @param spender the account that spend owner's token
    /// @param value the amount to be approve to spend
    /// @param deadline the deadline that valid the owner's signature
    /// @param _nounce the _nounce
    function hashPermit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint256 _nounce
    ) public view override returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    "\x19\x01",
                    DOMAIN_SEPARATOR,
                    keccak256(
                        abi.encode(
                            PERMIT_TYPEHASH,
                            owner,
                            spender,
                            value,
                            _nounce,
                            deadline
                        )
                    )
                )
            );
    }
}


// File contracts/interfaces/IDepositManager.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

interface IDepositManager {
    function owner() external view returns (address);

    function wton() external view returns (address);

    function registry() external view returns (address);

    function seigManager() external view returns (address);

    function accStaked(address layer2, address account)
        external
        view
        returns (uint256 wtonAmount);

    function accStakedLayer2(address layer2)
        external
        view
        returns (uint256 wtonAmount);

    function accStakedAccount(address account)
        external
        view
        returns (uint256 wtonAmount);

    function pendingUnstaked(address layer2, address account)
        external
        view
        returns (uint256 wtonAmount);

    function pendingUnstakedLayer2(address layer2)
        external
        view
        returns (uint256 wtonAmount);

    function pendingUnstakedAccount(address account)
        external
        view
        returns (uint256 wtonAmount);

    function accUnstaked(address layer2, address account)
        external
        view
        returns (uint256 wtonAmount);

    function accUnstakedLayer2(address layer2)
        external
        view
        returns (uint256 wtonAmount);

    function accUnstakedAccount(address account)
        external
        view
        returns (uint256 wtonAmount);

    function withdrawalRequestIndex(address layer2, address account)
        external
        view
        returns (uint256 index);

    // solhint-disable-next-line max-line-length
    function withdrawalRequest(
        address layer2,
        address account,
        uint256 index
    )
        external
        view
        returns (
            uint128 withdrawableBlockNumber,
            uint128 amount,
            bool processed
        );

    function WITHDRAWAL_DELAY() external view returns (uint256);

    function deposit(address layer2, uint256 amount) external returns (bool);

    function requestWithdrawal(address layer2, uint256 amount)
        external
        returns (bool);

    function processRequest(address layer2, bool receiveTON)
        external
        returns (bool);

    function requestWithdrawalAll(address layer2) external returns (bool);

    function processRequests(address layer2, uint256 n) external returns (bool);

    function numRequests(address layer2, address account)
        external
        view
        returns (uint256);

    function numPendingRequests(address layer2, address account)
        external
        view
        returns (uint256);
}


// File contracts/interfaces/IDeveloperVault.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IDeveloperVault {
    /// @dev set initial storage
    /// @param _tos the TOS address
    /// @param _cap the allocated TOS amount to devs
    /// @param _rewardPeriod given only once per _rewardPeriod.
    /// @param _startRewardBlock the start block to give .
    /// @param _claimsNumberMax Total number of payments
    /// @param _developers the developer list
    /// @param _claimAmounts How much do you pay at one time?
    function initialize(
        address _tos,
        uint256 _cap,
        uint256 _rewardPeriod,
        uint256 _startRewardBlock,
        uint256 _claimsNumberMax,
        address[] memory _developers,
        uint256[] memory _claimAmounts
    ) external;

    /// @dev Developers can receive their TOSs
    function claimReward() external;

    /// @dev Returns current reward block for sender
    function currentRewardBlock() external view returns (uint256);
}


// File contracts/interfaces/ISeigManager.sol

// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

interface ISeigManager {
    function registry() external view returns (address);

    function depositManager() external view returns (address);

    function ton() external view returns (address);

    function wton() external view returns (address);

    function powerton() external view returns (address);

    function tot() external view returns (address);

    function coinages(address layer2) external view returns (address);

    function commissionRates(address layer2) external view returns (uint256);

    function lastCommitBlock(address layer2) external view returns (uint256);

    function seigPerBlock() external view returns (uint256);

    function lastSeigBlock() external view returns (uint256);

    function pausedBlock() external view returns (uint256);

    function unpausedBlock() external view returns (uint256);

    function DEFAULT_FACTOR() external view returns (uint256);

    function deployCoinage(address layer2) external returns (bool);

    function setCommissionRate(
        address layer2,
        uint256 commission,
        bool isCommissionRateNegative
    ) external returns (bool);

    function uncomittedStakeOf(address layer2, address account)
        external
        view
        returns (uint256);

    function stakeOf(address layer2, address account)
        external
        view
        returns (uint256);

    function additionalTotBurnAmount(
        address layer2,
        address account,
        uint256 amount
    ) external view returns (uint256 totAmount);

    function onTransfer(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    function updateSeigniorage() external returns (bool);

    function onDeposit(
        address layer2,
        address account,
        uint256 amount
    ) external returns (bool);

    function onWithdraw(
        address layer2,
        address account,
        uint256 amount
    ) external returns (bool);
}


// File contracts/interfaces/IStakeDefiFactory.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStakeDefiFactory {
    /// @dev Create a stake contract that can operate the staked amount as a DeFi project.
    /// @param _addr array of [token, paytoken, vault]
    /// @param _registry  registry address
    /// @param _intdata array of [saleStartBlock, startBlock, periodBlocks]
    /// @param owner  owner address
    /// @return contract address
    function create(
        address[4] calldata _addr,
        address _registry,
        uint256[3] calldata _intdata,
        address owner
    ) external returns (address);
}


// File contracts/interfaces/IStakeProxyStorage.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStakeProxyStorage {
    /// @dev TOS address
    function tos() external view returns (address);

    /// @dev TON address in Tokamak
    function ton() external view returns (address);

    /// @dev WTON address in Tokamak
    function wton() external view returns (address);

    /// @dev Depositmanager address in Tokamak
    function depositManager() external view returns (address);

    /// @dev SeigManager address in Tokamak
    function seigManager() external view returns (address);
}


// File contracts/interfaces/IStakeTONStorage.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

interface IStakeTONStorage {
    /// @dev TON address
    function ton() external view returns (address);

    /// @dev WTON address
    function wton() external view returns (address);

    /// @dev SeigManager address
    function seigManager() external view returns (address);

    /// @dev DepositManager address
    function depositManager() external view returns (address);

    /// @dev the layer2 address in Tokamak
    function tokamakLayer2() external view returns (address);

    /// @dev the accumulated TON amount staked into tokamak , in wei unit
    function toTokamak() external view returns (uint256);

    /// @dev the accumulated WTON amount unstaked from tokamak , in ray unit
    function fromTokamak() external view returns (uint256);

    /// @dev the accumulated WTON amount swapped using uniswap , in ray unit
    function toUniswapWTON() external view returns (uint256);

    /// @dev the TOS balance in this contract
    function swappedAmountTOS() external view returns (uint256);

    /// @dev the TON balance in this contract when withdraw at first
    function finalBalanceTON() external view returns (uint256);

    /// @dev the WTON balance in this contract when withdraw at first
    function finalBalanceWTON() external view returns (uint256);

    /// @dev defi status -> NONE, APPROVE,DEPOSITED,REQUESTWITHDRAW,REQUESTWITHDRAWALL,WITHDRAW,END
    function defiStatus() external view returns (uint256);

    /// @dev the withdraw flag, when withdraw at first, set true
    function withdrawFlag() external view returns (bool);
}


// File contracts/libraries/ChainId.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

/// @title Function for getting the current chain ID
library ChainId {
    /// @dev Gets the current chain ID
    /// @return chainId The current chain ID
    function get() internal pure returns (uint256 chainId) {
        assembly {
            chainId := chainid()
        }
    }
}


// File contracts/sale/ERC20/SafeMath.sol

// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}


// File contracts/sale/PrivateSale copy 2.sol

// // SPDX-License-Identifier: MIT

// pragma solidity ^0.7.6;

// import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
// import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
// import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
// import {
//     ReentrancyGuard
// } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
// import "@openzeppelin/contracts/math/SafeMath.sol";
// import "../interfaces/IWTON.sol";

// contract PrivateSale is Ownable, ReentrancyGuard {
//     using SafeERC20 for IERC20;
//     using SafeMath for uint256;

    
//     struct UserInfoAmount {
//         uint256 inputamount;
//         uint256 totaloutputamount;
//         uint256 inputTime;
//         uint256 monthlyReward;
//         uint256 firstReward;
//     }

//     struct UserInfoClaim {
//         uint256 claimTime;
//         uint256 claimAmount;
//         uint256 firstClaimAmount;
//         uint256 firstClaimTime;
//         bool first;
//     }

//     struct WhiteList {
//         uint256 amount;
//     }

//     event addList(
//         address account,
//         uint256 amount
//     );

//     event delList(
//         address account,
//         uint256 amount
//     );

//     event Buyinfo(
//         address user,
//         uint256 inputAmount,
//         uint256 totalOutPutamount,
//         uint256 inputTime,
//         uint256 monthlyReward,
//         uint256 firstReward
//     );

//     event FirstClaiminfo(
//         address user,
//         uint256 claimAmount,
//         uint256 claimTime
//     );

//     event Claiminfo(
//         address user,
//         uint256 claimAmount,
//         uint256 claimTime
//     );

//     event Withdrawinfo(
//         address user,
//         uint256 withdrawAmount
//     );
    
//     address public getTokenOwner;       //받은 ton을 받을 주소
//     uint256 public totalGetAmount;      //총 TON받은양
//     uint256 public totalSaleAmount;     //총 판매토큰

//     uint256 public saleStartTime;           //sale시작 시간
//     uint256 public saleEndTime;             //sale끝 시간

//     uint256 public firstClaimTime;           //초기 claim 시간

//     uint256 public claimStartTime;  //6개월 뒤 claim시작 시간
//     uint256 public claimEndTime;    //claim시작시간 + 1년

//     uint256 public saleTokenPrice;  //판매토큰가격
//     uint256 public getTokenPrice;   //받는토큰가격(TON)

//     IERC20 public saleToken;        //판매할 token주소
//     IERC20 public getToken;         //TON 주소

//     address public wton;             //WTON 주소

//     mapping (address => UserInfoAmount) public usersAmount;
//     mapping (address => UserInfoClaim) public usersClaim;
//     mapping (address => WhiteList) public usersWhite;


//     /// @dev basic setting
//     /// @param _wton wtonAddress
//     constructor(address _wton) {
//         wton = _wton;
//     }

//     /// @dev calculator the SaleAmount(input TON how many get the anotherToken)
//     /// @param _amount input the TON amount
//     function calculSaleToken(uint256 _amount)
//         public
//         view
//         returns (uint256)
//     {
//         uint256 tokenSaleAmount = _amount.mul(getTokenPrice).div(saleTokenPrice);
//         return tokenSaleAmount;
//     }

//     /// @dev calculator the getAmount(want to get _amount how many input the TON?)
//     /// @param _amount input the anotherTokenAmount
//     function calculGetToken(uint256 _amount)
//         public
//         view
//         returns (uint256)
//     {
//         uint256 tokenGetAmount = _amount.mul(saleTokenPrice).div(getTokenPrice);
//         return tokenGetAmount;
//     }

//     /// @dev address setting
//     /// @param _saleToken saleTokenAddress (contract have token)
//     /// @param _getToken getTokenAddress (TON)
//     /// @param _ownerToken get TON transfer to wallet
//     function addressSetting(
//         address _saleToken,
//         address _getToken,
//         address _ownerToken
//     ) external onlyOwner {
//         changeTokenAddress(_saleToken,_getToken);
//         changeGetAddress(_ownerToken);
//     }

//     function changeWTONAddress(address _wton) external onlyOwner {
//         wton = _wton;
//     }

//     function changeTokenAddress(address _saleToken, address _getToken) public onlyOwner {
//         saleToken = IERC20(_saleToken);
//         getToken = IERC20(_getToken);
//     }

//     function changeGetAddress(address _address) public onlyOwner {
//         getTokenOwner = _address;
//     }

//     function settingAll(
//         uint256[4] calldata _time,
//         uint256 _saleTokenPrice,
//         uint256 _getTokenPrice
//     ) external onlyOwner {
//         settingPrivateTime(_time[0],_time[1],_time[2],_time[3]);
//         setTokenPrice(_saleTokenPrice,_getTokenPrice);
//     }

//     function settingPrivateTime(
//         uint256 _startTime,
//         uint256 _endTime,
//         uint256 _firstTime,
//         uint256 _claimTime
//     ) public onlyOwner {
//         settingSaleTime(_startTime,_endTime);
//         settingFirstClaimTime(_firstTime);
//         settingClaimTime(_claimTime);
//     }

//     function settingSaleTime(uint256 _startTime,uint256 _endTime) public onlyOwner {
//         saleStartTime = _startTime;
//         saleEndTime = _endTime;
//     }

//     function settingFirstClaimTime(uint256 _claimTime) public onlyOwner {
//         firstClaimTime = _claimTime;
//     }

//     function settingClaimTime(uint256 _time) public onlyOwner {
//         claimStartTime = _time;
//         claimEndTime = _time.add(360 days);
//     }

//     function setTokenPrice(uint256 _saleTokenPrice, uint256 _getTokenPrice)
//         public
//         onlyOwner
//     {
//         saleTokenPrice = _saleTokenPrice;
//         getTokenPrice = _getTokenPrice;
//     }

//     function claimAmount(
//         address _account
//     ) external view returns (uint256) {
//         UserInfoAmount memory user = usersAmount[_account];

//         require(user.inputamount > 0, "user isn't buy");
//         require(block.timestamp > claimStartTime, "need to time for claim");
        
//         UserInfoClaim memory userclaim = usersClaim[msg.sender];

//         uint difftime = block.timestamp.sub(claimStartTime);
//         uint monthTime = 30 days;

//         if (difftime < monthTime) {
//             uint period = 1;
//             uint256 reward = (user.monthlyReward.mul(period)).sub(userclaim.claimAmount);
//             return reward;
//         } else {
//             uint period = (difftime.div(monthTime)).add(1);
//             if (period >= 12) {
//                 uint256 reward = user.totaloutputamount.sub(userclaim.claimAmount).sub(userclaim.firstClaimAmount);
//                 return reward; 
//             } else {
//                 uint256 reward = (user.monthlyReward.mul(period)).sub(userclaim.claimAmount);
//                 return reward;
//             }
//         }
//     }
    
//     function calculClaimAmount(
//         uint256 _nowtime, 
//         uint256 _preclaimamount,
//         uint256 _monthlyReward,
//         uint256 _usertotaloutput,
//         uint256 _firstReward
//     ) internal view returns (uint256) {
//         uint difftime = _nowtime.sub(claimStartTime);
//         uint monthTime = 30 days;

//         if (difftime < monthTime) {
//             uint period = 1;
//             uint256 reward = (_monthlyReward.mul(period)).sub(_preclaimamount);
//             return reward;
//         } else {
//             uint period = (difftime.div(monthTime)).add(1);
//             if (period >= 12) {
//                 uint256 reward = _usertotaloutput.sub(_preclaimamount).sub(_firstReward);
//                 return reward; 
//             } else {
//                 uint256 reward = (_monthlyReward.mul(period)).sub(_preclaimamount);
//                 return reward;
//             }
//         }
//     }

//     function _toRAY(uint256 v) internal pure returns (uint256) {
//         return v * 10 ** 9;
//     }
    
//     function addWhiteList(address _account,uint256 _amount) external onlyOwner {
//         WhiteList storage userwhite = usersWhite[_account];
//         userwhite.amount = userwhite.amount.add(_amount);

//         emit addList(_account, _amount);
//     }

//     function addWhiteListArray(address[] calldata _account, uint256[] calldata _amount) external onlyOwner {
//         for(uint i = 0; i < _account.length; i++) {
//             WhiteList storage userwhite = usersWhite[_account[i]];
//             userwhite.amount = userwhite.amount.add(_amount[i]);

//             emit addList(_account[i], _amount[i]);
//         }
//     }

//     function delWhiteList(address _account, uint256 _amount) external onlyOwner {
//         WhiteList storage userwhite = usersWhite[_account];
//         userwhite.amount = userwhite.amount.sub(_amount);

//         emit delList(_account, _amount);
//     }

//     function onApprove(
//         address owner,
//         address spender,
//         uint256 tonAmount,
//         bytes calldata data
//     ) external returns (bool) {
//         require(msg.sender == address(getToken) || msg.sender == address(IWTON(wton)), "PrivateSale: only accept TON and WTON approve callback");

//         // swap owner's TON to WTON
//         _swapFromTON(owner, owner, tonAmount);

//         uint256 wtonAmount = _toRAY(tonAmount);
//         (address depositManager, address layer2) = _decodeTONApproveData(data);

//         // approve WTON to DepositManager
//         _approve(owner, depositManager, wtonAmount);

//         // call DepositManager.onApprove to deposit WTON
//         bytes memory depositManagerOnApproveData = _encodeDepositManagerOnApproveData(layer2);
//         _callOnApprove(owner, depositManager, wtonAmount, depositManagerOnApproveData);

//         return true;
//     }

//     function buy(
//         uint256 _amount
//     ) external {
//         require(saleStartTime != 0 && saleEndTime != 0, "need to setting saleTime");
//         require(block.timestamp >= saleStartTime && block.timestamp <= saleEndTime, "privaSale period end");
//         WhiteList storage userwhite = usersWhite[msg.sender];
//         require(userwhite.amount >= _amount, "need to add whiteList amount");
//         _buy(_amount);
//         userwhite.amount = userwhite.amount.sub(_amount);
//     }

//     function _buy(
//         uint256 _amount
//     )
//         internal
//     {
//         UserInfoAmount storage user = usersAmount[msg.sender];

//         uint256 tokenSaleAmount = calculSaleToken(_amount);
//         uint256 Saledtoken = totalSaleAmount.add(tokenSaleAmount);
//         uint256 tokenBalance = saleToken.balanceOf(address(this));

//         require(
//             tokenBalance >= Saledtoken,
//             "don't have token amount"
//         );

//         uint256 tonAllowance = getToken.allowance(msg.sender, address(this));
//         uint256 tonBalance = getToken.balanceOf(msg.sender);

//         if(tonBalance < _amount) {
//             uint256 needUserWton;
//             uint256 needWton = _amount.sub(tonBalance);
//             needUserWton = _toRAY(needWton);
//             require(IWTON(wton).allowance(msg.sender, address(this)) >= needUserWton, "privateSale: wton amount exceeds allowance");
//             require(IWTON(wton).balanceOf(msg.sender) >= needUserWton, "need more wton");
//             IERC20(wton).safeTransferFrom(msg.sender,address(this),needUserWton);
//             IWTON(wton).swapToTON(needUserWton);
//             require(tonAllowance >= _amount.sub(needWton), "privateSale: ton amount exceeds allowance");
//             if(_amount.sub(needWton) > 0) {
//                 getToken.safeTransferFrom(msg.sender, address(this), _amount.sub(needWton));   
//             }
//             getToken.safeTransfer(getTokenOwner, _amount);
//         } else {
//             require(tonAllowance >= _amount, "privateSale: ton amount exceeds allowance");

//             getToken.safeTransferFrom(msg.sender, address(this), _amount);
//             getToken.safeTransfer(getTokenOwner, _amount);
//         }

//         user.inputamount = user.inputamount.add(_amount);
//         user.totaloutputamount = user.totaloutputamount.add(tokenSaleAmount);
//         user.firstReward = user.totaloutputamount.mul(5).div(100);
//         user.monthlyReward = (user.totaloutputamount.sub(user.firstReward)).div(12);
//         user.inputTime = block.timestamp;

//         totalGetAmount = totalGetAmount.add(_amount);
//         totalSaleAmount = totalSaleAmount.add(tokenSaleAmount);

//         emit Buyinfo(
//             msg.sender, 
//             user.inputamount, 
//             user.totaloutputamount,
//             user.inputTime,
//             user.monthlyReward,
//             user.firstReward
//         );
//     }

//     function claim() external {
//         require(firstClaimTime != 0 && saleEndTime != 0, "need to setting Time");
//         require(block.timestamp > saleEndTime && block.timestamp > firstClaimTime, "need the fisrClaimtime");
//         if(block.timestamp < claimStartTime) {
//             firstClaim();
//         } else if(claimStartTime < block.timestamp){
//             _claim();
//         }
//     }


//     function firstClaim() public {
//         UserInfoAmount storage user = usersAmount[msg.sender];
//         UserInfoClaim storage userclaim = usersClaim[msg.sender];

//         require(user.inputamount > 0, "need to buy the token");
//         require(userclaim.firstClaimAmount == 0, "already getFirstreward");

//         userclaim.firstClaimAmount = userclaim.firstClaimAmount.add(user.firstReward);
//         userclaim.firstClaimTime = block.timestamp;

//         saleToken.safeTransfer(msg.sender, user.firstReward);

//         emit FirstClaiminfo(msg.sender, userclaim.firstClaimAmount, userclaim.firstClaimTime);
//     }

//     function _claim() public {
//         require(block.timestamp >= claimStartTime, "need the time for claim");

//         UserInfoAmount storage user = usersAmount[msg.sender];
//         UserInfoClaim storage userclaim = usersClaim[msg.sender];

//         require(user.inputamount > 0, "need to buy the token");
//         require(!(user.totaloutputamount == (userclaim.claimAmount.add(userclaim.firstClaimAmount))), "already getAllreward");

//         if(userclaim.firstClaimAmount == 0) {
//             firstClaim();
//         }

//         uint256 giveTokenAmount = calculClaimAmount(block.timestamp, userclaim.claimAmount, user.monthlyReward, user.totaloutputamount, userclaim.firstClaimAmount);
    
//         require(user.totaloutputamount.sub(userclaim.claimAmount) >= giveTokenAmount, "user is already getAllreward");
//         require(saleToken.balanceOf(address(this)) >= giveTokenAmount, "dont have saleToken in pool");

//         userclaim.claimAmount = userclaim.claimAmount.add(giveTokenAmount);
//         userclaim.claimTime = block.timestamp;

//         saleToken.safeTransfer(msg.sender, giveTokenAmount);

//         emit Claiminfo(msg.sender, userclaim.claimAmount, userclaim.claimTime);
//     }


//     function withdraw(uint256 _amount) external onlyOwner {
//         require(
//             saleToken.balanceOf(address(this)) >= _amount,
//             "dont have token amount"
//         );
//         saleToken.safeTransfer(msg.sender, _amount);

//         emit Withdrawinfo(msg.sender, _amount);
//     }

// }


// File contracts/sale/PrivateSale copy1222.sol

// // SPDX-License-Identifier: MIT

// pragma solidity ^0.7.6;

// import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
// import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
// import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
// import {
//     ReentrancyGuard
// } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
// import "@openzeppelin/contracts/math/SafeMath.sol";
// import "../interfaces/IWTON.sol";

// import { OnApprove } from "./OnApprove.sol";


// contract PrivateSale is Ownable, ReentrancyGuard, OnApprove {
//     using SafeERC20 for IERC20;
//     using SafeMath for uint256;

    
//     struct UserInfoAmount {
//         uint256 inputamount;
//         uint256 totaloutputamount;
//         uint256 inputTime;
//         uint256 monthlyReward;
//         uint256 firstReward;
//     }

//     struct UserInfoClaim {
//         uint256 claimTime;
//         uint256 claimAmount;
//         uint256 firstClaimAmount;
//         uint256 firstClaimTime;
//         bool first;
//     }

//     struct WhiteList {
//         uint256 amount;
//     }

//     event addList(
//         address account,
//         uint256 amount
//     );

//     event delList(
//         address account,
//         uint256 amount
//     );

//     event Buyinfo(
//         address user,
//         uint256 inputAmount,
//         uint256 totalOutPutamount,
//         uint256 inputTime,
//         uint256 monthlyReward,
//         uint256 firstReward
//     );

//     event FirstClaiminfo(
//         address user,
//         uint256 claimAmount,
//         uint256 claimTime
//     );

//     event Claiminfo(
//         address user,
//         uint256 claimAmount,
//         uint256 claimTime
//     );

//     event Withdrawinfo(
//         address user,
//         uint256 withdrawAmount
//     );
    
//     address public getTokenOwner;       //받은 ton을 받을 주소
//     uint256 public totalGetAmount;      //총 TON받은양
//     uint256 public totalSaleAmount;     //총 판매토큰

//     uint256 public saleStartTime;           //sale시작 시간
//     uint256 public saleEndTime;             //sale끝 시간

//     uint256 public firstClaimTime;           //초기 claim 시간

//     uint256 public claimStartTime;  //6개월 뒤 claim시작 시간
//     uint256 public claimEndTime;    //claim시작시간 + 1년

//     uint256 public saleTokenPrice;  //판매토큰가격
//     uint256 public getTokenPrice;   //받는토큰가격(TON)

//     IERC20 public saleToken;        //판매할 token주소
//     IERC20 public getToken;         //TON 주소

//     address public wton;             //WTON 주소

//     mapping (address => UserInfoAmount) public usersAmount;
//     mapping (address => UserInfoClaim) public usersClaim;
//     mapping (address => WhiteList) public usersWhite;


//     /// @dev basic setting
//     /// @param _wton wtonAddress
//     constructor(address _wton) {
//         wton = _wton;
//     }

//     /// @dev calculator the SaleAmount(input TON how many get the anotherToken)
//     /// @param _amount input the TON amount
//     function calculSaleToken(uint256 _amount)
//         public
//         view
//         returns (uint256)
//     {
//         uint256 tokenSaleAmount = _amount.mul(getTokenPrice).div(saleTokenPrice);
//         return tokenSaleAmount;
//     }

//     /// @dev calculator the getAmount(want to get _amount how many input the TON?)
//     /// @param _amount input the anotherTokenAmount
//     function calculGetToken(uint256 _amount)
//         public
//         view
//         returns (uint256)
//     {
//         uint256 tokenGetAmount = _amount.mul(saleTokenPrice).div(getTokenPrice);
//         return tokenGetAmount;
//     }

//     /// @dev address setting
//     /// @param _saleToken saleTokenAddress (contract have token)
//     /// @param _getToken getTokenAddress (TON)
//     /// @param _ownerToken get TON transfer to wallet
//     function addressSetting(
//         address _saleToken,
//         address _getToken,
//         address _ownerToken
//     ) external onlyOwner {
//         changeTokenAddress(_saleToken,_getToken);
//         changeGetAddress(_ownerToken);
//     }

//     function changeWTONAddress(address _wton) external onlyOwner {
//         wton = _wton;
//     }

//     function changeTokenAddress(address _saleToken, address _getToken) public onlyOwner {
//         saleToken = IERC20(_saleToken);
//         getToken = IERC20(_getToken);
//     }

//     function changeGetAddress(address _address) public onlyOwner {
//         getTokenOwner = _address;
//     }

//     function settingAll(
//         uint256[4] calldata _time,
//         uint256 _saleTokenPrice,
//         uint256 _getTokenPrice
//     ) external onlyOwner {
//         settingPrivateTime(_time[0],_time[1],_time[2],_time[3]);
//         setTokenPrice(_saleTokenPrice,_getTokenPrice);
//     }

//     function settingPrivateTime(
//         uint256 _startTime,
//         uint256 _endTime,
//         uint256 _firstTime,
//         uint256 _claimTime
//     ) public onlyOwner {
//         settingSaleTime(_startTime,_endTime);
//         settingFirstClaimTime(_firstTime);
//         settingClaimTime(_claimTime);
//     }

//     function settingSaleTime(uint256 _startTime,uint256 _endTime) public onlyOwner {
//         saleStartTime = _startTime;
//         saleEndTime = _endTime;
//     }

//     function settingFirstClaimTime(uint256 _claimTime) public onlyOwner {
//         firstClaimTime = _claimTime;
//     }

//     function settingClaimTime(uint256 _time) public onlyOwner {
//         claimStartTime = _time;
//         claimEndTime = _time.add(360 days);
//     }

//     function setTokenPrice(uint256 _saleTokenPrice, uint256 _getTokenPrice)
//         public
//         onlyOwner
//     {
//         saleTokenPrice = _saleTokenPrice;
//         getTokenPrice = _getTokenPrice;
//     }

//     function claimAmount(
//         address _account
//     ) external view returns (uint256) {
//         UserInfoAmount memory user = usersAmount[_account];

//         require(user.inputamount > 0, "user isn't buy");
//         require(block.timestamp > claimStartTime, "need to time for claim");
        
//         UserInfoClaim memory userclaim = usersClaim[msg.sender];

//         uint difftime = block.timestamp.sub(claimStartTime);
//         uint monthTime = 30 days;

//         if (difftime < monthTime) {
//             uint period = 1;
//             uint256 reward = (user.monthlyReward.mul(period)).sub(userclaim.claimAmount);
//             return reward;
//         } else {
//             uint period = (difftime.div(monthTime)).add(1);
//             if (period >= 12) {
//                 uint256 reward = user.totaloutputamount.sub(userclaim.claimAmount).sub(userclaim.firstClaimAmount);
//                 return reward; 
//             } else {
//                 uint256 reward = (user.monthlyReward.mul(period)).sub(userclaim.claimAmount);
//                 return reward;
//             }
//         }
//     }
    
//     function calculClaimAmount(
//         uint256 _nowtime, 
//         uint256 _preclaimamount,
//         uint256 _monthlyReward,
//         uint256 _usertotaloutput,
//         uint256 _firstReward
//     ) internal view returns (uint256) {
//         uint difftime = _nowtime.sub(claimStartTime);
//         uint monthTime = 30 days;

//         if (difftime < monthTime) {
//             uint period = 1;
//             uint256 reward = (_monthlyReward.mul(period)).sub(_preclaimamount);
//             return reward;
//         } else {
//             uint period = (difftime.div(monthTime)).add(1);
//             if (period >= 12) {
//                 uint256 reward = _usertotaloutput.sub(_preclaimamount).sub(_firstReward);
//                 return reward; 
//             } else {
//                 uint256 reward = (_monthlyReward.mul(period)).sub(_preclaimamount);
//                 return reward;
//             }
//         }
//     }

//     /**
//      * @dev transform WAD to RAY
//      */
//     function _toRAY(uint256 v) internal pure returns (uint256) {
//         return v * 10 ** 9;
//     }

//     /**
//      * @dev transform RAY to WAD
//      */
//     function _toWAD(uint256 v) internal pure returns (uint256) {
//         return v / 10 ** 9;
//     }
    
//     function addWhiteList(address _account,uint256 _amount) external onlyOwner {
//         WhiteList storage userwhite = usersWhite[_account];
//         userwhite.amount = userwhite.amount.add(_amount);

//         emit addList(_account, _amount);
//     }

//     function addWhiteListArray(address[] calldata _account, uint256[] calldata _amount) external onlyOwner {
//         for(uint i = 0; i < _account.length; i++) {
//             WhiteList storage userwhite = usersWhite[_account[i]];
//             userwhite.amount = userwhite.amount.add(_amount[i]);

//             emit addList(_account[i], _amount[i]);
//         }
//     }

//     function delWhiteList(address _account, uint256 _amount) external onlyOwner {
//         WhiteList storage userwhite = usersWhite[_account];
//         userwhite.amount = userwhite.amount.sub(_amount);

//         emit delList(_account, _amount);
//     }

//     function onApprove(
//         address sender,
//         address spender,
//         uint256 amount,
//         bytes calldata data
//     ) external override returns (bool) {
//         require(msg.sender == address(getToken) || msg.sender == address(IWTON(wton)), "PrivateSale: only accept TON and WTON approve callback");
//         if(msg.sender == address(getToken)) {
//             uint256 wtonAmount = _decodeApproveData(data);
//             if(wtonAmount == 0){
//                 buy(sender,amount);
//             } else {
//                 uint256 totalAmount = amount + wtonAmount;
//                 buy(sender,totalAmount);
//             }
//         } else if (msg.sender == address(IWTON(wton))) {
//             uint256 wtonAmount = _toWAD(amount);
//             buy(sender,wtonAmount);
//         }

//         return true;
//     }

//     function _decodeApproveData(
//         bytes memory data
//     ) public pure returns (uint256 approveData) {
//         assembly {
//             approveData := mload(add(data, 0x20))
//         }
//     }

//     function buy(
//         address _sender,
//         uint256 _amount
//     ) public {
//         require(saleStartTime != 0 && saleEndTime != 0, "need to setting saleTime");
//         require(block.timestamp >= saleStartTime && block.timestamp <= saleEndTime, "privaSale period end");
//         WhiteList storage userwhite = usersWhite[_sender];
//         require(userwhite.amount >= _amount, "need to add whiteList amount");
//         _buy(_sender,_amount);
//         userwhite.amount = userwhite.amount.sub(_amount);
//     }

//     function _buy(
//         address _sender,
//         uint256 _amount
//     )
//         internal
//     {
//         UserInfoAmount storage user = usersAmount[_sender];

//         uint256 tokenSaleAmount = calculSaleToken(_amount);
//         uint256 Saledtoken = totalSaleAmount.add(tokenSaleAmount);
//         uint256 tokenBalance = saleToken.balanceOf(address(this));

//         require(
//             tokenBalance >= Saledtoken,
//             "don't have token amount"
//         );

//         uint256 tonAllowance = getToken.allowance(_sender, address(this));
//         uint256 tonBalance = getToken.balanceOf(_sender);
//         if(tonAllowance > tonBalance) {
//             tonAllowance = tonBalance;  //tonAllowance가 tonBlance보다 더 클때 문제가 된다.
//         }
//         if(tonAllowance < _amount) {
//             uint256 needUserWton;
//             uint256 needWton = _amount.sub(tonAllowance);
//             needUserWton = _toRAY(needWton);
//             require(IWTON(wton).allowance(_sender, address(this)) >= needUserWton, "privateSale: wton amount exceeds allowance");
//             require(IWTON(wton).balanceOf(_sender) >= needUserWton, "need more wton");
//             IERC20(wton).safeTransferFrom(_sender,address(this),needUserWton);
//             IWTON(wton).swapToTON(needUserWton);
//             require(tonAllowance >= _amount.sub(needWton), "privateSale: ton amount exceeds allowance");
//             if(_amount.sub(needWton) > 0) {
//                 getToken.safeTransferFrom(_sender, address(this), _amount.sub(needWton));   
//             }
//             getToken.safeTransfer(getTokenOwner, _amount);
//         } else {
//             require(tonAllowance >= _amount && tonBalance >= _amount, "privateSale: ton amount exceeds allowance");

//             getToken.safeTransferFrom(_sender, address(this), _amount);
//             getToken.safeTransfer(getTokenOwner, _amount);
//         }

//         user.inputamount = user.inputamount.add(_amount);
//         user.totaloutputamount = user.totaloutputamount.add(tokenSaleAmount);
//         user.firstReward = user.totaloutputamount.mul(5).div(100);
//         user.monthlyReward = (user.totaloutputamount.sub(user.firstReward)).div(12);
//         user.inputTime = block.timestamp;

//         totalGetAmount = totalGetAmount.add(_amount);
//         totalSaleAmount = totalSaleAmount.add(tokenSaleAmount);

//         emit Buyinfo(
//             msg.sender, 
//             user.inputamount, 
//             user.totaloutputamount,
//             user.inputTime,
//             user.monthlyReward,
//             user.firstReward
//         );
//     }

//     function claim() external {
//         require(firstClaimTime != 0 && saleEndTime != 0, "need to setting Time");
//         require(block.timestamp > saleEndTime && block.timestamp > firstClaimTime, "need the fisrClaimtime");
//         if(block.timestamp < claimStartTime) {
//             firstClaim();
//         } else if(claimStartTime < block.timestamp){
//             _claim();
//         }
//     }


//     function firstClaim() public {
//         UserInfoAmount storage user = usersAmount[msg.sender];
//         UserInfoClaim storage userclaim = usersClaim[msg.sender];

//         require(user.inputamount > 0, "need to buy the token");
//         require(userclaim.firstClaimAmount == 0, "already getFirstreward");

//         userclaim.firstClaimAmount = userclaim.firstClaimAmount.add(user.firstReward);
//         userclaim.firstClaimTime = block.timestamp;

//         saleToken.safeTransfer(msg.sender, user.firstReward);

//         emit FirstClaiminfo(msg.sender, userclaim.firstClaimAmount, userclaim.firstClaimTime);
//     }

//     function _claim() public {
//         require(block.timestamp >= claimStartTime, "need the time for claim");

//         UserInfoAmount storage user = usersAmount[msg.sender];
//         UserInfoClaim storage userclaim = usersClaim[msg.sender];

//         require(user.inputamount > 0, "need to buy the token");
//         require(!(user.totaloutputamount == (userclaim.claimAmount.add(userclaim.firstClaimAmount))), "already getAllreward");

//         if(userclaim.firstClaimAmount == 0) {
//             firstClaim();
//         }

//         uint256 giveTokenAmount = calculClaimAmount(block.timestamp, userclaim.claimAmount, user.monthlyReward, user.totaloutputamount, userclaim.firstClaimAmount);
    
//         require(user.totaloutputamount.sub(userclaim.claimAmount) >= giveTokenAmount, "user is already getAllreward");
//         require(saleToken.balanceOf(address(this)) >= giveTokenAmount, "dont have saleToken in pool");

//         userclaim.claimAmount = userclaim.claimAmount.add(giveTokenAmount);
//         userclaim.claimTime = block.timestamp;

//         saleToken.safeTransfer(msg.sender, giveTokenAmount);

//         emit Claiminfo(msg.sender, userclaim.claimAmount, userclaim.claimTime);
//     }


//     function withdraw(uint256 _amount) external onlyOwner {
//         require(
//             saleToken.balanceOf(address(this)) >= _amount,
//             "dont have token amount"
//         );
//         saleToken.safeTransfer(msg.sender, _amount);

//         emit Withdrawinfo(msg.sender, _amount);
//     }

// }


// File contracts/sale/PublicSale (mainnet).sol

// // SPDX-License-Identifier: MIT

// pragma solidity ^0.7.6;

// import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
// import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
// import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
// import {
//     ReentrancyGuard
// } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
// import "@openzeppelin/contracts/math/SafeMath.sol";
// import "../interfaces/ILockTOS.sol";
// import "../interfaces/IPublicSale.sol";
// import "../interfaces/IWTON.sol";
// import "../common/AccessibleCommon.sol";
// import "./PublicSaleStorage.sol";

// contract PublicSale is
//     PublicSaleStorage,
//     AccessibleCommon,
//     ReentrancyGuard,
//     IPublicSale
// {
//     using SafeERC20 for IERC20;
//     using SafeMath for uint256;

//     event AddedWhiteList(address indexed from, uint256 tier);
//     event ExclusiveSaled(address indexed from, uint256 amount);
//     event Deposited(address indexed from, uint256 amount);

//     event Claimed(address indexed from, uint256 amount);
//     event Withdrawal(address indexed from, uint256 amount);
//     event DepositWithdrawal(address indexed from, uint256 amount);

//     modifier nonZero(uint256 _value) {
//         require(_value > 0, "PublicSale: zero");
//         _;
//     }

//     modifier nonZeroAddress(address _addr) {
//         require(_addr != address(0), "PublicSale: zero address");
//         _;
//     }

//     modifier beforeStartAddWhiteTime() {
//         require(
//             startAddWhiteTime == 0 ||
//                 (startAddWhiteTime > 0 && block.timestamp < startAddWhiteTime),
//             "PublicSale: not beforeStartAddWhiteTime"
//         );
//         _;
//     }

//     modifier beforeEndAddWhiteTime() {
//         require(
//             endAddWhiteTime == 0 ||
//                 (endAddWhiteTime > 0 && block.timestamp < endAddWhiteTime),
//             "PublicSale: not beforeEndAddWhiteTime"
//         );
//         _;
//     }

//     modifier greaterThan(uint256 _value1, uint256 _value2) {
//         require(_value1 > _value2, "PublicSale: non greaterThan");
//         _;
//     }

//     modifier lessThan(uint256 _value1, uint256 _value2) {
//         require(_value1 < _value2, "PublicSale: non less than");
//         _;
//     }

//     /// @inheritdoc IPublicSale
//     function changeTONOwner(address _address) external override onlyOwner {
//         getTokenOwner = _address;
//     }

//     /// @inheritdoc IPublicSale
//     function setAllValue(
//         uint256 _snapshot,
//         uint256[4] calldata _exclusiveTime,
//         uint256[2] calldata _openSaleTime,
//         uint256[4] calldata _claimTime
//     ) external override onlyOwner beforeStartAddWhiteTime {
//         require(
//             (_exclusiveTime[0] < _exclusiveTime[1]) &&
//                 (_exclusiveTime[2] < _exclusiveTime[3])
//         );
//         require(
//             (_openSaleTime[0] < _openSaleTime[1])
//         );
//         setSnapshot(_snapshot);
//         setExclusiveTime(
//             _exclusiveTime[0],
//             _exclusiveTime[1],
//             _exclusiveTime[2],
//             _exclusiveTime[3]
//         );
//         setOpenTime(
//             _openSaleTime[0],
//             _openSaleTime[1]
//         );
//         setClaim(
//             _claimTime[0],
//             _claimTime[1],
//             _claimTime[2],
//             _claimTime[3]
//         );
//     }

//     /// @inheritdoc IPublicSale
//     function setSnapshot(uint256 _snapshot)
//         public
//         override
//         onlyOwner
//         nonZero(_snapshot)
//     {
//         snapshot = _snapshot;
//     }

//     /// @inheritdoc IPublicSale
//     function setExclusiveTime(
//         uint256 _startAddWhiteTime,
//         uint256 _endAddWhiteTime,
//         uint256 _startExclusiveTime,
//         uint256 _endExclusiveTime
//     )
//         public
//         override
//         onlyOwner
//         nonZero(_startAddWhiteTime)
//         nonZero(_endAddWhiteTime)
//         nonZero(_startExclusiveTime)
//         nonZero(_endExclusiveTime)
//         beforeStartAddWhiteTime
//     {
//         startAddWhiteTime = _startAddWhiteTime;
//         endAddWhiteTime = _endAddWhiteTime;
//         startExclusiveTime = _startExclusiveTime;
//         endExclusiveTime = _endExclusiveTime;
//     }

//     /// @inheritdoc IPublicSale
//     function setOpenTime(
//         uint256 _startDepositTime,
//         uint256 _endDepositTime
//     )
//         public
//         override
//         onlyOwner
//         nonZero(_startDepositTime)
//         nonZero(_endDepositTime)
//         beforeStartAddWhiteTime
//     {
//         startDepositTime = _startDepositTime;
//         endDepositTime = _endDepositTime;
//     }

//     /// @inheritdoc IPublicSale
//     function setClaim(
//         uint256 _startClaimTime,
//         uint256 _claimInterval,
//         uint256 _claimPeriod,
//         uint256 _claimFirst
//     )
//         public
//         override
//         onlyOwner
//         nonZero(_startClaimTime)
//         nonZero(_claimInterval)
//         nonZero(_claimPeriod)
//         beforeStartAddWhiteTime
//     {
//         startClaimTime = _startClaimTime;
//         claimInterval = _claimInterval;
//         claimPeriod = _claimPeriod;
//         claimFirst = _claimFirst;
//     }

//     /// @inheritdoc IPublicSale
//     function setAllTier(
//         uint256[4] calldata _tier,
//         uint256[4] calldata _tierPercent
//     ) external override onlyOwner {
//         setTier(
//             _tier[0],
//             _tier[1],
//             _tier[2],
//             _tier[3]
//         );
//         setTierPercents(
//             _tierPercent[0],
//             _tierPercent[1],
//             _tierPercent[2],
//             _tierPercent[3]
//         );
//     }

//     /// @inheritdoc IPublicSale
//     function setTier(
//         uint256 _tier1,
//         uint256 _tier2,
//         uint256 _tier3,
//         uint256 _tier4
//     )
//         public
//         override
//         onlyOwner
//         nonZero(_tier1)
//         nonZero(_tier2)
//         nonZero(_tier3)
//         nonZero(_tier4)
//         beforeStartAddWhiteTime
//     {
//         tiers[1] = _tier1;
//         tiers[2] = _tier2;
//         tiers[3] = _tier3;
//         tiers[4] = _tier4;
//     }

//     /// @inheritdoc IPublicSale
//     function setTierPercents(
//         uint256 _tier1,
//         uint256 _tier2,
//         uint256 _tier3,
//         uint256 _tier4
//     )
//         public
//         override
//         onlyOwner
//         nonZero(_tier1)
//         nonZero(_tier2)
//         nonZero(_tier3)
//         nonZero(_tier4)
//         beforeStartAddWhiteTime
//     {
//         require(
//             _tier1.add(_tier2).add(_tier3).add(_tier4) == 10000,
//             "PublicSale: Sum should be 10000"
//         );
//         tiersPercents[1] = _tier1;
//         tiersPercents[2] = _tier2;
//         tiersPercents[3] = _tier3;
//         tiersPercents[4] = _tier4;
//     }

//     /// @inheritdoc IPublicSale
//     function setAllAmount(
//         uint256[2] calldata _expectAmount,
//         uint256[2] calldata _priceAmount
//     ) external override onlyOwner {
//         setSaleAmount(
//             _expectAmount[0],
//             _expectAmount[1]
//         );
//         setTokenPrice(
//             _priceAmount[0],
//             _priceAmount[1]
//         );
//     }

//     /// @inheritdoc IPublicSale
//     function setSaleAmount(
//         uint256 _totalExpectSaleAmount,
//         uint256 _totalExpectOpenSaleAmount
//     )
//         public
//         override
//         onlyOwner
//         nonZero(_totalExpectSaleAmount.add(_totalExpectOpenSaleAmount))
//         beforeStartAddWhiteTime
//     {
//         totalExpectSaleAmount = _totalExpectSaleAmount;
//         totalExpectOpenSaleAmount = _totalExpectOpenSaleAmount;
//     }

//     /// @inheritdoc IPublicSale
//     function setTokenPrice(uint256 _saleTokenPrice, uint256 _payTokenPrice)
//         public
//         override
//         onlyOwner
//         nonZero(_saleTokenPrice)
//         nonZero(_payTokenPrice)
//         beforeStartAddWhiteTime
//     {
//         saleTokenPrice = _saleTokenPrice;
//         payTokenPrice = _payTokenPrice;
//     }

//     /// @inheritdoc IPublicSale
//     function totalExpectOpenSaleAmountView() public view override returns(uint256){
//         if(block.timestamp < endExclusiveTime) return totalExpectOpenSaleAmount;
//         else return totalExpectOpenSaleAmount.add(totalRound1NonSaleAmount());
//     }

//     /// @inheritdoc IPublicSale
//     function totalRound1NonSaleAmount() public view override returns(uint256){
//         return totalExpectSaleAmount.sub(totalExSaleAmount);
//     }


//     function _toRAY(uint256 v) internal pure returns (uint256) {
//         return v * 10 ** 9;
//     }

//     /// @inheritdoc IPublicSale
//     function calculSaleToken(uint256 _amount)
//         public
//         view
//         override
//         returns (uint256)
//     {
//         uint256 tokenSaleAmount =
//             _amount.mul(payTokenPrice).div(saleTokenPrice);
//         return tokenSaleAmount;
//     }

//     /// @inheritdoc IPublicSale
//     function calculPayToken(uint256 _amount)
//         public
//         view
//         override
//         returns (uint256)
//     {
//         uint256 tokenPayAmount = _amount.mul(saleTokenPrice).div(payTokenPrice);
//         return tokenPayAmount;
//     }

//     /// @inheritdoc IPublicSale
//     function calculTier(address _address)
//         public
//         view
//         override
//         nonZeroAddress(address(sTOS))
//         nonZero(tiers[1])
//         nonZero(tiers[2])
//         nonZero(tiers[3])
//         nonZero(tiers[4])
//         returns (uint256)
//     {
//         uint256 sTOSBalance = sTOS.balanceOfAt(_address, snapshot);
//         uint256 tier;
//         if (sTOSBalance >= tiers[1] && sTOSBalance < tiers[2]) {
//             tier = 1;
//         } else if (sTOSBalance >= tiers[2] && sTOSBalance < tiers[3]) {
//             tier = 2;
//         } else if (sTOSBalance >= tiers[3] && sTOSBalance < tiers[4]) {
//             tier = 3;
//         } else if (sTOSBalance >= tiers[4]) {
//             tier = 4;
//         } else if (sTOSBalance < tiers[1]) {
//             tier = 0;
//         }
//         return tier;
//     }

//     /// @inheritdoc IPublicSale
//     function calculTierAmount(address _address)
//         public
//         view
//         override
//         returns (uint256)
//     {
//         UserInfoEx storage userEx = usersEx[_address];
//         uint256 tier = calculTier(_address);
//         if (userEx.join == true && tier > 0) {
//             uint256 salePossible =
//                 totalExpectSaleAmount
//                     .mul(tiersPercents[tier])
//                     .div(tiersAccount[tier])
//                     .div(10000);
//             return salePossible;
//         } else if (tier > 0) {
//             uint256 tierAccount = tiersAccount[tier].add(1);
//             uint256 salePossible =
//                 totalExpectSaleAmount
//                     .mul(tiersPercents[tier])
//                     .div(tierAccount)
//                     .div(10000);
//             return salePossible;
//         } else {
//             return 0;
//         }
//     }

//     /// @inheritdoc IPublicSale
//     function calculOpenSaleAmount(address _account, uint256 _amount)
//         public
//         view
//         override
//         returns (uint256)
//     {
//         UserInfoOpen storage userOpen = usersOpen[_account];
//         uint256 depositAmount = userOpen.depositAmount.add(_amount);
//         uint256 openSalePossible =
//             totalExpectOpenSaleAmountView().mul(depositAmount).div(
//                 totalDepositAmount.add(_amount)
//             );
//         return openSalePossible;
//     }

//     /// @inheritdoc IPublicSale
//     function calculClaimAmount(address _account, uint256 _period)
//         public
//         view
//         override
//         returns (uint256 _reward, uint256 _totalClaim)
//     {
//         if(block.timestamp < startClaimTime) return (0, 0);
//         if(_period > claimPeriod) return (0,0);

//         UserClaim storage userClaim = usersClaim[_account];
//         (, uint256 realSaleAmount, ) = totalSaleUserAmount(_account);

//         if (realSaleAmount == 0 ) return (0, 0);
//         if (userClaim.claimAmount >= realSaleAmount) return (0, realSaleAmount);

//         uint256 difftime = block.timestamp.sub(startClaimTime);
//         uint256 totalClaimReward = realSaleAmount;
//         uint256 firstReward = totalClaimReward.mul(claimFirst).div(100);
//         uint256 periodReward = (totalClaimReward.sub(firstReward)).div(claimPeriod.sub(1));

//         if(_period == 0) {
//             if (difftime < claimInterval) {
//                 uint256 reward = firstReward.sub(userClaim.claimAmount);
//                 return (reward, totalClaimReward);
//             } else {
//                 uint256 period = (difftime / claimInterval).add(1);
//                 if (period >= claimPeriod) {
//                     uint256 reward =
//                         totalClaimReward.sub(userClaim.claimAmount);
//                     return (reward, totalClaimReward);
//                 } else {
//                     uint256 reward = firstReward.add(periodReward.mul(period.sub(1))).sub(userClaim.claimAmount);
//                     return (reward, totalClaimReward);
//                 }
//             }
//         } else if(_period == 1){
//             return (firstReward, totalClaimReward);
//         } else {
//             if(_period == claimPeriod) {
//                 uint256 reward =
//                     totalClaimReward.sub((firstReward.add(periodReward.mul(claimPeriod.sub(2)))));
//                 return (reward, totalClaimReward);
//             } else {
//                 return (periodReward, totalClaimReward);
//             }
//         }
//     }

//     /// @inheritdoc IPublicSale
//     function totalSaleUserAmount(address user) public override view returns (uint256 _realPayAmount, uint256 _realSaleAmount, uint256 _refundAmount) {
//         UserInfoEx storage userEx = usersEx[user];

//         if(userEx.join){
//             (uint256 realPayAmount, uint256 realSaleAmount, uint256 refundAmount) = openSaleUserAmount(user);
//             return ( realPayAmount.add(userEx.payAmount), realSaleAmount.add(userEx.saleAmount), refundAmount);
//         }else {
//             return openSaleUserAmount(user);
//         }
//     }

//     /// @inheritdoc IPublicSale
//     function openSaleUserAmount(address user) public override view returns (uint256 _realPayAmount, uint256 _realSaleAmount, uint256 _refundAmount) {
//         UserInfoOpen storage userOpen = usersOpen[user];

//         if(!userOpen.join || userOpen.depositAmount == 0) return (0, 0, 0);

//         uint256 openSalePossible = calculOpenSaleAmount(user, 0);
//         uint256 realPayAmount = calculPayToken(openSalePossible);
//         uint256 depositAmount = userOpen.depositAmount;
//         uint256 realSaleAmount = 0;
//         uint256 returnAmount = 0;

//         if (realPayAmount < depositAmount) {
//            returnAmount = depositAmount.sub(realPayAmount);
//            realSaleAmount = calculSaleToken(realPayAmount);
//         } else {
//             realPayAmount = userOpen.depositAmount;
//             realSaleAmount = calculSaleToken(depositAmount);
//         }

//         return (realPayAmount, realSaleAmount, returnAmount);
//     }
    
//     /// @inheritdoc IPublicSale
//     function totalOpenSaleAmount() public override view returns (uint256){
//         uint256 _calculSaleToken = calculSaleToken(totalDepositAmount);
//         uint256 _totalAmount = totalExpectOpenSaleAmountView();

//         if(_calculSaleToken < _totalAmount) return _calculSaleToken;
//         else return _totalAmount;
//     }

//     /// @inheritdoc IPublicSale
//     function totalOpenPurchasedAmount() public override view returns (uint256){
//         uint256 _calculSaleToken = calculSaleToken(totalDepositAmount);
//         uint256 _totalAmount = totalExpectOpenSaleAmountView();
//         if(_calculSaleToken < _totalAmount) return totalDepositAmount;
//         else return  calculPayToken(_totalAmount);
//     }

//     /// @inheritdoc IPublicSale
//     function addWhiteList() external override nonReentrant {
//         require(
//             block.timestamp >= startAddWhiteTime,
//             "PublicSale: whitelistStartTime has not passed"
//         );
//         require(
//             block.timestamp < endAddWhiteTime,
//             "PublicSale: end the whitelistTime"
//         );
//         uint256 tier = calculTier(msg.sender);
//         require(tier >= 1, "PublicSale: need to more sTOS");
//         UserInfoEx storage userEx = usersEx[msg.sender];
//         require(userEx.join != true, "PublicSale: already attended");

//         whitelists.push(msg.sender);
//         totalWhitelists = totalWhitelists.add(1);

//         userEx.join = true;
//         userEx.tier = tier;
//         userEx.saleAmount = 0;
//         tiersAccount[tier] = tiersAccount[tier].add(1);

//         emit AddedWhiteList(msg.sender, tier);
//     }

//     /// @inheritdoc IPublicSale
//     function exclusiveSale(uint256 _amount)
//         external
//         override
//         nonZero(_amount)
//         nonZero(claimPeriod)
//         nonReentrant
//     {
//         require(
//             block.timestamp >= startExclusiveTime,
//             "PublicSale: exclusiveStartTime has not passed"
//         );
//         require(
//             block.timestamp < endExclusiveTime,
//             "PublicSale: end the exclusiveTime"
//         );
//         UserInfoEx storage userEx = usersEx[msg.sender];
//         require(userEx.join == true, "PublicSale: not registered in whitelist");
//         uint256 tokenSaleAmount = calculSaleToken(_amount);
//         uint256 salePossible = calculTierAmount(msg.sender);

//         require(
//             salePossible >= userEx.saleAmount.add(tokenSaleAmount),
//             "PublicSale: just buy tier's allocated amount"
//         );

//         if(userEx.payAmount == 0) {
//             totalRound1Users = totalRound1Users.add(1);
//             totalUsers = totalUsers.add(1);
//         }

//         userEx.payAmount = userEx.payAmount.add(_amount);
//         userEx.saleAmount = userEx.saleAmount.add(tokenSaleAmount);

//         totalExPurchasedAmount = totalExPurchasedAmount.add(_amount);
//         totalExSaleAmount = totalExSaleAmount.add(tokenSaleAmount);

//         uint256 tier = calculTier(msg.sender);
//         tiersExAccount[tier] = tiersExAccount[tier].add(1);
        
//         uint256 tonAllowance = getToken.allowance(msg.sender, address(this));
//         uint256 tonBalance = getToken.balanceOf(msg.sender);
//         if(tonAllowance < _amount) {
//             uint256 needUserWton;
//             uint256 needWton = _amount.sub(tonAllowance);
//             needUserWton = _toRAY(needWton);
//             require(IWTON(wton).allowance(msg.sender, address(this)) >= needUserWton, "PublicSale: wton amount exceeds allowance");
//             require(IWTON(wton).balanceOf(msg.sender) >= needUserWton, "need more wton");
//             IERC20(wton).safeTransferFrom(msg.sender,address(this),needUserWton);
//             IWTON(wton).swapToTON(needUserWton);
//             require(tonAllowance >= _amount.sub(needWton), "PublicSale: ton amount exceeds allowance");
//             if(_amount.sub(needWton) > 0) {
//                 getToken.safeTransferFrom(msg.sender, address(this), _amount.sub(needWton));   
//             }
//             getToken.safeTransfer(getTokenOwner, _amount);
//         } else {
//             require(tonAllowance >= _amount && tonBalance >= _amount, "PublicSale: ton amount exceeds allowance");

//             getToken.safeTransferFrom(msg.sender, address(this), _amount);
//             getToken.safeTransfer(getTokenOwner, _amount);
//         }

//         emit ExclusiveSaled(msg.sender, _amount);
//     }

//     /// @inheritdoc IPublicSale
//     function deposit(uint256 _amount) external override nonReentrant {
//         require(
//             block.timestamp >= startDepositTime,
//             "PublicSale: don't start depositTime"
//         );
//         require(
//             block.timestamp < endDepositTime,
//             "PublicSale: end the depositTime"
//         );

//         UserInfoOpen storage userOpen = usersOpen[msg.sender];

//         if (!userOpen.join) {
//             depositors.push(msg.sender);
//             userOpen.join = true;

//             totalRound2Users = totalRound2Users.add(1);
//             UserInfoEx storage userEx = usersEx[msg.sender];
//             if(userEx.payAmount == 0) totalUsers = totalUsers.add(1);
//         }
//         userOpen.depositAmount = userOpen.depositAmount.add(_amount);
//         userOpen.saleAmount = 0;
//         totalDepositAmount = totalDepositAmount.add(_amount);

//         uint256 tonAllowance = getToken.allowance(msg.sender, address(this));
//         uint256 tonBalance = getToken.balanceOf(msg.sender);
//         if(tonAllowance < _amount) {
//             uint256 needUserWton;
//             uint256 needWton = _amount.sub(tonAllowance);
//             needUserWton = _toRAY(needWton);
//             require(IWTON(wton).allowance(msg.sender, address(this)) >= needUserWton, "PublicSale: wton amount exceeds allowance");
//             require(IWTON(wton).balanceOf(msg.sender) >= needUserWton, "need more wton");
//             IERC20(wton).safeTransferFrom(msg.sender,address(this),needUserWton);
//             IWTON(wton).swapToTON(needUserWton);
//             require(tonAllowance >= _amount.sub(needWton), "PublicSale: ton amount exceeds allowance");
//             if(_amount.sub(needWton) > 0) {
//                 getToken.safeTransferFrom(msg.sender, address(this), _amount.sub(needWton));   
//             }
//         } else {
//             require(tonAllowance >= _amount && tonBalance >= _amount, "PublicSale: ton amount exceeds allowance");

//             getToken.safeTransferFrom(msg.sender, address(this), _amount);
//         }


//         emit Deposited(msg.sender, _amount);
//     }

//     /// @inheritdoc IPublicSale
//     function claim() external override {
//         require(
//             block.timestamp >= startClaimTime,
//             "PublicSale: don't start claimTime"
//         );
//         UserClaim storage userClaim = usersClaim[msg.sender];
//         UserInfoOpen storage userOpen = usersOpen[msg.sender];

//         (, uint256 realSaleAmount, ) = totalSaleUserAmount(msg.sender);
//         (, ,uint256 refundAmount ) = openSaleUserAmount(msg.sender);

//         require(
//             realSaleAmount > 0,
//             "PublicSale: no purchase amount"
//         );

//         (uint256 reward, ) = calculClaimAmount(msg.sender, 0);
//         require(reward > 0, "PublicSale: no reward");
//         require(
//             realSaleAmount.sub(userClaim.claimAmount) >= reward,
//             "PublicSale: user is already getAllreward"
//         );
//         require(
//             saleToken.balanceOf(address(this)) >= reward,
//             "PublicSale: dont have saleToken in pool"
//         );

//         userClaim.claimAmount = userClaim.claimAmount.add(reward);

//         saleToken.safeTransfer(msg.sender, reward);

//         if(!userClaim.exec && userOpen.join) {
//             totalRound2UsersClaim = totalRound2UsersClaim.add(1);
//             userClaim.exec = true;
//         }

//         if(refundAmount > 0 && userClaim.refundAmount == 0){
//             require(refundAmount <= getToken.balanceOf(address(this)), "PublicSale: dont have refund ton");
//             userClaim.refundAmount = refundAmount;
//             getToken.safeTransfer(msg.sender, refundAmount);
//         }

//         emit Claimed(msg.sender, reward);
//     }
    
//     /// @inheritdoc IPublicSale
//     function depositWithdraw() external override onlyOwner {
//         require(block.timestamp > endDepositTime,"PublicSale: need to end the depositTime");
//         uint256 getAmount;
//         if(totalRound2Users == totalRound2UsersClaim){
//             getAmount = getToken.balanceOf(address(this));
//         } else {
//             getAmount = totalOpenPurchasedAmount().sub(10 ether);
//         }
//         require(getAmount <= getToken.balanceOf(address(this)), "PublicSale: no token to receive");
//         getToken.safeTransfer(getTokenOwner, getAmount);
//         emit DepositWithdrawal(msg.sender, getAmount);
//     }

//     /// @inheritdoc IPublicSale
//     function withdraw() external override onlyOwner{
//         if(block.timestamp <= endDepositTime){
//             uint256 balance = saleToken.balanceOf(address(this));
//             require(balance > totalExpectSaleAmount.add(totalExpectOpenSaleAmount), "PublicSale: no withdrawable amount");
//             uint256 withdrawAmount = balance.sub(totalExpectSaleAmount.add(totalExpectOpenSaleAmount));
//             require(withdrawAmount != 0, "PublicSale: don't exist withdrawAmount");
//             saleToken.safeTransfer(msg.sender, withdrawAmount);
//             emit Withdrawal(msg.sender, withdrawAmount);
//         } else {
//             require(block.timestamp > endDepositTime, "PublicSale: end the openSaleTime");
//             require(!adminWithdraw, "already admin called withdraw");
//             adminWithdraw = true;
//             uint256 saleAmount = totalOpenSaleAmount();
//             require(totalExpectSaleAmount.add(totalExpectOpenSaleAmount) > totalExSaleAmount.add(saleAmount), "PublicSale: don't exist withdrawAmount");

//             uint256 withdrawAmount = totalExpectSaleAmount.add(totalExpectOpenSaleAmount).sub(totalExSaleAmount).sub(saleAmount);

//             require(withdrawAmount != 0, "PublicSale: don't exist withdrawAmount");
//             saleToken.safeTransfer(msg.sender, withdrawAmount);
//             emit Withdrawal(msg.sender, withdrawAmount);
//         }
//     }
// }


// File contracts/tokens/WETH9.sol

//SPDX-License-Identifier: Unlicense
pragma solidity ^0.7.6;

contract WETH9 {
    string public name = "Wrapped Ether";
    string public symbol = "WETH";
    uint8 public decimals = 18;

    event Approval(address indexed src, address indexed guy, uint256 wad);
    event Transfer(address indexed src, address indexed dst, uint256 wad);
    event Deposit(address indexed dst, uint256 wad);
    event Withdrawal(address indexed src, uint256 wad);

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    receive() external payable {
        deposit();
    }

    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 wad) public {
        require(balanceOf[msg.sender] >= wad);
        balanceOf[msg.sender] -= wad;
        msg.sender.transfer(wad);
        emit Withdrawal(msg.sender, wad);
    }

    function totalSupply() public view returns (uint256) {
        return address(this).balance;
    }

    function approve(address guy, uint256 wad) public returns (bool) {
        allowance[msg.sender][guy] = wad;
        emit Approval(msg.sender, guy, wad);
        return true;
    }

    function transfer(address dst, uint256 wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(
        address src,
        address dst,
        uint256 wad
    ) public returns (bool) {
        require(balanceOf[src] >= wad);

        if (src != msg.sender && allowance[src][msg.sender] != uint256(-1)) {
            require(allowance[src][msg.sender] >= wad);
            allowance[src][msg.sender] -= wad;
        }

        balanceOf[src] -= wad;
        balanceOf[dst] += wad;

        emit Transfer(src, dst, wad);

        return true;
    }

    // used for overflow testing
    function testSetBalance(address account, uint256 amount) external {
        balanceOf[account] = amount;
    }
}
